"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bootstrap";
exports.ids = ["vendor-chunks/bootstrap"];
exports.modules = {

/***/ "(ssr)/./node_modules/bootstrap/dist/js/bootstrap.js":
/*!*****************************************************!*\
  !*** ./node_modules/bootstrap/dist/js/bootstrap.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/*!\n  * Bootstrap v5.3.2 (https://getbootstrap.com/)\n  * Copyright 2011-2023 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n  */ (function(global, factory) {\n     true ? module.exports = factory(__webpack_require__(/*! @popperjs/core */ \"(ssr)/./node_modules/@popperjs/core/lib/index.js\")) : 0;\n})(void 0, function(Popper) {\n    \"use strict\";\n    function _interopNamespaceDefault(e) {\n        const n = Object.create(null, {\n            [Symbol.toStringTag]: {\n                value: \"Module\"\n            }\n        });\n        if (e) {\n            for(const k in e){\n                if (k !== \"default\") {\n                    const d = Object.getOwnPropertyDescriptor(e, k);\n                    Object.defineProperty(n, k, d.get ? d : {\n                        enumerable: true,\n                        get: ()=>e[k]\n                    });\n                }\n            }\n        }\n        n.default = e;\n        return Object.freeze(n);\n    }\n    const Popper__namespace = /*#__PURE__*/ _interopNamespaceDefault(Popper);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap dom/data.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const elementMap = new Map();\n    const Data = {\n        set (element, key, instance) {\n            if (!elementMap.has(element)) {\n                elementMap.set(element, new Map());\n            }\n            const instanceMap = elementMap.get(element);\n            // make it clear we only want one instance per element\n            // can be removed later when multiple key/instances are fine to be used\n            if (!instanceMap.has(key) && instanceMap.size !== 0) {\n                // eslint-disable-next-line no-console\n                console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);\n                return;\n            }\n            instanceMap.set(key, instance);\n        },\n        get (element, key) {\n            if (elementMap.has(element)) {\n                return elementMap.get(element).get(key) || null;\n            }\n            return null;\n        },\n        remove (element, key) {\n            if (!elementMap.has(element)) {\n                return;\n            }\n            const instanceMap = elementMap.get(element);\n            instanceMap.delete(key);\n            // free up element references if there are no instances left for an element\n            if (instanceMap.size === 0) {\n                elementMap.delete(element);\n            }\n        }\n    };\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap util/index.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ const MAX_UID = 1000000;\n    const MILLISECONDS_MULTIPLIER = 1000;\n    const TRANSITION_END = \"transitionend\";\n    /**\n   * Properly escape IDs selectors to handle weird IDs\n   * @param {string} selector\n   * @returns {string}\n   */ const parseSelector = (selector)=>{\n        if (selector && window.CSS && window.CSS.escape) {\n            // document.querySelector needs escaping to handle IDs (html5+) containing for instance /\n            selector = selector.replace(/#([^\\s\"#']+)/g, (match, id)=>`#${CSS.escape(id)}`);\n        }\n        return selector;\n    };\n    // Shout-out Angus Croll (https://goo.gl/pxwQGp)\n    const toType = (object)=>{\n        if (object === null || object === undefined) {\n            return `${object}`;\n        }\n        return Object.prototype.toString.call(object).match(/\\s([a-z]+)/i)[1].toLowerCase();\n    };\n    /**\n   * Public Util API\n   */ const getUID = (prefix)=>{\n        do {\n            prefix += Math.floor(Math.random() * MAX_UID);\n        }while (document.getElementById(prefix));\n        return prefix;\n    };\n    const getTransitionDurationFromElement = (element)=>{\n        if (!element) {\n            return 0;\n        }\n        // Get transition-duration of the element\n        let { transitionDuration, transitionDelay } = window.getComputedStyle(element);\n        const floatTransitionDuration = Number.parseFloat(transitionDuration);\n        const floatTransitionDelay = Number.parseFloat(transitionDelay);\n        // Return 0 if element or transition duration is not found\n        if (!floatTransitionDuration && !floatTransitionDelay) {\n            return 0;\n        }\n        // If multiple durations are defined, take the first\n        transitionDuration = transitionDuration.split(\",\")[0];\n        transitionDelay = transitionDelay.split(\",\")[0];\n        return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;\n    };\n    const triggerTransitionEnd = (element)=>{\n        element.dispatchEvent(new Event(TRANSITION_END));\n    };\n    const isElement = (object)=>{\n        if (!object || typeof object !== \"object\") {\n            return false;\n        }\n        if (typeof object.jquery !== \"undefined\") {\n            object = object[0];\n        }\n        return typeof object.nodeType !== \"undefined\";\n    };\n    const getElement = (object)=>{\n        // it's a jQuery object or a node element\n        if (isElement(object)) {\n            return object.jquery ? object[0] : object;\n        }\n        if (typeof object === \"string\" && object.length > 0) {\n            return document.querySelector(parseSelector(object));\n        }\n        return null;\n    };\n    const isVisible = (element)=>{\n        if (!isElement(element) || element.getClientRects().length === 0) {\n            return false;\n        }\n        const elementIsVisible = getComputedStyle(element).getPropertyValue(\"visibility\") === \"visible\";\n        // Handle `details` element as its content may falsie appear visible when it is closed\n        const closedDetails = element.closest(\"details:not([open])\");\n        if (!closedDetails) {\n            return elementIsVisible;\n        }\n        if (closedDetails !== element) {\n            const summary = element.closest(\"summary\");\n            if (summary && summary.parentNode !== closedDetails) {\n                return false;\n            }\n            if (summary === null) {\n                return false;\n            }\n        }\n        return elementIsVisible;\n    };\n    const isDisabled = (element)=>{\n        if (!element || element.nodeType !== Node.ELEMENT_NODE) {\n            return true;\n        }\n        if (element.classList.contains(\"disabled\")) {\n            return true;\n        }\n        if (typeof element.disabled !== \"undefined\") {\n            return element.disabled;\n        }\n        return element.hasAttribute(\"disabled\") && element.getAttribute(\"disabled\") !== \"false\";\n    };\n    const findShadowRoot = (element)=>{\n        if (!document.documentElement.attachShadow) {\n            return null;\n        }\n        // Can find the shadow root otherwise it'll return the document\n        if (typeof element.getRootNode === \"function\") {\n            const root = element.getRootNode();\n            return root instanceof ShadowRoot ? root : null;\n        }\n        if (element instanceof ShadowRoot) {\n            return element;\n        }\n        // when we don't find a shadow root\n        if (!element.parentNode) {\n            return null;\n        }\n        return findShadowRoot(element.parentNode);\n    };\n    const noop = ()=>{};\n    /**\n   * Trick to restart an element's animation\n   *\n   * @param {HTMLElement} element\n   * @return void\n   *\n   * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation\n   */ const reflow = (element)=>{\n        element.offsetHeight; // eslint-disable-line no-unused-expressions\n    };\n    const getjQuery = ()=>{\n        if (window.jQuery && !document.body.hasAttribute(\"data-bs-no-jquery\")) {\n            return window.jQuery;\n        }\n        return null;\n    };\n    const DOMContentLoadedCallbacks = [];\n    const onDOMContentLoaded = (callback)=>{\n        if (document.readyState === \"loading\") {\n            // add listener on the first call when the document is in loading state\n            if (!DOMContentLoadedCallbacks.length) {\n                document.addEventListener(\"DOMContentLoaded\", ()=>{\n                    for (const callback of DOMContentLoadedCallbacks){\n                        callback();\n                    }\n                });\n            }\n            DOMContentLoadedCallbacks.push(callback);\n        } else {\n            callback();\n        }\n    };\n    const isRTL = ()=>document.documentElement.dir === \"rtl\";\n    const defineJQueryPlugin = (plugin)=>{\n        onDOMContentLoaded(()=>{\n            const $ = getjQuery();\n            /* istanbul ignore if */ if ($) {\n                const name = plugin.NAME;\n                const JQUERY_NO_CONFLICT = $.fn[name];\n                $.fn[name] = plugin.jQueryInterface;\n                $.fn[name].Constructor = plugin;\n                $.fn[name].noConflict = ()=>{\n                    $.fn[name] = JQUERY_NO_CONFLICT;\n                    return plugin.jQueryInterface;\n                };\n            }\n        });\n    };\n    const execute = (possibleCallback, args = [], defaultValue = possibleCallback)=>{\n        return typeof possibleCallback === \"function\" ? possibleCallback(...args) : defaultValue;\n    };\n    const executeAfterTransition = (callback, transitionElement, waitForTransition = true)=>{\n        if (!waitForTransition) {\n            execute(callback);\n            return;\n        }\n        const durationPadding = 5;\n        const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;\n        let called = false;\n        const handler = ({ target })=>{\n            if (target !== transitionElement) {\n                return;\n            }\n            called = true;\n            transitionElement.removeEventListener(TRANSITION_END, handler);\n            execute(callback);\n        };\n        transitionElement.addEventListener(TRANSITION_END, handler);\n        setTimeout(()=>{\n            if (!called) {\n                triggerTransitionEnd(transitionElement);\n            }\n        }, emulatedDuration);\n    };\n    /**\n   * Return the previous/next element of a list.\n   *\n   * @param {array} list    The list of elements\n   * @param activeElement   The active element\n   * @param shouldGetNext   Choose to get next or previous element\n   * @param isCycleAllowed\n   * @return {Element|elem} The proper element\n   */ const getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed)=>{\n        const listLength = list.length;\n        let index = list.indexOf(activeElement);\n        // if the element does not exist in the list return an element\n        // depending on the direction and if cycle is allowed\n        if (index === -1) {\n            return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];\n        }\n        index += shouldGetNext ? 1 : -1;\n        if (isCycleAllowed) {\n            index = (index + listLength) % listLength;\n        }\n        return list[Math.max(0, Math.min(index, listLength - 1))];\n    };\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap dom/event-handler.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const namespaceRegex = /[^.]*(?=\\..*)\\.|.*/;\n    const stripNameRegex = /\\..*/;\n    const stripUidRegex = /::\\d+$/;\n    const eventRegistry = {}; // Events storage\n    let uidEvent = 1;\n    const customEvents = {\n        mouseenter: \"mouseover\",\n        mouseleave: \"mouseout\"\n    };\n    const nativeEvents = new Set([\n        \"click\",\n        \"dblclick\",\n        \"mouseup\",\n        \"mousedown\",\n        \"contextmenu\",\n        \"mousewheel\",\n        \"DOMMouseScroll\",\n        \"mouseover\",\n        \"mouseout\",\n        \"mousemove\",\n        \"selectstart\",\n        \"selectend\",\n        \"keydown\",\n        \"keypress\",\n        \"keyup\",\n        \"orientationchange\",\n        \"touchstart\",\n        \"touchmove\",\n        \"touchend\",\n        \"touchcancel\",\n        \"pointerdown\",\n        \"pointermove\",\n        \"pointerup\",\n        \"pointerleave\",\n        \"pointercancel\",\n        \"gesturestart\",\n        \"gesturechange\",\n        \"gestureend\",\n        \"focus\",\n        \"blur\",\n        \"change\",\n        \"reset\",\n        \"select\",\n        \"submit\",\n        \"focusin\",\n        \"focusout\",\n        \"load\",\n        \"unload\",\n        \"beforeunload\",\n        \"resize\",\n        \"move\",\n        \"DOMContentLoaded\",\n        \"readystatechange\",\n        \"error\",\n        \"abort\",\n        \"scroll\"\n    ]);\n    /**\n   * Private methods\n   */ function makeEventUid(element, uid) {\n        return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;\n    }\n    function getElementEvents(element) {\n        const uid = makeEventUid(element);\n        element.uidEvent = uid;\n        eventRegistry[uid] = eventRegistry[uid] || {};\n        return eventRegistry[uid];\n    }\n    function bootstrapHandler(element, fn) {\n        return function handler(event) {\n            hydrateObj(event, {\n                delegateTarget: element\n            });\n            if (handler.oneOff) {\n                EventHandler.off(element, event.type, fn);\n            }\n            return fn.apply(element, [\n                event\n            ]);\n        };\n    }\n    function bootstrapDelegationHandler(element, selector, fn) {\n        return function handler(event) {\n            const domElements = element.querySelectorAll(selector);\n            for(let { target } = event; target && target !== this; target = target.parentNode){\n                for (const domElement of domElements){\n                    if (domElement !== target) {\n                        continue;\n                    }\n                    hydrateObj(event, {\n                        delegateTarget: target\n                    });\n                    if (handler.oneOff) {\n                        EventHandler.off(element, event.type, selector, fn);\n                    }\n                    return fn.apply(target, [\n                        event\n                    ]);\n                }\n            }\n        };\n    }\n    function findHandler(events, callable, delegationSelector = null) {\n        return Object.values(events).find((event)=>event.callable === callable && event.delegationSelector === delegationSelector);\n    }\n    function normalizeParameters(originalTypeEvent, handler, delegationFunction) {\n        const isDelegated = typeof handler === \"string\";\n        // TODO: tooltip passes `false` instead of selector, so we need to check\n        const callable = isDelegated ? delegationFunction : handler || delegationFunction;\n        let typeEvent = getTypeEvent(originalTypeEvent);\n        if (!nativeEvents.has(typeEvent)) {\n            typeEvent = originalTypeEvent;\n        }\n        return [\n            isDelegated,\n            callable,\n            typeEvent\n        ];\n    }\n    function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {\n        if (typeof originalTypeEvent !== \"string\" || !element) {\n            return;\n        }\n        let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);\n        // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position\n        // this prevents the handler from being dispatched the same way as mouseover or mouseout does\n        if (originalTypeEvent in customEvents) {\n            const wrapFunction = (fn)=>{\n                return function(event) {\n                    if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {\n                        return fn.call(this, event);\n                    }\n                };\n            };\n            callable = wrapFunction(callable);\n        }\n        const events = getElementEvents(element);\n        const handlers = events[typeEvent] || (events[typeEvent] = {});\n        const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);\n        if (previousFunction) {\n            previousFunction.oneOff = previousFunction.oneOff && oneOff;\n            return;\n        }\n        const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, \"\"));\n        const fn = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);\n        fn.delegationSelector = isDelegated ? handler : null;\n        fn.callable = callable;\n        fn.oneOff = oneOff;\n        fn.uidEvent = uid;\n        handlers[uid] = fn;\n        element.addEventListener(typeEvent, fn, isDelegated);\n    }\n    function removeHandler(element, events, typeEvent, handler, delegationSelector) {\n        const fn = findHandler(events[typeEvent], handler, delegationSelector);\n        if (!fn) {\n            return;\n        }\n        element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));\n        delete events[typeEvent][fn.uidEvent];\n    }\n    function removeNamespacedHandlers(element, events, typeEvent, namespace) {\n        const storeElementEvent = events[typeEvent] || {};\n        for (const [handlerKey, event] of Object.entries(storeElementEvent)){\n            if (handlerKey.includes(namespace)) {\n                removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);\n            }\n        }\n    }\n    function getTypeEvent(event) {\n        // allow to get the native events from namespaced events ('click.bs.button' --> 'click')\n        event = event.replace(stripNameRegex, \"\");\n        return customEvents[event] || event;\n    }\n    const EventHandler = {\n        on (element, event, handler, delegationFunction) {\n            addHandler(element, event, handler, delegationFunction, false);\n        },\n        one (element, event, handler, delegationFunction) {\n            addHandler(element, event, handler, delegationFunction, true);\n        },\n        off (element, originalTypeEvent, handler, delegationFunction) {\n            if (typeof originalTypeEvent !== \"string\" || !element) {\n                return;\n            }\n            const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);\n            const inNamespace = typeEvent !== originalTypeEvent;\n            const events = getElementEvents(element);\n            const storeElementEvent = events[typeEvent] || {};\n            const isNamespace = originalTypeEvent.startsWith(\".\");\n            if (typeof callable !== \"undefined\") {\n                // Simplest case: handler is passed, remove that listener ONLY.\n                if (!Object.keys(storeElementEvent).length) {\n                    return;\n                }\n                removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);\n                return;\n            }\n            if (isNamespace) {\n                for (const elementEvent of Object.keys(events)){\n                    removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));\n                }\n            }\n            for (const [keyHandlers, event] of Object.entries(storeElementEvent)){\n                const handlerKey = keyHandlers.replace(stripUidRegex, \"\");\n                if (!inNamespace || originalTypeEvent.includes(handlerKey)) {\n                    removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);\n                }\n            }\n        },\n        trigger (element, event, args) {\n            if (typeof event !== \"string\" || !element) {\n                return null;\n            }\n            const $ = getjQuery();\n            const typeEvent = getTypeEvent(event);\n            const inNamespace = event !== typeEvent;\n            let jQueryEvent = null;\n            let bubbles = true;\n            let nativeDispatch = true;\n            let defaultPrevented = false;\n            if (inNamespace && $) {\n                jQueryEvent = $.Event(event, args);\n                $(element).trigger(jQueryEvent);\n                bubbles = !jQueryEvent.isPropagationStopped();\n                nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();\n                defaultPrevented = jQueryEvent.isDefaultPrevented();\n            }\n            const evt = hydrateObj(new Event(event, {\n                bubbles,\n                cancelable: true\n            }), args);\n            if (defaultPrevented) {\n                evt.preventDefault();\n            }\n            if (nativeDispatch) {\n                element.dispatchEvent(evt);\n            }\n            if (evt.defaultPrevented && jQueryEvent) {\n                jQueryEvent.preventDefault();\n            }\n            return evt;\n        }\n    };\n    function hydrateObj(obj, meta = {}) {\n        for (const [key, value] of Object.entries(meta)){\n            try {\n                obj[key] = value;\n            } catch (_unused) {\n                Object.defineProperty(obj, key, {\n                    configurable: true,\n                    get () {\n                        return value;\n                    }\n                });\n            }\n        }\n        return obj;\n    }\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap dom/manipulator.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ function normalizeData(value) {\n        if (value === \"true\") {\n            return true;\n        }\n        if (value === \"false\") {\n            return false;\n        }\n        if (value === Number(value).toString()) {\n            return Number(value);\n        }\n        if (value === \"\" || value === \"null\") {\n            return null;\n        }\n        if (typeof value !== \"string\") {\n            return value;\n        }\n        try {\n            return JSON.parse(decodeURIComponent(value));\n        } catch (_unused) {\n            return value;\n        }\n    }\n    function normalizeDataKey(key) {\n        return key.replace(/[A-Z]/g, (chr)=>`-${chr.toLowerCase()}`);\n    }\n    const Manipulator = {\n        setDataAttribute (element, key, value) {\n            element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);\n        },\n        removeDataAttribute (element, key) {\n            element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);\n        },\n        getDataAttributes (element) {\n            if (!element) {\n                return {};\n            }\n            const attributes = {};\n            const bsKeys = Object.keys(element.dataset).filter((key)=>key.startsWith(\"bs\") && !key.startsWith(\"bsConfig\"));\n            for (const key of bsKeys){\n                let pureKey = key.replace(/^bs/, \"\");\n                pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);\n                attributes[pureKey] = normalizeData(element.dataset[key]);\n            }\n            return attributes;\n        },\n        getDataAttribute (element, key) {\n            return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));\n        }\n    };\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap util/config.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Class definition\n   */ class Config {\n        // Getters\n        static get Default() {\n            return {};\n        }\n        static get DefaultType() {\n            return {};\n        }\n        static get NAME() {\n            throw new Error('You have to implement the static method \"NAME\", for each component!');\n        }\n        _getConfig(config) {\n            config = this._mergeConfigObj(config);\n            config = this._configAfterMerge(config);\n            this._typeCheckConfig(config);\n            return config;\n        }\n        _configAfterMerge(config) {\n            return config;\n        }\n        _mergeConfigObj(config, element) {\n            const jsonConfig = isElement(element) ? Manipulator.getDataAttribute(element, \"config\") : {}; // try to parse\n            return {\n                ...this.constructor.Default,\n                ...typeof jsonConfig === \"object\" ? jsonConfig : {},\n                ...isElement(element) ? Manipulator.getDataAttributes(element) : {},\n                ...typeof config === \"object\" ? config : {}\n            };\n        }\n        _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {\n            for (const [property, expectedTypes] of Object.entries(configTypes)){\n                const value = config[property];\n                const valueType = isElement(value) ? \"element\" : toType(value);\n                if (!new RegExp(expectedTypes).test(valueType)) {\n                    throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option \"${property}\" provided type \"${valueType}\" but expected type \"${expectedTypes}\".`);\n                }\n            }\n        }\n    }\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap base-component.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const VERSION = \"5.3.2\";\n    /**\n   * Class definition\n   */ class BaseComponent extends Config {\n        constructor(element, config){\n            super();\n            element = getElement(element);\n            if (!element) {\n                return;\n            }\n            this._element = element;\n            this._config = this._getConfig(config);\n            Data.set(this._element, this.constructor.DATA_KEY, this);\n        }\n        // Public\n        dispose() {\n            Data.remove(this._element, this.constructor.DATA_KEY);\n            EventHandler.off(this._element, this.constructor.EVENT_KEY);\n            for (const propertyName of Object.getOwnPropertyNames(this)){\n                this[propertyName] = null;\n            }\n        }\n        _queueCallback(callback, element, isAnimated = true) {\n            executeAfterTransition(callback, element, isAnimated);\n        }\n        _getConfig(config) {\n            config = this._mergeConfigObj(config, this._element);\n            config = this._configAfterMerge(config);\n            this._typeCheckConfig(config);\n            return config;\n        }\n        // Static\n        static getInstance(element) {\n            return Data.get(getElement(element), this.DATA_KEY);\n        }\n        static getOrCreateInstance(element, config = {}) {\n            return this.getInstance(element) || new this(element, typeof config === \"object\" ? config : null);\n        }\n        static get VERSION() {\n            return VERSION;\n        }\n        static get DATA_KEY() {\n            return `bs.${this.NAME}`;\n        }\n        static get EVENT_KEY() {\n            return `.${this.DATA_KEY}`;\n        }\n        static eventName(name) {\n            return `${name}${this.EVENT_KEY}`;\n        }\n    }\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap dom/selector-engine.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ const getSelector = (element)=>{\n        let selector = element.getAttribute(\"data-bs-target\");\n        if (!selector || selector === \"#\") {\n            let hrefAttribute = element.getAttribute(\"href\");\n            // The only valid content that could double as a selector are IDs or classes,\n            // so everything starting with `#` or `.`. If a \"real\" URL is used as the selector,\n            // `document.querySelector` will rightfully complain it is invalid.\n            // See https://github.com/twbs/bootstrap/issues/32273\n            if (!hrefAttribute || !hrefAttribute.includes(\"#\") && !hrefAttribute.startsWith(\".\")) {\n                return null;\n            }\n            // Just in case some CMS puts out a full URL with the anchor appended\n            if (hrefAttribute.includes(\"#\") && !hrefAttribute.startsWith(\"#\")) {\n                hrefAttribute = `#${hrefAttribute.split(\"#\")[1]}`;\n            }\n            selector = hrefAttribute && hrefAttribute !== \"#\" ? parseSelector(hrefAttribute.trim()) : null;\n        }\n        return selector;\n    };\n    const SelectorEngine = {\n        find (selector, element = document.documentElement) {\n            return [].concat(...Element.prototype.querySelectorAll.call(element, selector));\n        },\n        findOne (selector, element = document.documentElement) {\n            return Element.prototype.querySelector.call(element, selector);\n        },\n        children (element, selector) {\n            return [].concat(...element.children).filter((child)=>child.matches(selector));\n        },\n        parents (element, selector) {\n            const parents = [];\n            let ancestor = element.parentNode.closest(selector);\n            while(ancestor){\n                parents.push(ancestor);\n                ancestor = ancestor.parentNode.closest(selector);\n            }\n            return parents;\n        },\n        prev (element, selector) {\n            let previous = element.previousElementSibling;\n            while(previous){\n                if (previous.matches(selector)) {\n                    return [\n                        previous\n                    ];\n                }\n                previous = previous.previousElementSibling;\n            }\n            return [];\n        },\n        // TODO: this is now unused; remove later along with prev()\n        next (element, selector) {\n            let next = element.nextElementSibling;\n            while(next){\n                if (next.matches(selector)) {\n                    return [\n                        next\n                    ];\n                }\n                next = next.nextElementSibling;\n            }\n            return [];\n        },\n        focusableChildren (element) {\n            const focusables = [\n                \"a\",\n                \"button\",\n                \"input\",\n                \"textarea\",\n                \"select\",\n                \"details\",\n                \"[tabindex]\",\n                '[contenteditable=\"true\"]'\n            ].map((selector)=>`${selector}:not([tabindex^=\"-\"])`).join(\",\");\n            return this.find(focusables, element).filter((el)=>!isDisabled(el) && isVisible(el));\n        },\n        getSelectorFromElement (element) {\n            const selector = getSelector(element);\n            if (selector) {\n                return SelectorEngine.findOne(selector) ? selector : null;\n            }\n            return null;\n        },\n        getElementFromSelector (element) {\n            const selector = getSelector(element);\n            return selector ? SelectorEngine.findOne(selector) : null;\n        },\n        getMultipleElementsFromSelector (element) {\n            const selector = getSelector(element);\n            return selector ? SelectorEngine.find(selector) : [];\n        }\n    };\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap util/component-functions.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ const enableDismissTrigger = (component, method = \"hide\")=>{\n        const clickEvent = `click.dismiss${component.EVENT_KEY}`;\n        const name = component.NAME;\n        EventHandler.on(document, clickEvent, `[data-bs-dismiss=\"${name}\"]`, function(event) {\n            if ([\n                \"A\",\n                \"AREA\"\n            ].includes(this.tagName)) {\n                event.preventDefault();\n            }\n            if (isDisabled(this)) {\n                return;\n            }\n            const target = SelectorEngine.getElementFromSelector(this) || this.closest(`.${name}`);\n            const instance = component.getOrCreateInstance(target);\n            // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method\n            instance[method]();\n        });\n    };\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap alert.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$f = \"alert\";\n    const DATA_KEY$a = \"bs.alert\";\n    const EVENT_KEY$b = `.${DATA_KEY$a}`;\n    const EVENT_CLOSE = `close${EVENT_KEY$b}`;\n    const EVENT_CLOSED = `closed${EVENT_KEY$b}`;\n    const CLASS_NAME_FADE$5 = \"fade\";\n    const CLASS_NAME_SHOW$8 = \"show\";\n    /**\n   * Class definition\n   */ class Alert extends BaseComponent {\n        // Getters\n        static get NAME() {\n            return NAME$f;\n        }\n        // Public\n        close() {\n            const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);\n            if (closeEvent.defaultPrevented) {\n                return;\n            }\n            this._element.classList.remove(CLASS_NAME_SHOW$8);\n            const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);\n            this._queueCallback(()=>this._destroyElement(), this._element, isAnimated);\n        }\n        // Private\n        _destroyElement() {\n            this._element.remove();\n            EventHandler.trigger(this._element, EVENT_CLOSED);\n            this.dispose();\n        }\n        // Static\n        static jQueryInterface(config) {\n            return this.each(function() {\n                const data = Alert.getOrCreateInstance(this);\n                if (typeof config !== \"string\") {\n                    return;\n                }\n                if (data[config] === undefined || config.startsWith(\"_\") || config === \"constructor\") {\n                    throw new TypeError(`No method named \"${config}\"`);\n                }\n                data[config](this);\n            });\n        }\n    }\n    /**\n   * Data API implementation\n   */ enableDismissTrigger(Alert, \"close\");\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Alert);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap button.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$e = \"button\";\n    const DATA_KEY$9 = \"bs.button\";\n    const EVENT_KEY$a = `.${DATA_KEY$9}`;\n    const DATA_API_KEY$6 = \".data-api\";\n    const CLASS_NAME_ACTIVE$3 = \"active\";\n    const SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle=\"button\"]';\n    const EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;\n    /**\n   * Class definition\n   */ class Button extends BaseComponent {\n        // Getters\n        static get NAME() {\n            return NAME$e;\n        }\n        // Public\n        toggle() {\n            // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method\n            this._element.setAttribute(\"aria-pressed\", this._element.classList.toggle(CLASS_NAME_ACTIVE$3));\n        }\n        // Static\n        static jQueryInterface(config) {\n            return this.each(function() {\n                const data = Button.getOrCreateInstance(this);\n                if (config === \"toggle\") {\n                    data[config]();\n                }\n            });\n        }\n    }\n    /**\n   * Data API implementation\n   */ EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, (event)=>{\n        event.preventDefault();\n        const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);\n        const data = Button.getOrCreateInstance(button);\n        data.toggle();\n    });\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Button);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap util/swipe.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$d = \"swipe\";\n    const EVENT_KEY$9 = \".bs.swipe\";\n    const EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;\n    const EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;\n    const EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;\n    const EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;\n    const EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;\n    const POINTER_TYPE_TOUCH = \"touch\";\n    const POINTER_TYPE_PEN = \"pen\";\n    const CLASS_NAME_POINTER_EVENT = \"pointer-event\";\n    const SWIPE_THRESHOLD = 40;\n    const Default$c = {\n        endCallback: null,\n        leftCallback: null,\n        rightCallback: null\n    };\n    const DefaultType$c = {\n        endCallback: \"(function|null)\",\n        leftCallback: \"(function|null)\",\n        rightCallback: \"(function|null)\"\n    };\n    /**\n   * Class definition\n   */ class Swipe extends Config {\n        constructor(element, config){\n            super();\n            this._element = element;\n            if (!element || !Swipe.isSupported()) {\n                return;\n            }\n            this._config = this._getConfig(config);\n            this._deltaX = 0;\n            this._supportPointerEvents = Boolean(window.PointerEvent);\n            this._initEvents();\n        }\n        // Getters\n        static get Default() {\n            return Default$c;\n        }\n        static get DefaultType() {\n            return DefaultType$c;\n        }\n        static get NAME() {\n            return NAME$d;\n        }\n        // Public\n        dispose() {\n            EventHandler.off(this._element, EVENT_KEY$9);\n        }\n        // Private\n        _start(event) {\n            if (!this._supportPointerEvents) {\n                this._deltaX = event.touches[0].clientX;\n                return;\n            }\n            if (this._eventIsPointerPenTouch(event)) {\n                this._deltaX = event.clientX;\n            }\n        }\n        _end(event) {\n            if (this._eventIsPointerPenTouch(event)) {\n                this._deltaX = event.clientX - this._deltaX;\n            }\n            this._handleSwipe();\n            execute(this._config.endCallback);\n        }\n        _move(event) {\n            this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;\n        }\n        _handleSwipe() {\n            const absDeltaX = Math.abs(this._deltaX);\n            if (absDeltaX <= SWIPE_THRESHOLD) {\n                return;\n            }\n            const direction = absDeltaX / this._deltaX;\n            this._deltaX = 0;\n            if (!direction) {\n                return;\n            }\n            execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);\n        }\n        _initEvents() {\n            if (this._supportPointerEvents) {\n                EventHandler.on(this._element, EVENT_POINTERDOWN, (event)=>this._start(event));\n                EventHandler.on(this._element, EVENT_POINTERUP, (event)=>this._end(event));\n                this._element.classList.add(CLASS_NAME_POINTER_EVENT);\n            } else {\n                EventHandler.on(this._element, EVENT_TOUCHSTART, (event)=>this._start(event));\n                EventHandler.on(this._element, EVENT_TOUCHMOVE, (event)=>this._move(event));\n                EventHandler.on(this._element, EVENT_TOUCHEND, (event)=>this._end(event));\n            }\n        }\n        _eventIsPointerPenTouch(event) {\n            return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);\n        }\n        // Static\n        static isSupported() {\n            return \"ontouchstart\" in document.documentElement || navigator.maxTouchPoints > 0;\n        }\n    }\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap carousel.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$c = \"carousel\";\n    const DATA_KEY$8 = \"bs.carousel\";\n    const EVENT_KEY$8 = `.${DATA_KEY$8}`;\n    const DATA_API_KEY$5 = \".data-api\";\n    const ARROW_LEFT_KEY$1 = \"ArrowLeft\";\n    const ARROW_RIGHT_KEY$1 = \"ArrowRight\";\n    const TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch\n    const ORDER_NEXT = \"next\";\n    const ORDER_PREV = \"prev\";\n    const DIRECTION_LEFT = \"left\";\n    const DIRECTION_RIGHT = \"right\";\n    const EVENT_SLIDE = `slide${EVENT_KEY$8}`;\n    const EVENT_SLID = `slid${EVENT_KEY$8}`;\n    const EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`;\n    const EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`;\n    const EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`;\n    const EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`;\n    const EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`;\n    const EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;\n    const CLASS_NAME_CAROUSEL = \"carousel\";\n    const CLASS_NAME_ACTIVE$2 = \"active\";\n    const CLASS_NAME_SLIDE = \"slide\";\n    const CLASS_NAME_END = \"carousel-item-end\";\n    const CLASS_NAME_START = \"carousel-item-start\";\n    const CLASS_NAME_NEXT = \"carousel-item-next\";\n    const CLASS_NAME_PREV = \"carousel-item-prev\";\n    const SELECTOR_ACTIVE = \".active\";\n    const SELECTOR_ITEM = \".carousel-item\";\n    const SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;\n    const SELECTOR_ITEM_IMG = \".carousel-item img\";\n    const SELECTOR_INDICATORS = \".carousel-indicators\";\n    const SELECTOR_DATA_SLIDE = \"[data-bs-slide], [data-bs-slide-to]\";\n    const SELECTOR_DATA_RIDE = '[data-bs-ride=\"carousel\"]';\n    const KEY_TO_DIRECTION = {\n        [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,\n        [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT\n    };\n    const Default$b = {\n        interval: 5000,\n        keyboard: true,\n        pause: \"hover\",\n        ride: false,\n        touch: true,\n        wrap: true\n    };\n    const DefaultType$b = {\n        interval: \"(number|boolean)\",\n        // TODO:v6 remove boolean support\n        keyboard: \"boolean\",\n        pause: \"(string|boolean)\",\n        ride: \"(boolean|string)\",\n        touch: \"boolean\",\n        wrap: \"boolean\"\n    };\n    /**\n   * Class definition\n   */ class Carousel extends BaseComponent {\n        constructor(element, config){\n            super(element, config);\n            this._interval = null;\n            this._activeElement = null;\n            this._isSliding = false;\n            this.touchTimeout = null;\n            this._swipeHelper = null;\n            this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);\n            this._addEventListeners();\n            if (this._config.ride === CLASS_NAME_CAROUSEL) {\n                this.cycle();\n            }\n        }\n        // Getters\n        static get Default() {\n            return Default$b;\n        }\n        static get DefaultType() {\n            return DefaultType$b;\n        }\n        static get NAME() {\n            return NAME$c;\n        }\n        // Public\n        next() {\n            this._slide(ORDER_NEXT);\n        }\n        nextWhenVisible() {\n            // FIXME TODO use `document.visibilityState`\n            // Don't call next when the page isn't visible\n            // or the carousel or its parent isn't visible\n            if (!document.hidden && isVisible(this._element)) {\n                this.next();\n            }\n        }\n        prev() {\n            this._slide(ORDER_PREV);\n        }\n        pause() {\n            if (this._isSliding) {\n                triggerTransitionEnd(this._element);\n            }\n            this._clearInterval();\n        }\n        cycle() {\n            this._clearInterval();\n            this._updateInterval();\n            this._interval = setInterval(()=>this.nextWhenVisible(), this._config.interval);\n        }\n        _maybeEnableCycle() {\n            if (!this._config.ride) {\n                return;\n            }\n            if (this._isSliding) {\n                EventHandler.one(this._element, EVENT_SLID, ()=>this.cycle());\n                return;\n            }\n            this.cycle();\n        }\n        to(index) {\n            const items = this._getItems();\n            if (index > items.length - 1 || index < 0) {\n                return;\n            }\n            if (this._isSliding) {\n                EventHandler.one(this._element, EVENT_SLID, ()=>this.to(index));\n                return;\n            }\n            const activeIndex = this._getItemIndex(this._getActive());\n            if (activeIndex === index) {\n                return;\n            }\n            const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;\n            this._slide(order, items[index]);\n        }\n        dispose() {\n            if (this._swipeHelper) {\n                this._swipeHelper.dispose();\n            }\n            super.dispose();\n        }\n        // Private\n        _configAfterMerge(config) {\n            config.defaultInterval = config.interval;\n            return config;\n        }\n        _addEventListeners() {\n            if (this._config.keyboard) {\n                EventHandler.on(this._element, EVENT_KEYDOWN$1, (event)=>this._keydown(event));\n            }\n            if (this._config.pause === \"hover\") {\n                EventHandler.on(this._element, EVENT_MOUSEENTER$1, ()=>this.pause());\n                EventHandler.on(this._element, EVENT_MOUSELEAVE$1, ()=>this._maybeEnableCycle());\n            }\n            if (this._config.touch && Swipe.isSupported()) {\n                this._addTouchEventListeners();\n            }\n        }\n        _addTouchEventListeners() {\n            for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)){\n                EventHandler.on(img, EVENT_DRAG_START, (event)=>event.preventDefault());\n            }\n            const endCallBack = ()=>{\n                if (this._config.pause !== \"hover\") {\n                    return;\n                }\n                // If it's a touch-enabled device, mouseenter/leave are fired as\n                // part of the mouse compatibility events on first tap - the carousel\n                // would stop cycling until user tapped out of it;\n                // here, we listen for touchend, explicitly pause the carousel\n                // (as if it's the second time we tap on it, mouseenter compat event\n                // is NOT fired) and after a timeout (to allow for mouse compatibility\n                // events to fire) we explicitly restart cycling\n                this.pause();\n                if (this.touchTimeout) {\n                    clearTimeout(this.touchTimeout);\n                }\n                this.touchTimeout = setTimeout(()=>this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval);\n            };\n            const swipeConfig = {\n                leftCallback: ()=>this._slide(this._directionToOrder(DIRECTION_LEFT)),\n                rightCallback: ()=>this._slide(this._directionToOrder(DIRECTION_RIGHT)),\n                endCallback: endCallBack\n            };\n            this._swipeHelper = new Swipe(this._element, swipeConfig);\n        }\n        _keydown(event) {\n            if (/input|textarea/i.test(event.target.tagName)) {\n                return;\n            }\n            const direction = KEY_TO_DIRECTION[event.key];\n            if (direction) {\n                event.preventDefault();\n                this._slide(this._directionToOrder(direction));\n            }\n        }\n        _getItemIndex(element) {\n            return this._getItems().indexOf(element);\n        }\n        _setActiveIndicatorElement(index) {\n            if (!this._indicatorsElement) {\n                return;\n            }\n            const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);\n            activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);\n            activeIndicator.removeAttribute(\"aria-current\");\n            const newActiveIndicator = SelectorEngine.findOne(`[data-bs-slide-to=\"${index}\"]`, this._indicatorsElement);\n            if (newActiveIndicator) {\n                newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);\n                newActiveIndicator.setAttribute(\"aria-current\", \"true\");\n            }\n        }\n        _updateInterval() {\n            const element = this._activeElement || this._getActive();\n            if (!element) {\n                return;\n            }\n            const elementInterval = Number.parseInt(element.getAttribute(\"data-bs-interval\"), 10);\n            this._config.interval = elementInterval || this._config.defaultInterval;\n        }\n        _slide(order, element = null) {\n            if (this._isSliding) {\n                return;\n            }\n            const activeElement = this._getActive();\n            const isNext = order === ORDER_NEXT;\n            const nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);\n            if (nextElement === activeElement) {\n                return;\n            }\n            const nextElementIndex = this._getItemIndex(nextElement);\n            const triggerEvent = (eventName)=>{\n                return EventHandler.trigger(this._element, eventName, {\n                    relatedTarget: nextElement,\n                    direction: this._orderToDirection(order),\n                    from: this._getItemIndex(activeElement),\n                    to: nextElementIndex\n                });\n            };\n            const slideEvent = triggerEvent(EVENT_SLIDE);\n            if (slideEvent.defaultPrevented) {\n                return;\n            }\n            if (!activeElement || !nextElement) {\n                // Some weirdness is happening, so we bail\n                // TODO: change tests that use empty divs to avoid this check\n                return;\n            }\n            const isCycling = Boolean(this._interval);\n            this.pause();\n            this._isSliding = true;\n            this._setActiveIndicatorElement(nextElementIndex);\n            this._activeElement = nextElement;\n            const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;\n            const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;\n            nextElement.classList.add(orderClassName);\n            reflow(nextElement);\n            activeElement.classList.add(directionalClassName);\n            nextElement.classList.add(directionalClassName);\n            const completeCallBack = ()=>{\n                nextElement.classList.remove(directionalClassName, orderClassName);\n                nextElement.classList.add(CLASS_NAME_ACTIVE$2);\n                activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);\n                this._isSliding = false;\n                triggerEvent(EVENT_SLID);\n            };\n            this._queueCallback(completeCallBack, activeElement, this._isAnimated());\n            if (isCycling) {\n                this.cycle();\n            }\n        }\n        _isAnimated() {\n            return this._element.classList.contains(CLASS_NAME_SLIDE);\n        }\n        _getActive() {\n            return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);\n        }\n        _getItems() {\n            return SelectorEngine.find(SELECTOR_ITEM, this._element);\n        }\n        _clearInterval() {\n            if (this._interval) {\n                clearInterval(this._interval);\n                this._interval = null;\n            }\n        }\n        _directionToOrder(direction) {\n            if (isRTL()) {\n                return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;\n            }\n            return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;\n        }\n        _orderToDirection(order) {\n            if (isRTL()) {\n                return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;\n            }\n            return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;\n        }\n        // Static\n        static jQueryInterface(config) {\n            return this.each(function() {\n                const data = Carousel.getOrCreateInstance(this, config);\n                if (typeof config === \"number\") {\n                    data.to(config);\n                    return;\n                }\n                if (typeof config === \"string\") {\n                    if (data[config] === undefined || config.startsWith(\"_\") || config === \"constructor\") {\n                        throw new TypeError(`No method named \"${config}\"`);\n                    }\n                    data[config]();\n                }\n            });\n        }\n    }\n    /**\n   * Data API implementation\n   */ EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function(event) {\n        const target = SelectorEngine.getElementFromSelector(this);\n        if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {\n            return;\n        }\n        event.preventDefault();\n        const carousel = Carousel.getOrCreateInstance(target);\n        const slideIndex = this.getAttribute(\"data-bs-slide-to\");\n        if (slideIndex) {\n            carousel.to(slideIndex);\n            carousel._maybeEnableCycle();\n            return;\n        }\n        if (Manipulator.getDataAttribute(this, \"slide\") === \"next\") {\n            carousel.next();\n            carousel._maybeEnableCycle();\n            return;\n        }\n        carousel.prev();\n        carousel._maybeEnableCycle();\n    });\n    EventHandler.on(window, EVENT_LOAD_DATA_API$3, ()=>{\n        const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);\n        for (const carousel of carousels){\n            Carousel.getOrCreateInstance(carousel);\n        }\n    });\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Carousel);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap collapse.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$b = \"collapse\";\n    const DATA_KEY$7 = \"bs.collapse\";\n    const EVENT_KEY$7 = `.${DATA_KEY$7}`;\n    const DATA_API_KEY$4 = \".data-api\";\n    const EVENT_SHOW$6 = `show${EVENT_KEY$7}`;\n    const EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`;\n    const EVENT_HIDE$6 = `hide${EVENT_KEY$7}`;\n    const EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`;\n    const EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;\n    const CLASS_NAME_SHOW$7 = \"show\";\n    const CLASS_NAME_COLLAPSE = \"collapse\";\n    const CLASS_NAME_COLLAPSING = \"collapsing\";\n    const CLASS_NAME_COLLAPSED = \"collapsed\";\n    const CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;\n    const CLASS_NAME_HORIZONTAL = \"collapse-horizontal\";\n    const WIDTH = \"width\";\n    const HEIGHT = \"height\";\n    const SELECTOR_ACTIVES = \".collapse.show, .collapse.collapsing\";\n    const SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle=\"collapse\"]';\n    const Default$a = {\n        parent: null,\n        toggle: true\n    };\n    const DefaultType$a = {\n        parent: \"(null|element)\",\n        toggle: \"boolean\"\n    };\n    /**\n   * Class definition\n   */ class Collapse extends BaseComponent {\n        constructor(element, config){\n            super(element, config);\n            this._isTransitioning = false;\n            this._triggerArray = [];\n            const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);\n            for (const elem of toggleList){\n                const selector = SelectorEngine.getSelectorFromElement(elem);\n                const filterElement = SelectorEngine.find(selector).filter((foundElement)=>foundElement === this._element);\n                if (selector !== null && filterElement.length) {\n                    this._triggerArray.push(elem);\n                }\n            }\n            this._initializeChildren();\n            if (!this._config.parent) {\n                this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());\n            }\n            if (this._config.toggle) {\n                this.toggle();\n            }\n        }\n        // Getters\n        static get Default() {\n            return Default$a;\n        }\n        static get DefaultType() {\n            return DefaultType$a;\n        }\n        static get NAME() {\n            return NAME$b;\n        }\n        // Public\n        toggle() {\n            if (this._isShown()) {\n                this.hide();\n            } else {\n                this.show();\n            }\n        }\n        show() {\n            if (this._isTransitioning || this._isShown()) {\n                return;\n            }\n            let activeChildren = [];\n            // find active children\n            if (this._config.parent) {\n                activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter((element)=>element !== this._element).map((element)=>Collapse.getOrCreateInstance(element, {\n                        toggle: false\n                    }));\n            }\n            if (activeChildren.length && activeChildren[0]._isTransitioning) {\n                return;\n            }\n            const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);\n            if (startEvent.defaultPrevented) {\n                return;\n            }\n            for (const activeInstance of activeChildren){\n                activeInstance.hide();\n            }\n            const dimension = this._getDimension();\n            this._element.classList.remove(CLASS_NAME_COLLAPSE);\n            this._element.classList.add(CLASS_NAME_COLLAPSING);\n            this._element.style[dimension] = 0;\n            this._addAriaAndCollapsedClass(this._triggerArray, true);\n            this._isTransitioning = true;\n            const complete = ()=>{\n                this._isTransitioning = false;\n                this._element.classList.remove(CLASS_NAME_COLLAPSING);\n                this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);\n                this._element.style[dimension] = \"\";\n                EventHandler.trigger(this._element, EVENT_SHOWN$6);\n            };\n            const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);\n            const scrollSize = `scroll${capitalizedDimension}`;\n            this._queueCallback(complete, this._element, true);\n            this._element.style[dimension] = `${this._element[scrollSize]}px`;\n        }\n        hide() {\n            if (this._isTransitioning || !this._isShown()) {\n                return;\n            }\n            const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);\n            if (startEvent.defaultPrevented) {\n                return;\n            }\n            const dimension = this._getDimension();\n            this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;\n            reflow(this._element);\n            this._element.classList.add(CLASS_NAME_COLLAPSING);\n            this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);\n            for (const trigger of this._triggerArray){\n                const element = SelectorEngine.getElementFromSelector(trigger);\n                if (element && !this._isShown(element)) {\n                    this._addAriaAndCollapsedClass([\n                        trigger\n                    ], false);\n                }\n            }\n            this._isTransitioning = true;\n            const complete = ()=>{\n                this._isTransitioning = false;\n                this._element.classList.remove(CLASS_NAME_COLLAPSING);\n                this._element.classList.add(CLASS_NAME_COLLAPSE);\n                EventHandler.trigger(this._element, EVENT_HIDDEN$6);\n            };\n            this._element.style[dimension] = \"\";\n            this._queueCallback(complete, this._element, true);\n        }\n        _isShown(element = this._element) {\n            return element.classList.contains(CLASS_NAME_SHOW$7);\n        }\n        // Private\n        _configAfterMerge(config) {\n            config.toggle = Boolean(config.toggle); // Coerce string values\n            config.parent = getElement(config.parent);\n            return config;\n        }\n        _getDimension() {\n            return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;\n        }\n        _initializeChildren() {\n            if (!this._config.parent) {\n                return;\n            }\n            const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);\n            for (const element of children){\n                const selected = SelectorEngine.getElementFromSelector(element);\n                if (selected) {\n                    this._addAriaAndCollapsedClass([\n                        element\n                    ], this._isShown(selected));\n                }\n            }\n        }\n        _getFirstLevelChildren(selector) {\n            const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);\n            // remove children if greater depth\n            return SelectorEngine.find(selector, this._config.parent).filter((element)=>!children.includes(element));\n        }\n        _addAriaAndCollapsedClass(triggerArray, isOpen) {\n            if (!triggerArray.length) {\n                return;\n            }\n            for (const element of triggerArray){\n                element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);\n                element.setAttribute(\"aria-expanded\", isOpen);\n            }\n        }\n        // Static\n        static jQueryInterface(config) {\n            const _config = {};\n            if (typeof config === \"string\" && /show|hide/.test(config)) {\n                _config.toggle = false;\n            }\n            return this.each(function() {\n                const data = Collapse.getOrCreateInstance(this, _config);\n                if (typeof config === \"string\") {\n                    if (typeof data[config] === \"undefined\") {\n                        throw new TypeError(`No method named \"${config}\"`);\n                    }\n                    data[config]();\n                }\n            });\n        }\n    }\n    /**\n   * Data API implementation\n   */ EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function(event) {\n        // preventDefault only for <a> elements (which change the URL) not inside the collapsible element\n        if (event.target.tagName === \"A\" || event.delegateTarget && event.delegateTarget.tagName === \"A\") {\n            event.preventDefault();\n        }\n        for (const element of SelectorEngine.getMultipleElementsFromSelector(this)){\n            Collapse.getOrCreateInstance(element, {\n                toggle: false\n            }).toggle();\n        }\n    });\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Collapse);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap dropdown.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$a = \"dropdown\";\n    const DATA_KEY$6 = \"bs.dropdown\";\n    const EVENT_KEY$6 = `.${DATA_KEY$6}`;\n    const DATA_API_KEY$3 = \".data-api\";\n    const ESCAPE_KEY$2 = \"Escape\";\n    const TAB_KEY$1 = \"Tab\";\n    const ARROW_UP_KEY$1 = \"ArrowUp\";\n    const ARROW_DOWN_KEY$1 = \"ArrowDown\";\n    const RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button\n    const EVENT_HIDE$5 = `hide${EVENT_KEY$6}`;\n    const EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`;\n    const EVENT_SHOW$5 = `show${EVENT_KEY$6}`;\n    const EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`;\n    const EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;\n    const EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`;\n    const EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`;\n    const CLASS_NAME_SHOW$6 = \"show\";\n    const CLASS_NAME_DROPUP = \"dropup\";\n    const CLASS_NAME_DROPEND = \"dropend\";\n    const CLASS_NAME_DROPSTART = \"dropstart\";\n    const CLASS_NAME_DROPUP_CENTER = \"dropup-center\";\n    const CLASS_NAME_DROPDOWN_CENTER = \"dropdown-center\";\n    const SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle=\"dropdown\"]:not(.disabled):not(:disabled)';\n    const SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`;\n    const SELECTOR_MENU = \".dropdown-menu\";\n    const SELECTOR_NAVBAR = \".navbar\";\n    const SELECTOR_NAVBAR_NAV = \".navbar-nav\";\n    const SELECTOR_VISIBLE_ITEMS = \".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)\";\n    const PLACEMENT_TOP = isRTL() ? \"top-end\" : \"top-start\";\n    const PLACEMENT_TOPEND = isRTL() ? \"top-start\" : \"top-end\";\n    const PLACEMENT_BOTTOM = isRTL() ? \"bottom-end\" : \"bottom-start\";\n    const PLACEMENT_BOTTOMEND = isRTL() ? \"bottom-start\" : \"bottom-end\";\n    const PLACEMENT_RIGHT = isRTL() ? \"left-start\" : \"right-start\";\n    const PLACEMENT_LEFT = isRTL() ? \"right-start\" : \"left-start\";\n    const PLACEMENT_TOPCENTER = \"top\";\n    const PLACEMENT_BOTTOMCENTER = \"bottom\";\n    const Default$9 = {\n        autoClose: true,\n        boundary: \"clippingParents\",\n        display: \"dynamic\",\n        offset: [\n            0,\n            2\n        ],\n        popperConfig: null,\n        reference: \"toggle\"\n    };\n    const DefaultType$9 = {\n        autoClose: \"(boolean|string)\",\n        boundary: \"(string|element)\",\n        display: \"string\",\n        offset: \"(array|string|function)\",\n        popperConfig: \"(null|object|function)\",\n        reference: \"(string|element|object)\"\n    };\n    /**\n   * Class definition\n   */ class Dropdown extends BaseComponent {\n        constructor(element, config){\n            super(element, config);\n            this._popper = null;\n            this._parent = this._element.parentNode; // dropdown wrapper\n            // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/\n            this._menu = SelectorEngine.next(this._element, SELECTOR_MENU)[0] || SelectorEngine.prev(this._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, this._parent);\n            this._inNavbar = this._detectNavbar();\n        }\n        // Getters\n        static get Default() {\n            return Default$9;\n        }\n        static get DefaultType() {\n            return DefaultType$9;\n        }\n        static get NAME() {\n            return NAME$a;\n        }\n        // Public\n        toggle() {\n            return this._isShown() ? this.hide() : this.show();\n        }\n        show() {\n            if (isDisabled(this._element) || this._isShown()) {\n                return;\n            }\n            const relatedTarget = {\n                relatedTarget: this._element\n            };\n            const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);\n            if (showEvent.defaultPrevented) {\n                return;\n            }\n            this._createPopper();\n            // If this is a touch-enabled device we add extra\n            // empty mouseover listeners to the body's immediate children;\n            // only needed because of broken event delegation on iOS\n            // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n            if (\"ontouchstart\" in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {\n                for (const element of [].concat(...document.body.children)){\n                    EventHandler.on(element, \"mouseover\", noop);\n                }\n            }\n            this._element.focus();\n            this._element.setAttribute(\"aria-expanded\", true);\n            this._menu.classList.add(CLASS_NAME_SHOW$6);\n            this._element.classList.add(CLASS_NAME_SHOW$6);\n            EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);\n        }\n        hide() {\n            if (isDisabled(this._element) || !this._isShown()) {\n                return;\n            }\n            const relatedTarget = {\n                relatedTarget: this._element\n            };\n            this._completeHide(relatedTarget);\n        }\n        dispose() {\n            if (this._popper) {\n                this._popper.destroy();\n            }\n            super.dispose();\n        }\n        update() {\n            this._inNavbar = this._detectNavbar();\n            if (this._popper) {\n                this._popper.update();\n            }\n        }\n        // Private\n        _completeHide(relatedTarget) {\n            const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);\n            if (hideEvent.defaultPrevented) {\n                return;\n            }\n            // If this is a touch-enabled device we remove the extra\n            // empty mouseover listeners we added for iOS support\n            if (\"ontouchstart\" in document.documentElement) {\n                for (const element of [].concat(...document.body.children)){\n                    EventHandler.off(element, \"mouseover\", noop);\n                }\n            }\n            if (this._popper) {\n                this._popper.destroy();\n            }\n            this._menu.classList.remove(CLASS_NAME_SHOW$6);\n            this._element.classList.remove(CLASS_NAME_SHOW$6);\n            this._element.setAttribute(\"aria-expanded\", \"false\");\n            Manipulator.removeDataAttribute(this._menu, \"popper\");\n            EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);\n        }\n        _getConfig(config) {\n            config = super._getConfig(config);\n            if (typeof config.reference === \"object\" && !isElement(config.reference) && typeof config.reference.getBoundingClientRect !== \"function\") {\n                // Popper virtual elements require a getBoundingClientRect method\n                throw new TypeError(`${NAME$a.toUpperCase()}: Option \"reference\" provided type \"object\" without a required \"getBoundingClientRect\" method.`);\n            }\n            return config;\n        }\n        _createPopper() {\n            if (typeof Popper__namespace === \"undefined\") {\n                throw new TypeError(\"Bootstrap's dropdowns require Popper (https://popper.js.org)\");\n            }\n            let referenceElement = this._element;\n            if (this._config.reference === \"parent\") {\n                referenceElement = this._parent;\n            } else if (isElement(this._config.reference)) {\n                referenceElement = getElement(this._config.reference);\n            } else if (typeof this._config.reference === \"object\") {\n                referenceElement = this._config.reference;\n            }\n            const popperConfig = this._getPopperConfig();\n            this._popper = Popper__namespace.createPopper(referenceElement, this._menu, popperConfig);\n        }\n        _isShown() {\n            return this._menu.classList.contains(CLASS_NAME_SHOW$6);\n        }\n        _getPlacement() {\n            const parentDropdown = this._parent;\n            if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {\n                return PLACEMENT_RIGHT;\n            }\n            if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {\n                return PLACEMENT_LEFT;\n            }\n            if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {\n                return PLACEMENT_TOPCENTER;\n            }\n            if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {\n                return PLACEMENT_BOTTOMCENTER;\n            }\n            // We need to trim the value because custom properties can also include spaces\n            const isEnd = getComputedStyle(this._menu).getPropertyValue(\"--bs-position\").trim() === \"end\";\n            if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {\n                return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;\n            }\n            return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;\n        }\n        _detectNavbar() {\n            return this._element.closest(SELECTOR_NAVBAR) !== null;\n        }\n        _getOffset() {\n            const { offset } = this._config;\n            if (typeof offset === \"string\") {\n                return offset.split(\",\").map((value)=>Number.parseInt(value, 10));\n            }\n            if (typeof offset === \"function\") {\n                return (popperData)=>offset(popperData, this._element);\n            }\n            return offset;\n        }\n        _getPopperConfig() {\n            const defaultBsPopperConfig = {\n                placement: this._getPlacement(),\n                modifiers: [\n                    {\n                        name: \"preventOverflow\",\n                        options: {\n                            boundary: this._config.boundary\n                        }\n                    },\n                    {\n                        name: \"offset\",\n                        options: {\n                            offset: this._getOffset()\n                        }\n                    }\n                ]\n            };\n            // Disable Popper if we have a static display or Dropdown is in Navbar\n            if (this._inNavbar || this._config.display === \"static\") {\n                Manipulator.setDataAttribute(this._menu, \"popper\", \"static\"); // TODO: v6 remove\n                defaultBsPopperConfig.modifiers = [\n                    {\n                        name: \"applyStyles\",\n                        enabled: false\n                    }\n                ];\n            }\n            return {\n                ...defaultBsPopperConfig,\n                ...execute(this._config.popperConfig, [\n                    defaultBsPopperConfig\n                ])\n            };\n        }\n        _selectMenuItem({ key, target }) {\n            const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter((element)=>isVisible(element));\n            if (!items.length) {\n                return;\n            }\n            // if target isn't included in items (e.g. when expanding the dropdown)\n            // allow cycling to get the last item in case key equals ARROW_UP_KEY\n            getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();\n        }\n        // Static\n        static jQueryInterface(config) {\n            return this.each(function() {\n                const data = Dropdown.getOrCreateInstance(this, config);\n                if (typeof config !== \"string\") {\n                    return;\n                }\n                if (typeof data[config] === \"undefined\") {\n                    throw new TypeError(`No method named \"${config}\"`);\n                }\n                data[config]();\n            });\n        }\n        static clearMenus(event) {\n            if (event.button === RIGHT_MOUSE_BUTTON || event.type === \"keyup\" && event.key !== TAB_KEY$1) {\n                return;\n            }\n            const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);\n            for (const toggle of openToggles){\n                const context = Dropdown.getInstance(toggle);\n                if (!context || context._config.autoClose === false) {\n                    continue;\n                }\n                const composedPath = event.composedPath();\n                const isMenuTarget = composedPath.includes(context._menu);\n                if (composedPath.includes(context._element) || context._config.autoClose === \"inside\" && !isMenuTarget || context._config.autoClose === \"outside\" && isMenuTarget) {\n                    continue;\n                }\n                // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu\n                if (context._menu.contains(event.target) && (event.type === \"keyup\" && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {\n                    continue;\n                }\n                const relatedTarget = {\n                    relatedTarget: context._element\n                };\n                if (event.type === \"click\") {\n                    relatedTarget.clickEvent = event;\n                }\n                context._completeHide(relatedTarget);\n            }\n        }\n        static dataApiKeydownHandler(event) {\n            // If not an UP | DOWN | ESCAPE key => not a dropdown command\n            // If input/textarea && if key is other than ESCAPE => not a dropdown command\n            const isInput = /input|textarea/i.test(event.target.tagName);\n            const isEscapeEvent = event.key === ESCAPE_KEY$2;\n            const isUpOrDownEvent = [\n                ARROW_UP_KEY$1,\n                ARROW_DOWN_KEY$1\n            ].includes(event.key);\n            if (!isUpOrDownEvent && !isEscapeEvent) {\n                return;\n            }\n            if (isInput && !isEscapeEvent) {\n                return;\n            }\n            event.preventDefault();\n            // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/\n            const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);\n            const instance = Dropdown.getOrCreateInstance(getToggleButton);\n            if (isUpOrDownEvent) {\n                event.stopPropagation();\n                instance.show();\n                instance._selectMenuItem(event);\n                return;\n            }\n            if (instance._isShown()) {\n                // else is escape and we check if it is shown\n                event.stopPropagation();\n                instance.hide();\n                getToggleButton.focus();\n            }\n        }\n    }\n    /**\n   * Data API implementation\n   */ EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);\n    EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);\n    EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);\n    EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);\n    EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function(event) {\n        event.preventDefault();\n        Dropdown.getOrCreateInstance(this).toggle();\n    });\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Dropdown);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap util/backdrop.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$9 = \"backdrop\";\n    const CLASS_NAME_FADE$4 = \"fade\";\n    const CLASS_NAME_SHOW$5 = \"show\";\n    const EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`;\n    const Default$8 = {\n        className: \"modal-backdrop\",\n        clickCallback: null,\n        isAnimated: false,\n        isVisible: true,\n        // if false, we use the backdrop helper without adding any element to the dom\n        rootElement: \"body\" // give the choice to place backdrop under different elements\n    };\n    const DefaultType$8 = {\n        className: \"string\",\n        clickCallback: \"(function|null)\",\n        isAnimated: \"boolean\",\n        isVisible: \"boolean\",\n        rootElement: \"(element|string)\"\n    };\n    /**\n   * Class definition\n   */ class Backdrop extends Config {\n        constructor(config){\n            super();\n            this._config = this._getConfig(config);\n            this._isAppended = false;\n            this._element = null;\n        }\n        // Getters\n        static get Default() {\n            return Default$8;\n        }\n        static get DefaultType() {\n            return DefaultType$8;\n        }\n        static get NAME() {\n            return NAME$9;\n        }\n        // Public\n        show(callback) {\n            if (!this._config.isVisible) {\n                execute(callback);\n                return;\n            }\n            this._append();\n            const element = this._getElement();\n            if (this._config.isAnimated) {\n                reflow(element);\n            }\n            element.classList.add(CLASS_NAME_SHOW$5);\n            this._emulateAnimation(()=>{\n                execute(callback);\n            });\n        }\n        hide(callback) {\n            if (!this._config.isVisible) {\n                execute(callback);\n                return;\n            }\n            this._getElement().classList.remove(CLASS_NAME_SHOW$5);\n            this._emulateAnimation(()=>{\n                this.dispose();\n                execute(callback);\n            });\n        }\n        dispose() {\n            if (!this._isAppended) {\n                return;\n            }\n            EventHandler.off(this._element, EVENT_MOUSEDOWN);\n            this._element.remove();\n            this._isAppended = false;\n        }\n        // Private\n        _getElement() {\n            if (!this._element) {\n                const backdrop = document.createElement(\"div\");\n                backdrop.className = this._config.className;\n                if (this._config.isAnimated) {\n                    backdrop.classList.add(CLASS_NAME_FADE$4);\n                }\n                this._element = backdrop;\n            }\n            return this._element;\n        }\n        _configAfterMerge(config) {\n            // use getElement() with the default \"body\" to get a fresh Element on each instantiation\n            config.rootElement = getElement(config.rootElement);\n            return config;\n        }\n        _append() {\n            if (this._isAppended) {\n                return;\n            }\n            const element = this._getElement();\n            this._config.rootElement.append(element);\n            EventHandler.on(element, EVENT_MOUSEDOWN, ()=>{\n                execute(this._config.clickCallback);\n            });\n            this._isAppended = true;\n        }\n        _emulateAnimation(callback) {\n            executeAfterTransition(callback, this._getElement(), this._config.isAnimated);\n        }\n    }\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap util/focustrap.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$8 = \"focustrap\";\n    const DATA_KEY$5 = \"bs.focustrap\";\n    const EVENT_KEY$5 = `.${DATA_KEY$5}`;\n    const EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`;\n    const EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`;\n    const TAB_KEY = \"Tab\";\n    const TAB_NAV_FORWARD = \"forward\";\n    const TAB_NAV_BACKWARD = \"backward\";\n    const Default$7 = {\n        autofocus: true,\n        trapElement: null // The element to trap focus inside of\n    };\n    const DefaultType$7 = {\n        autofocus: \"boolean\",\n        trapElement: \"element\"\n    };\n    /**\n   * Class definition\n   */ class FocusTrap extends Config {\n        constructor(config){\n            super();\n            this._config = this._getConfig(config);\n            this._isActive = false;\n            this._lastTabNavDirection = null;\n        }\n        // Getters\n        static get Default() {\n            return Default$7;\n        }\n        static get DefaultType() {\n            return DefaultType$7;\n        }\n        static get NAME() {\n            return NAME$8;\n        }\n        // Public\n        activate() {\n            if (this._isActive) {\n                return;\n            }\n            if (this._config.autofocus) {\n                this._config.trapElement.focus();\n            }\n            EventHandler.off(document, EVENT_KEY$5); // guard against infinite focus loop\n            EventHandler.on(document, EVENT_FOCUSIN$2, (event)=>this._handleFocusin(event));\n            EventHandler.on(document, EVENT_KEYDOWN_TAB, (event)=>this._handleKeydown(event));\n            this._isActive = true;\n        }\n        deactivate() {\n            if (!this._isActive) {\n                return;\n            }\n            this._isActive = false;\n            EventHandler.off(document, EVENT_KEY$5);\n        }\n        // Private\n        _handleFocusin(event) {\n            const { trapElement } = this._config;\n            if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {\n                return;\n            }\n            const elements = SelectorEngine.focusableChildren(trapElement);\n            if (elements.length === 0) {\n                trapElement.focus();\n            } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {\n                elements[elements.length - 1].focus();\n            } else {\n                elements[0].focus();\n            }\n        }\n        _handleKeydown(event) {\n            if (event.key !== TAB_KEY) {\n                return;\n            }\n            this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;\n        }\n    }\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap util/scrollBar.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const SELECTOR_FIXED_CONTENT = \".fixed-top, .fixed-bottom, .is-fixed, .sticky-top\";\n    const SELECTOR_STICKY_CONTENT = \".sticky-top\";\n    const PROPERTY_PADDING = \"padding-right\";\n    const PROPERTY_MARGIN = \"margin-right\";\n    /**\n   * Class definition\n   */ class ScrollBarHelper {\n        constructor(){\n            this._element = document.body;\n        }\n        // Public\n        getWidth() {\n            // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes\n            const documentWidth = document.documentElement.clientWidth;\n            return Math.abs(window.innerWidth - documentWidth);\n        }\n        hide() {\n            const width = this.getWidth();\n            this._disableOverFlow();\n            // give padding to element to balance the hidden scrollbar width\n            this._setElementAttributes(this._element, PROPERTY_PADDING, (calculatedValue)=>calculatedValue + width);\n            // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth\n            this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, (calculatedValue)=>calculatedValue + width);\n            this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, (calculatedValue)=>calculatedValue - width);\n        }\n        reset() {\n            this._resetElementAttributes(this._element, \"overflow\");\n            this._resetElementAttributes(this._element, PROPERTY_PADDING);\n            this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);\n            this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);\n        }\n        isOverflowing() {\n            return this.getWidth() > 0;\n        }\n        // Private\n        _disableOverFlow() {\n            this._saveInitialAttribute(this._element, \"overflow\");\n            this._element.style.overflow = \"hidden\";\n        }\n        _setElementAttributes(selector, styleProperty, callback) {\n            const scrollbarWidth = this.getWidth();\n            const manipulationCallBack = (element)=>{\n                if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {\n                    return;\n                }\n                this._saveInitialAttribute(element, styleProperty);\n                const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);\n                element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);\n            };\n            this._applyManipulationCallback(selector, manipulationCallBack);\n        }\n        _saveInitialAttribute(element, styleProperty) {\n            const actualValue = element.style.getPropertyValue(styleProperty);\n            if (actualValue) {\n                Manipulator.setDataAttribute(element, styleProperty, actualValue);\n            }\n        }\n        _resetElementAttributes(selector, styleProperty) {\n            const manipulationCallBack = (element)=>{\n                const value = Manipulator.getDataAttribute(element, styleProperty);\n                // We only want to remove the property if the value is `null`; the value can also be zero\n                if (value === null) {\n                    element.style.removeProperty(styleProperty);\n                    return;\n                }\n                Manipulator.removeDataAttribute(element, styleProperty);\n                element.style.setProperty(styleProperty, value);\n            };\n            this._applyManipulationCallback(selector, manipulationCallBack);\n        }\n        _applyManipulationCallback(selector, callBack) {\n            if (isElement(selector)) {\n                callBack(selector);\n                return;\n            }\n            for (const sel of SelectorEngine.find(selector, this._element)){\n                callBack(sel);\n            }\n        }\n    }\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap modal.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$7 = \"modal\";\n    const DATA_KEY$4 = \"bs.modal\";\n    const EVENT_KEY$4 = `.${DATA_KEY$4}`;\n    const DATA_API_KEY$2 = \".data-api\";\n    const ESCAPE_KEY$1 = \"Escape\";\n    const EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;\n    const EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`;\n    const EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;\n    const EVENT_SHOW$4 = `show${EVENT_KEY$4}`;\n    const EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;\n    const EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`;\n    const EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$4}`;\n    const EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`;\n    const EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`;\n    const EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`;\n    const CLASS_NAME_OPEN = \"modal-open\";\n    const CLASS_NAME_FADE$3 = \"fade\";\n    const CLASS_NAME_SHOW$4 = \"show\";\n    const CLASS_NAME_STATIC = \"modal-static\";\n    const OPEN_SELECTOR$1 = \".modal.show\";\n    const SELECTOR_DIALOG = \".modal-dialog\";\n    const SELECTOR_MODAL_BODY = \".modal-body\";\n    const SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle=\"modal\"]';\n    const Default$6 = {\n        backdrop: true,\n        focus: true,\n        keyboard: true\n    };\n    const DefaultType$6 = {\n        backdrop: \"(boolean|string)\",\n        focus: \"boolean\",\n        keyboard: \"boolean\"\n    };\n    /**\n   * Class definition\n   */ class Modal extends BaseComponent {\n        constructor(element, config){\n            super(element, config);\n            this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);\n            this._backdrop = this._initializeBackDrop();\n            this._focustrap = this._initializeFocusTrap();\n            this._isShown = false;\n            this._isTransitioning = false;\n            this._scrollBar = new ScrollBarHelper();\n            this._addEventListeners();\n        }\n        // Getters\n        static get Default() {\n            return Default$6;\n        }\n        static get DefaultType() {\n            return DefaultType$6;\n        }\n        static get NAME() {\n            return NAME$7;\n        }\n        // Public\n        toggle(relatedTarget) {\n            return this._isShown ? this.hide() : this.show(relatedTarget);\n        }\n        show(relatedTarget) {\n            if (this._isShown || this._isTransitioning) {\n                return;\n            }\n            const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {\n                relatedTarget\n            });\n            if (showEvent.defaultPrevented) {\n                return;\n            }\n            this._isShown = true;\n            this._isTransitioning = true;\n            this._scrollBar.hide();\n            document.body.classList.add(CLASS_NAME_OPEN);\n            this._adjustDialog();\n            this._backdrop.show(()=>this._showElement(relatedTarget));\n        }\n        hide() {\n            if (!this._isShown || this._isTransitioning) {\n                return;\n            }\n            const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);\n            if (hideEvent.defaultPrevented) {\n                return;\n            }\n            this._isShown = false;\n            this._isTransitioning = true;\n            this._focustrap.deactivate();\n            this._element.classList.remove(CLASS_NAME_SHOW$4);\n            this._queueCallback(()=>this._hideModal(), this._element, this._isAnimated());\n        }\n        dispose() {\n            EventHandler.off(window, EVENT_KEY$4);\n            EventHandler.off(this._dialog, EVENT_KEY$4);\n            this._backdrop.dispose();\n            this._focustrap.deactivate();\n            super.dispose();\n        }\n        handleUpdate() {\n            this._adjustDialog();\n        }\n        // Private\n        _initializeBackDrop() {\n            return new Backdrop({\n                isVisible: Boolean(this._config.backdrop),\n                // 'static' option will be translated to true, and booleans will keep their value,\n                isAnimated: this._isAnimated()\n            });\n        }\n        _initializeFocusTrap() {\n            return new FocusTrap({\n                trapElement: this._element\n            });\n        }\n        _showElement(relatedTarget) {\n            // try to append dynamic modal\n            if (!document.body.contains(this._element)) {\n                document.body.append(this._element);\n            }\n            this._element.style.display = \"block\";\n            this._element.removeAttribute(\"aria-hidden\");\n            this._element.setAttribute(\"aria-modal\", true);\n            this._element.setAttribute(\"role\", \"dialog\");\n            this._element.scrollTop = 0;\n            const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);\n            if (modalBody) {\n                modalBody.scrollTop = 0;\n            }\n            reflow(this._element);\n            this._element.classList.add(CLASS_NAME_SHOW$4);\n            const transitionComplete = ()=>{\n                if (this._config.focus) {\n                    this._focustrap.activate();\n                }\n                this._isTransitioning = false;\n                EventHandler.trigger(this._element, EVENT_SHOWN$4, {\n                    relatedTarget\n                });\n            };\n            this._queueCallback(transitionComplete, this._dialog, this._isAnimated());\n        }\n        _addEventListeners() {\n            EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, (event)=>{\n                if (event.key !== ESCAPE_KEY$1) {\n                    return;\n                }\n                if (this._config.keyboard) {\n                    this.hide();\n                    return;\n                }\n                this._triggerBackdropTransition();\n            });\n            EventHandler.on(window, EVENT_RESIZE$1, ()=>{\n                if (this._isShown && !this._isTransitioning) {\n                    this._adjustDialog();\n                }\n            });\n            EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, (event)=>{\n                // a bad trick to segregate clicks that may start inside dialog but end outside, and avoid listen to scrollbar clicks\n                EventHandler.one(this._element, EVENT_CLICK_DISMISS, (event2)=>{\n                    if (this._element !== event.target || this._element !== event2.target) {\n                        return;\n                    }\n                    if (this._config.backdrop === \"static\") {\n                        this._triggerBackdropTransition();\n                        return;\n                    }\n                    if (this._config.backdrop) {\n                        this.hide();\n                    }\n                });\n            });\n        }\n        _hideModal() {\n            this._element.style.display = \"none\";\n            this._element.setAttribute(\"aria-hidden\", true);\n            this._element.removeAttribute(\"aria-modal\");\n            this._element.removeAttribute(\"role\");\n            this._isTransitioning = false;\n            this._backdrop.hide(()=>{\n                document.body.classList.remove(CLASS_NAME_OPEN);\n                this._resetAdjustments();\n                this._scrollBar.reset();\n                EventHandler.trigger(this._element, EVENT_HIDDEN$4);\n            });\n        }\n        _isAnimated() {\n            return this._element.classList.contains(CLASS_NAME_FADE$3);\n        }\n        _triggerBackdropTransition() {\n            const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);\n            if (hideEvent.defaultPrevented) {\n                return;\n            }\n            const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n            const initialOverflowY = this._element.style.overflowY;\n            // return if the following background transition hasn't yet completed\n            if (initialOverflowY === \"hidden\" || this._element.classList.contains(CLASS_NAME_STATIC)) {\n                return;\n            }\n            if (!isModalOverflowing) {\n                this._element.style.overflowY = \"hidden\";\n            }\n            this._element.classList.add(CLASS_NAME_STATIC);\n            this._queueCallback(()=>{\n                this._element.classList.remove(CLASS_NAME_STATIC);\n                this._queueCallback(()=>{\n                    this._element.style.overflowY = initialOverflowY;\n                }, this._dialog);\n            }, this._dialog);\n            this._element.focus();\n        }\n        /**\n     * The following methods are used to handle overflowing modals\n     */ _adjustDialog() {\n            const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n            const scrollbarWidth = this._scrollBar.getWidth();\n            const isBodyOverflowing = scrollbarWidth > 0;\n            if (isBodyOverflowing && !isModalOverflowing) {\n                const property = isRTL() ? \"paddingLeft\" : \"paddingRight\";\n                this._element.style[property] = `${scrollbarWidth}px`;\n            }\n            if (!isBodyOverflowing && isModalOverflowing) {\n                const property = isRTL() ? \"paddingRight\" : \"paddingLeft\";\n                this._element.style[property] = `${scrollbarWidth}px`;\n            }\n        }\n        _resetAdjustments() {\n            this._element.style.paddingLeft = \"\";\n            this._element.style.paddingRight = \"\";\n        }\n        // Static\n        static jQueryInterface(config, relatedTarget) {\n            return this.each(function() {\n                const data = Modal.getOrCreateInstance(this, config);\n                if (typeof config !== \"string\") {\n                    return;\n                }\n                if (typeof data[config] === \"undefined\") {\n                    throw new TypeError(`No method named \"${config}\"`);\n                }\n                data[config](relatedTarget);\n            });\n        }\n    }\n    /**\n   * Data API implementation\n   */ EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function(event) {\n        const target = SelectorEngine.getElementFromSelector(this);\n        if ([\n            \"A\",\n            \"AREA\"\n        ].includes(this.tagName)) {\n            event.preventDefault();\n        }\n        EventHandler.one(target, EVENT_SHOW$4, (showEvent)=>{\n            if (showEvent.defaultPrevented) {\n                // only register focus restorer if modal will actually get shown\n                return;\n            }\n            EventHandler.one(target, EVENT_HIDDEN$4, ()=>{\n                if (isVisible(this)) {\n                    this.focus();\n                }\n            });\n        });\n        // avoid conflict when clicking modal toggler while another one is open\n        const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);\n        if (alreadyOpen) {\n            Modal.getInstance(alreadyOpen).hide();\n        }\n        const data = Modal.getOrCreateInstance(target);\n        data.toggle(this);\n    });\n    enableDismissTrigger(Modal);\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Modal);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap offcanvas.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$6 = \"offcanvas\";\n    const DATA_KEY$3 = \"bs.offcanvas\";\n    const EVENT_KEY$3 = `.${DATA_KEY$3}`;\n    const DATA_API_KEY$1 = \".data-api\";\n    const EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`;\n    const ESCAPE_KEY = \"Escape\";\n    const CLASS_NAME_SHOW$3 = \"show\";\n    const CLASS_NAME_SHOWING$1 = \"showing\";\n    const CLASS_NAME_HIDING = \"hiding\";\n    const CLASS_NAME_BACKDROP = \"offcanvas-backdrop\";\n    const OPEN_SELECTOR = \".offcanvas.show\";\n    const EVENT_SHOW$3 = `show${EVENT_KEY$3}`;\n    const EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;\n    const EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;\n    const EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`;\n    const EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;\n    const EVENT_RESIZE = `resize${EVENT_KEY$3}`;\n    const EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`;\n    const EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`;\n    const SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle=\"offcanvas\"]';\n    const Default$5 = {\n        backdrop: true,\n        keyboard: true,\n        scroll: false\n    };\n    const DefaultType$5 = {\n        backdrop: \"(boolean|string)\",\n        keyboard: \"boolean\",\n        scroll: \"boolean\"\n    };\n    /**\n   * Class definition\n   */ class Offcanvas extends BaseComponent {\n        constructor(element, config){\n            super(element, config);\n            this._isShown = false;\n            this._backdrop = this._initializeBackDrop();\n            this._focustrap = this._initializeFocusTrap();\n            this._addEventListeners();\n        }\n        // Getters\n        static get Default() {\n            return Default$5;\n        }\n        static get DefaultType() {\n            return DefaultType$5;\n        }\n        static get NAME() {\n            return NAME$6;\n        }\n        // Public\n        toggle(relatedTarget) {\n            return this._isShown ? this.hide() : this.show(relatedTarget);\n        }\n        show(relatedTarget) {\n            if (this._isShown) {\n                return;\n            }\n            const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {\n                relatedTarget\n            });\n            if (showEvent.defaultPrevented) {\n                return;\n            }\n            this._isShown = true;\n            this._backdrop.show();\n            if (!this._config.scroll) {\n                new ScrollBarHelper().hide();\n            }\n            this._element.setAttribute(\"aria-modal\", true);\n            this._element.setAttribute(\"role\", \"dialog\");\n            this._element.classList.add(CLASS_NAME_SHOWING$1);\n            const completeCallBack = ()=>{\n                if (!this._config.scroll || this._config.backdrop) {\n                    this._focustrap.activate();\n                }\n                this._element.classList.add(CLASS_NAME_SHOW$3);\n                this._element.classList.remove(CLASS_NAME_SHOWING$1);\n                EventHandler.trigger(this._element, EVENT_SHOWN$3, {\n                    relatedTarget\n                });\n            };\n            this._queueCallback(completeCallBack, this._element, true);\n        }\n        hide() {\n            if (!this._isShown) {\n                return;\n            }\n            const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);\n            if (hideEvent.defaultPrevented) {\n                return;\n            }\n            this._focustrap.deactivate();\n            this._element.blur();\n            this._isShown = false;\n            this._element.classList.add(CLASS_NAME_HIDING);\n            this._backdrop.hide();\n            const completeCallback = ()=>{\n                this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);\n                this._element.removeAttribute(\"aria-modal\");\n                this._element.removeAttribute(\"role\");\n                if (!this._config.scroll) {\n                    new ScrollBarHelper().reset();\n                }\n                EventHandler.trigger(this._element, EVENT_HIDDEN$3);\n            };\n            this._queueCallback(completeCallback, this._element, true);\n        }\n        dispose() {\n            this._backdrop.dispose();\n            this._focustrap.deactivate();\n            super.dispose();\n        }\n        // Private\n        _initializeBackDrop() {\n            const clickCallback = ()=>{\n                if (this._config.backdrop === \"static\") {\n                    EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);\n                    return;\n                }\n                this.hide();\n            };\n            // 'static' option will be translated to true, and booleans will keep their value\n            const isVisible = Boolean(this._config.backdrop);\n            return new Backdrop({\n                className: CLASS_NAME_BACKDROP,\n                isVisible,\n                isAnimated: true,\n                rootElement: this._element.parentNode,\n                clickCallback: isVisible ? clickCallback : null\n            });\n        }\n        _initializeFocusTrap() {\n            return new FocusTrap({\n                trapElement: this._element\n            });\n        }\n        _addEventListeners() {\n            EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, (event)=>{\n                if (event.key !== ESCAPE_KEY) {\n                    return;\n                }\n                if (this._config.keyboard) {\n                    this.hide();\n                    return;\n                }\n                EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);\n            });\n        }\n        // Static\n        static jQueryInterface(config) {\n            return this.each(function() {\n                const data = Offcanvas.getOrCreateInstance(this, config);\n                if (typeof config !== \"string\") {\n                    return;\n                }\n                if (data[config] === undefined || config.startsWith(\"_\") || config === \"constructor\") {\n                    throw new TypeError(`No method named \"${config}\"`);\n                }\n                data[config](this);\n            });\n        }\n    }\n    /**\n   * Data API implementation\n   */ EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function(event) {\n        const target = SelectorEngine.getElementFromSelector(this);\n        if ([\n            \"A\",\n            \"AREA\"\n        ].includes(this.tagName)) {\n            event.preventDefault();\n        }\n        if (isDisabled(this)) {\n            return;\n        }\n        EventHandler.one(target, EVENT_HIDDEN$3, ()=>{\n            // focus on trigger when it is closed\n            if (isVisible(this)) {\n                this.focus();\n            }\n        });\n        // avoid conflict when clicking a toggler of an offcanvas, while another is open\n        const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);\n        if (alreadyOpen && alreadyOpen !== target) {\n            Offcanvas.getInstance(alreadyOpen).hide();\n        }\n        const data = Offcanvas.getOrCreateInstance(target);\n        data.toggle(this);\n    });\n    EventHandler.on(window, EVENT_LOAD_DATA_API$2, ()=>{\n        for (const selector of SelectorEngine.find(OPEN_SELECTOR)){\n            Offcanvas.getOrCreateInstance(selector).show();\n        }\n    });\n    EventHandler.on(window, EVENT_RESIZE, ()=>{\n        for (const element of SelectorEngine.find(\"[aria-modal][class*=show][class*=offcanvas-]\")){\n            if (getComputedStyle(element).position !== \"fixed\") {\n                Offcanvas.getOrCreateInstance(element).hide();\n            }\n        }\n    });\n    enableDismissTrigger(Offcanvas);\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Offcanvas);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap util/sanitizer.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ // js-docs-start allow-list\n    const ARIA_ATTRIBUTE_PATTERN = /^aria-[\\w-]*$/i;\n    const DefaultAllowlist = {\n        // Global attributes allowed on any supplied element below.\n        \"*\": [\n            \"class\",\n            \"dir\",\n            \"id\",\n            \"lang\",\n            \"role\",\n            ARIA_ATTRIBUTE_PATTERN\n        ],\n        a: [\n            \"target\",\n            \"href\",\n            \"title\",\n            \"rel\"\n        ],\n        area: [],\n        b: [],\n        br: [],\n        col: [],\n        code: [],\n        div: [],\n        em: [],\n        hr: [],\n        h1: [],\n        h2: [],\n        h3: [],\n        h4: [],\n        h5: [],\n        h6: [],\n        i: [],\n        img: [\n            \"src\",\n            \"srcset\",\n            \"alt\",\n            \"title\",\n            \"width\",\n            \"height\"\n        ],\n        li: [],\n        ol: [],\n        p: [],\n        pre: [],\n        s: [],\n        small: [],\n        span: [],\n        sub: [],\n        sup: [],\n        strong: [],\n        u: [],\n        ul: []\n    };\n    // js-docs-end allow-list\n    const uriAttributes = new Set([\n        \"background\",\n        \"cite\",\n        \"href\",\n        \"itemtype\",\n        \"longdesc\",\n        \"poster\",\n        \"src\",\n        \"xlink:href\"\n    ]);\n    /**\n   * A pattern that recognizes URLs that are safe wrt. XSS in URL navigation\n   * contexts.\n   *\n   * Shout-out to Angular https://github.com/angular/angular/blob/15.2.8/packages/core/src/sanitization/url_sanitizer.ts#L38\n   */ // eslint-disable-next-line unicorn/better-regex\n    const SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i;\n    const allowedAttribute = (attribute, allowedAttributeList)=>{\n        const attributeName = attribute.nodeName.toLowerCase();\n        if (allowedAttributeList.includes(attributeName)) {\n            if (uriAttributes.has(attributeName)) {\n                return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue));\n            }\n            return true;\n        }\n        // Check if a regular expression validates the attribute.\n        return allowedAttributeList.filter((attributeRegex)=>attributeRegex instanceof RegExp).some((regex)=>regex.test(attributeName));\n    };\n    function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {\n        if (!unsafeHtml.length) {\n            return unsafeHtml;\n        }\n        if (sanitizeFunction && typeof sanitizeFunction === \"function\") {\n            return sanitizeFunction(unsafeHtml);\n        }\n        const domParser = new window.DOMParser();\n        const createdDocument = domParser.parseFromString(unsafeHtml, \"text/html\");\n        const elements = [].concat(...createdDocument.body.querySelectorAll(\"*\"));\n        for (const element of elements){\n            const elementName = element.nodeName.toLowerCase();\n            if (!Object.keys(allowList).includes(elementName)) {\n                element.remove();\n                continue;\n            }\n            const attributeList = [].concat(...element.attributes);\n            const allowedAttributes = [].concat(allowList[\"*\"] || [], allowList[elementName] || []);\n            for (const attribute of attributeList){\n                if (!allowedAttribute(attribute, allowedAttributes)) {\n                    element.removeAttribute(attribute.nodeName);\n                }\n            }\n        }\n        return createdDocument.body.innerHTML;\n    }\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap util/template-factory.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$5 = \"TemplateFactory\";\n    const Default$4 = {\n        allowList: DefaultAllowlist,\n        content: {},\n        // { selector : text ,  selector2 : text2 , }\n        extraClass: \"\",\n        html: false,\n        sanitize: true,\n        sanitizeFn: null,\n        template: \"<div></div>\"\n    };\n    const DefaultType$4 = {\n        allowList: \"object\",\n        content: \"object\",\n        extraClass: \"(string|function)\",\n        html: \"boolean\",\n        sanitize: \"boolean\",\n        sanitizeFn: \"(null|function)\",\n        template: \"string\"\n    };\n    const DefaultContentType = {\n        entry: \"(string|element|function|null)\",\n        selector: \"(string|element)\"\n    };\n    /**\n   * Class definition\n   */ class TemplateFactory extends Config {\n        constructor(config){\n            super();\n            this._config = this._getConfig(config);\n        }\n        // Getters\n        static get Default() {\n            return Default$4;\n        }\n        static get DefaultType() {\n            return DefaultType$4;\n        }\n        static get NAME() {\n            return NAME$5;\n        }\n        // Public\n        getContent() {\n            return Object.values(this._config.content).map((config)=>this._resolvePossibleFunction(config)).filter(Boolean);\n        }\n        hasContent() {\n            return this.getContent().length > 0;\n        }\n        changeContent(content) {\n            this._checkContent(content);\n            this._config.content = {\n                ...this._config.content,\n                ...content\n            };\n            return this;\n        }\n        toHtml() {\n            const templateWrapper = document.createElement(\"div\");\n            templateWrapper.innerHTML = this._maybeSanitize(this._config.template);\n            for (const [selector, text] of Object.entries(this._config.content)){\n                this._setContent(templateWrapper, text, selector);\n            }\n            const template = templateWrapper.children[0];\n            const extraClass = this._resolvePossibleFunction(this._config.extraClass);\n            if (extraClass) {\n                template.classList.add(...extraClass.split(\" \"));\n            }\n            return template;\n        }\n        // Private\n        _typeCheckConfig(config) {\n            super._typeCheckConfig(config);\n            this._checkContent(config.content);\n        }\n        _checkContent(arg) {\n            for (const [selector, content] of Object.entries(arg)){\n                super._typeCheckConfig({\n                    selector,\n                    entry: content\n                }, DefaultContentType);\n            }\n        }\n        _setContent(template, content, selector) {\n            const templateElement = SelectorEngine.findOne(selector, template);\n            if (!templateElement) {\n                return;\n            }\n            content = this._resolvePossibleFunction(content);\n            if (!content) {\n                templateElement.remove();\n                return;\n            }\n            if (isElement(content)) {\n                this._putElementInTemplate(getElement(content), templateElement);\n                return;\n            }\n            if (this._config.html) {\n                templateElement.innerHTML = this._maybeSanitize(content);\n                return;\n            }\n            templateElement.textContent = content;\n        }\n        _maybeSanitize(arg) {\n            return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;\n        }\n        _resolvePossibleFunction(arg) {\n            return execute(arg, [\n                this\n            ]);\n        }\n        _putElementInTemplate(element, templateElement) {\n            if (this._config.html) {\n                templateElement.innerHTML = \"\";\n                templateElement.append(element);\n                return;\n            }\n            templateElement.textContent = element.textContent;\n        }\n    }\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap tooltip.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$4 = \"tooltip\";\n    const DISALLOWED_ATTRIBUTES = new Set([\n        \"sanitize\",\n        \"allowList\",\n        \"sanitizeFn\"\n    ]);\n    const CLASS_NAME_FADE$2 = \"fade\";\n    const CLASS_NAME_MODAL = \"modal\";\n    const CLASS_NAME_SHOW$2 = \"show\";\n    const SELECTOR_TOOLTIP_INNER = \".tooltip-inner\";\n    const SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;\n    const EVENT_MODAL_HIDE = \"hide.bs.modal\";\n    const TRIGGER_HOVER = \"hover\";\n    const TRIGGER_FOCUS = \"focus\";\n    const TRIGGER_CLICK = \"click\";\n    const TRIGGER_MANUAL = \"manual\";\n    const EVENT_HIDE$2 = \"hide\";\n    const EVENT_HIDDEN$2 = \"hidden\";\n    const EVENT_SHOW$2 = \"show\";\n    const EVENT_SHOWN$2 = \"shown\";\n    const EVENT_INSERTED = \"inserted\";\n    const EVENT_CLICK$1 = \"click\";\n    const EVENT_FOCUSIN$1 = \"focusin\";\n    const EVENT_FOCUSOUT$1 = \"focusout\";\n    const EVENT_MOUSEENTER = \"mouseenter\";\n    const EVENT_MOUSELEAVE = \"mouseleave\";\n    const AttachmentMap = {\n        AUTO: \"auto\",\n        TOP: \"top\",\n        RIGHT: isRTL() ? \"left\" : \"right\",\n        BOTTOM: \"bottom\",\n        LEFT: isRTL() ? \"right\" : \"left\"\n    };\n    const Default$3 = {\n        allowList: DefaultAllowlist,\n        animation: true,\n        boundary: \"clippingParents\",\n        container: false,\n        customClass: \"\",\n        delay: 0,\n        fallbackPlacements: [\n            \"top\",\n            \"right\",\n            \"bottom\",\n            \"left\"\n        ],\n        html: false,\n        offset: [\n            0,\n            6\n        ],\n        placement: \"top\",\n        popperConfig: null,\n        sanitize: true,\n        sanitizeFn: null,\n        selector: false,\n        template: '<div class=\"tooltip\" role=\"tooltip\">' + '<div class=\"tooltip-arrow\"></div>' + '<div class=\"tooltip-inner\"></div>' + \"</div>\",\n        title: \"\",\n        trigger: \"hover focus\"\n    };\n    const DefaultType$3 = {\n        allowList: \"object\",\n        animation: \"boolean\",\n        boundary: \"(string|element)\",\n        container: \"(string|element|boolean)\",\n        customClass: \"(string|function)\",\n        delay: \"(number|object)\",\n        fallbackPlacements: \"array\",\n        html: \"boolean\",\n        offset: \"(array|string|function)\",\n        placement: \"(string|function)\",\n        popperConfig: \"(null|object|function)\",\n        sanitize: \"boolean\",\n        sanitizeFn: \"(null|function)\",\n        selector: \"(string|boolean)\",\n        template: \"string\",\n        title: \"(string|element|function)\",\n        trigger: \"string\"\n    };\n    /**\n   * Class definition\n   */ class Tooltip extends BaseComponent {\n        constructor(element, config){\n            if (typeof Popper__namespace === \"undefined\") {\n                throw new TypeError(\"Bootstrap's tooltips require Popper (https://popper.js.org)\");\n            }\n            super(element, config);\n            // Private\n            this._isEnabled = true;\n            this._timeout = 0;\n            this._isHovered = null;\n            this._activeTrigger = {};\n            this._popper = null;\n            this._templateFactory = null;\n            this._newContent = null;\n            // Protected\n            this.tip = null;\n            this._setListeners();\n            if (!this._config.selector) {\n                this._fixTitle();\n            }\n        }\n        // Getters\n        static get Default() {\n            return Default$3;\n        }\n        static get DefaultType() {\n            return DefaultType$3;\n        }\n        static get NAME() {\n            return NAME$4;\n        }\n        // Public\n        enable() {\n            this._isEnabled = true;\n        }\n        disable() {\n            this._isEnabled = false;\n        }\n        toggleEnabled() {\n            this._isEnabled = !this._isEnabled;\n        }\n        toggle() {\n            if (!this._isEnabled) {\n                return;\n            }\n            this._activeTrigger.click = !this._activeTrigger.click;\n            if (this._isShown()) {\n                this._leave();\n                return;\n            }\n            this._enter();\n        }\n        dispose() {\n            clearTimeout(this._timeout);\n            EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);\n            if (this._element.getAttribute(\"data-bs-original-title\")) {\n                this._element.setAttribute(\"title\", this._element.getAttribute(\"data-bs-original-title\"));\n            }\n            this._disposePopper();\n            super.dispose();\n        }\n        show() {\n            if (this._element.style.display === \"none\") {\n                throw new Error(\"Please use show on visible elements\");\n            }\n            if (!(this._isWithContent() && this._isEnabled)) {\n                return;\n            }\n            const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));\n            const shadowRoot = findShadowRoot(this._element);\n            const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);\n            if (showEvent.defaultPrevented || !isInTheDom) {\n                return;\n            }\n            // TODO: v6 remove this or make it optional\n            this._disposePopper();\n            const tip = this._getTipElement();\n            this._element.setAttribute(\"aria-describedby\", tip.getAttribute(\"id\"));\n            const { container } = this._config;\n            if (!this._element.ownerDocument.documentElement.contains(this.tip)) {\n                container.append(tip);\n                EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));\n            }\n            this._popper = this._createPopper(tip);\n            tip.classList.add(CLASS_NAME_SHOW$2);\n            // If this is a touch-enabled device we add extra\n            // empty mouseover listeners to the body's immediate children;\n            // only needed because of broken event delegation on iOS\n            // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n            if (\"ontouchstart\" in document.documentElement) {\n                for (const element of [].concat(...document.body.children)){\n                    EventHandler.on(element, \"mouseover\", noop);\n                }\n            }\n            const complete = ()=>{\n                EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2));\n                if (this._isHovered === false) {\n                    this._leave();\n                }\n                this._isHovered = false;\n            };\n            this._queueCallback(complete, this.tip, this._isAnimated());\n        }\n        hide() {\n            if (!this._isShown()) {\n                return;\n            }\n            const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));\n            if (hideEvent.defaultPrevented) {\n                return;\n            }\n            const tip = this._getTipElement();\n            tip.classList.remove(CLASS_NAME_SHOW$2);\n            // If this is a touch-enabled device we remove the extra\n            // empty mouseover listeners we added for iOS support\n            if (\"ontouchstart\" in document.documentElement) {\n                for (const element of [].concat(...document.body.children)){\n                    EventHandler.off(element, \"mouseover\", noop);\n                }\n            }\n            this._activeTrigger[TRIGGER_CLICK] = false;\n            this._activeTrigger[TRIGGER_FOCUS] = false;\n            this._activeTrigger[TRIGGER_HOVER] = false;\n            this._isHovered = null; // it is a trick to support manual triggering\n            const complete = ()=>{\n                if (this._isWithActiveTrigger()) {\n                    return;\n                }\n                if (!this._isHovered) {\n                    this._disposePopper();\n                }\n                this._element.removeAttribute(\"aria-describedby\");\n                EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2));\n            };\n            this._queueCallback(complete, this.tip, this._isAnimated());\n        }\n        update() {\n            if (this._popper) {\n                this._popper.update();\n            }\n        }\n        // Protected\n        _isWithContent() {\n            return Boolean(this._getTitle());\n        }\n        _getTipElement() {\n            if (!this.tip) {\n                this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());\n            }\n            return this.tip;\n        }\n        _createTipElement(content) {\n            const tip = this._getTemplateFactory(content).toHtml();\n            // TODO: remove this check in v6\n            if (!tip) {\n                return null;\n            }\n            tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);\n            // TODO: v6 the following can be achieved with CSS only\n            tip.classList.add(`bs-${this.constructor.NAME}-auto`);\n            const tipId = getUID(this.constructor.NAME).toString();\n            tip.setAttribute(\"id\", tipId);\n            if (this._isAnimated()) {\n                tip.classList.add(CLASS_NAME_FADE$2);\n            }\n            return tip;\n        }\n        setContent(content) {\n            this._newContent = content;\n            if (this._isShown()) {\n                this._disposePopper();\n                this.show();\n            }\n        }\n        _getTemplateFactory(content) {\n            if (this._templateFactory) {\n                this._templateFactory.changeContent(content);\n            } else {\n                this._templateFactory = new TemplateFactory({\n                    ...this._config,\n                    // the `content` var has to be after `this._config`\n                    // to override config.content in case of popover\n                    content,\n                    extraClass: this._resolvePossibleFunction(this._config.customClass)\n                });\n            }\n            return this._templateFactory;\n        }\n        _getContentForTemplate() {\n            return {\n                [SELECTOR_TOOLTIP_INNER]: this._getTitle()\n            };\n        }\n        _getTitle() {\n            return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute(\"data-bs-original-title\");\n        }\n        // Private\n        _initializeOnDelegatedTarget(event) {\n            return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());\n        }\n        _isAnimated() {\n            return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);\n        }\n        _isShown() {\n            return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);\n        }\n        _createPopper(tip) {\n            const placement = execute(this._config.placement, [\n                this,\n                tip,\n                this._element\n            ]);\n            const attachment = AttachmentMap[placement.toUpperCase()];\n            return Popper__namespace.createPopper(this._element, tip, this._getPopperConfig(attachment));\n        }\n        _getOffset() {\n            const { offset } = this._config;\n            if (typeof offset === \"string\") {\n                return offset.split(\",\").map((value)=>Number.parseInt(value, 10));\n            }\n            if (typeof offset === \"function\") {\n                return (popperData)=>offset(popperData, this._element);\n            }\n            return offset;\n        }\n        _resolvePossibleFunction(arg) {\n            return execute(arg, [\n                this._element\n            ]);\n        }\n        _getPopperConfig(attachment) {\n            const defaultBsPopperConfig = {\n                placement: attachment,\n                modifiers: [\n                    {\n                        name: \"flip\",\n                        options: {\n                            fallbackPlacements: this._config.fallbackPlacements\n                        }\n                    },\n                    {\n                        name: \"offset\",\n                        options: {\n                            offset: this._getOffset()\n                        }\n                    },\n                    {\n                        name: \"preventOverflow\",\n                        options: {\n                            boundary: this._config.boundary\n                        }\n                    },\n                    {\n                        name: \"arrow\",\n                        options: {\n                            element: `.${this.constructor.NAME}-arrow`\n                        }\n                    },\n                    {\n                        name: \"preSetPlacement\",\n                        enabled: true,\n                        phase: \"beforeMain\",\n                        fn: (data)=>{\n                            // Pre-set Popper's placement attribute in order to read the arrow sizes properly.\n                            // Otherwise, Popper mixes up the width and height dimensions since the initial arrow style is for top placement\n                            this._getTipElement().setAttribute(\"data-popper-placement\", data.state.placement);\n                        }\n                    }\n                ]\n            };\n            return {\n                ...defaultBsPopperConfig,\n                ...execute(this._config.popperConfig, [\n                    defaultBsPopperConfig\n                ])\n            };\n        }\n        _setListeners() {\n            const triggers = this._config.trigger.split(\" \");\n            for (const trigger of triggers){\n                if (trigger === \"click\") {\n                    EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, (event)=>{\n                        const context = this._initializeOnDelegatedTarget(event);\n                        context.toggle();\n                    });\n                } else if (trigger !== TRIGGER_MANUAL) {\n                    const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);\n                    const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);\n                    EventHandler.on(this._element, eventIn, this._config.selector, (event)=>{\n                        const context = this._initializeOnDelegatedTarget(event);\n                        context._activeTrigger[event.type === \"focusin\" ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;\n                        context._enter();\n                    });\n                    EventHandler.on(this._element, eventOut, this._config.selector, (event)=>{\n                        const context = this._initializeOnDelegatedTarget(event);\n                        context._activeTrigger[event.type === \"focusout\" ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);\n                        context._leave();\n                    });\n                }\n            }\n            this._hideModalHandler = ()=>{\n                if (this._element) {\n                    this.hide();\n                }\n            };\n            EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);\n        }\n        _fixTitle() {\n            const title = this._element.getAttribute(\"title\");\n            if (!title) {\n                return;\n            }\n            if (!this._element.getAttribute(\"aria-label\") && !this._element.textContent.trim()) {\n                this._element.setAttribute(\"aria-label\", title);\n            }\n            this._element.setAttribute(\"data-bs-original-title\", title); // DO NOT USE IT. Is only for backwards compatibility\n            this._element.removeAttribute(\"title\");\n        }\n        _enter() {\n            if (this._isShown() || this._isHovered) {\n                this._isHovered = true;\n                return;\n            }\n            this._isHovered = true;\n            this._setTimeout(()=>{\n                if (this._isHovered) {\n                    this.show();\n                }\n            }, this._config.delay.show);\n        }\n        _leave() {\n            if (this._isWithActiveTrigger()) {\n                return;\n            }\n            this._isHovered = false;\n            this._setTimeout(()=>{\n                if (!this._isHovered) {\n                    this.hide();\n                }\n            }, this._config.delay.hide);\n        }\n        _setTimeout(handler, timeout) {\n            clearTimeout(this._timeout);\n            this._timeout = setTimeout(handler, timeout);\n        }\n        _isWithActiveTrigger() {\n            return Object.values(this._activeTrigger).includes(true);\n        }\n        _getConfig(config) {\n            const dataAttributes = Manipulator.getDataAttributes(this._element);\n            for (const dataAttribute of Object.keys(dataAttributes)){\n                if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {\n                    delete dataAttributes[dataAttribute];\n                }\n            }\n            config = {\n                ...dataAttributes,\n                ...typeof config === \"object\" && config ? config : {}\n            };\n            config = this._mergeConfigObj(config);\n            config = this._configAfterMerge(config);\n            this._typeCheckConfig(config);\n            return config;\n        }\n        _configAfterMerge(config) {\n            config.container = config.container === false ? document.body : getElement(config.container);\n            if (typeof config.delay === \"number\") {\n                config.delay = {\n                    show: config.delay,\n                    hide: config.delay\n                };\n            }\n            if (typeof config.title === \"number\") {\n                config.title = config.title.toString();\n            }\n            if (typeof config.content === \"number\") {\n                config.content = config.content.toString();\n            }\n            return config;\n        }\n        _getDelegateConfig() {\n            const config = {};\n            for (const [key, value] of Object.entries(this._config)){\n                if (this.constructor.Default[key] !== value) {\n                    config[key] = value;\n                }\n            }\n            config.selector = false;\n            config.trigger = \"manual\";\n            // In the future can be replaced with:\n            // const keysWithDifferentValues = Object.entries(this._config).filter(entry => this.constructor.Default[entry[0]] !== this._config[entry[0]])\n            // `Object.fromEntries(keysWithDifferentValues)`\n            return config;\n        }\n        _disposePopper() {\n            if (this._popper) {\n                this._popper.destroy();\n                this._popper = null;\n            }\n            if (this.tip) {\n                this.tip.remove();\n                this.tip = null;\n            }\n        }\n        // Static\n        static jQueryInterface(config) {\n            return this.each(function() {\n                const data = Tooltip.getOrCreateInstance(this, config);\n                if (typeof config !== \"string\") {\n                    return;\n                }\n                if (typeof data[config] === \"undefined\") {\n                    throw new TypeError(`No method named \"${config}\"`);\n                }\n                data[config]();\n            });\n        }\n    }\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Tooltip);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap popover.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$3 = \"popover\";\n    const SELECTOR_TITLE = \".popover-header\";\n    const SELECTOR_CONTENT = \".popover-body\";\n    const Default$2 = {\n        ...Tooltip.Default,\n        content: \"\",\n        offset: [\n            0,\n            8\n        ],\n        placement: \"right\",\n        template: '<div class=\"popover\" role=\"tooltip\">' + '<div class=\"popover-arrow\"></div>' + '<h3 class=\"popover-header\"></h3>' + '<div class=\"popover-body\"></div>' + \"</div>\",\n        trigger: \"click\"\n    };\n    const DefaultType$2 = {\n        ...Tooltip.DefaultType,\n        content: \"(null|string|element|function)\"\n    };\n    /**\n   * Class definition\n   */ class Popover extends Tooltip {\n        // Getters\n        static get Default() {\n            return Default$2;\n        }\n        static get DefaultType() {\n            return DefaultType$2;\n        }\n        static get NAME() {\n            return NAME$3;\n        }\n        // Overrides\n        _isWithContent() {\n            return this._getTitle() || this._getContent();\n        }\n        // Private\n        _getContentForTemplate() {\n            return {\n                [SELECTOR_TITLE]: this._getTitle(),\n                [SELECTOR_CONTENT]: this._getContent()\n            };\n        }\n        _getContent() {\n            return this._resolvePossibleFunction(this._config.content);\n        }\n        // Static\n        static jQueryInterface(config) {\n            return this.each(function() {\n                const data = Popover.getOrCreateInstance(this, config);\n                if (typeof config !== \"string\") {\n                    return;\n                }\n                if (typeof data[config] === \"undefined\") {\n                    throw new TypeError(`No method named \"${config}\"`);\n                }\n                data[config]();\n            });\n        }\n    }\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Popover);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap scrollspy.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$2 = \"scrollspy\";\n    const DATA_KEY$2 = \"bs.scrollspy\";\n    const EVENT_KEY$2 = `.${DATA_KEY$2}`;\n    const DATA_API_KEY = \".data-api\";\n    const EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;\n    const EVENT_CLICK = `click${EVENT_KEY$2}`;\n    const EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`;\n    const CLASS_NAME_DROPDOWN_ITEM = \"dropdown-item\";\n    const CLASS_NAME_ACTIVE$1 = \"active\";\n    const SELECTOR_DATA_SPY = '[data-bs-spy=\"scroll\"]';\n    const SELECTOR_TARGET_LINKS = \"[href]\";\n    const SELECTOR_NAV_LIST_GROUP = \".nav, .list-group\";\n    const SELECTOR_NAV_LINKS = \".nav-link\";\n    const SELECTOR_NAV_ITEMS = \".nav-item\";\n    const SELECTOR_LIST_ITEMS = \".list-group-item\";\n    const SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`;\n    const SELECTOR_DROPDOWN = \".dropdown\";\n    const SELECTOR_DROPDOWN_TOGGLE$1 = \".dropdown-toggle\";\n    const Default$1 = {\n        offset: null,\n        // TODO: v6 @deprecated, keep it for backwards compatibility reasons\n        rootMargin: \"0px 0px -25%\",\n        smoothScroll: false,\n        target: null,\n        threshold: [\n            0.1,\n            0.5,\n            1\n        ]\n    };\n    const DefaultType$1 = {\n        offset: \"(number|null)\",\n        // TODO v6 @deprecated, keep it for backwards compatibility reasons\n        rootMargin: \"string\",\n        smoothScroll: \"boolean\",\n        target: \"element\",\n        threshold: \"array\"\n    };\n    /**\n   * Class definition\n   */ class ScrollSpy extends BaseComponent {\n        constructor(element, config){\n            super(element, config);\n            // this._element is the observablesContainer and config.target the menu links wrapper\n            this._targetLinks = new Map();\n            this._observableSections = new Map();\n            this._rootElement = getComputedStyle(this._element).overflowY === \"visible\" ? null : this._element;\n            this._activeTarget = null;\n            this._observer = null;\n            this._previousScrollData = {\n                visibleEntryTop: 0,\n                parentScrollTop: 0\n            };\n            this.refresh(); // initialize\n        }\n        // Getters\n        static get Default() {\n            return Default$1;\n        }\n        static get DefaultType() {\n            return DefaultType$1;\n        }\n        static get NAME() {\n            return NAME$2;\n        }\n        // Public\n        refresh() {\n            this._initializeTargetsAndObservables();\n            this._maybeEnableSmoothScroll();\n            if (this._observer) {\n                this._observer.disconnect();\n            } else {\n                this._observer = this._getNewObserver();\n            }\n            for (const section of this._observableSections.values()){\n                this._observer.observe(section);\n            }\n        }\n        dispose() {\n            this._observer.disconnect();\n            super.dispose();\n        }\n        // Private\n        _configAfterMerge(config) {\n            // TODO: on v6 target should be given explicitly & remove the {target: 'ss-target'} case\n            config.target = getElement(config.target) || document.body;\n            // TODO: v6 Only for backwards compatibility reasons. Use rootMargin only\n            config.rootMargin = config.offset ? `${config.offset}px 0px -30%` : config.rootMargin;\n            if (typeof config.threshold === \"string\") {\n                config.threshold = config.threshold.split(\",\").map((value)=>Number.parseFloat(value));\n            }\n            return config;\n        }\n        _maybeEnableSmoothScroll() {\n            if (!this._config.smoothScroll) {\n                return;\n            }\n            // unregister any previous listeners\n            EventHandler.off(this._config.target, EVENT_CLICK);\n            EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, (event)=>{\n                const observableSection = this._observableSections.get(event.target.hash);\n                if (observableSection) {\n                    event.preventDefault();\n                    const root = this._rootElement || window;\n                    const height = observableSection.offsetTop - this._element.offsetTop;\n                    if (root.scrollTo) {\n                        root.scrollTo({\n                            top: height,\n                            behavior: \"smooth\"\n                        });\n                        return;\n                    }\n                    // Chrome 60 doesn't support `scrollTo`\n                    root.scrollTop = height;\n                }\n            });\n        }\n        _getNewObserver() {\n            const options = {\n                root: this._rootElement,\n                threshold: this._config.threshold,\n                rootMargin: this._config.rootMargin\n            };\n            return new IntersectionObserver((entries)=>this._observerCallback(entries), options);\n        }\n        // The logic of selection\n        _observerCallback(entries) {\n            const targetElement = (entry)=>this._targetLinks.get(`#${entry.target.id}`);\n            const activate = (entry)=>{\n                this._previousScrollData.visibleEntryTop = entry.target.offsetTop;\n                this._process(targetElement(entry));\n            };\n            const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;\n            const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;\n            this._previousScrollData.parentScrollTop = parentScrollTop;\n            for (const entry of entries){\n                if (!entry.isIntersecting) {\n                    this._activeTarget = null;\n                    this._clearActiveClass(targetElement(entry));\n                    continue;\n                }\n                const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop;\n                // if we are scrolling down, pick the bigger offsetTop\n                if (userScrollsDown && entryIsLowerThanPrevious) {\n                    activate(entry);\n                    // if parent isn't scrolled, let's keep the first visible item, breaking the iteration\n                    if (!parentScrollTop) {\n                        return;\n                    }\n                    continue;\n                }\n                // if we are scrolling up, pick the smallest offsetTop\n                if (!userScrollsDown && !entryIsLowerThanPrevious) {\n                    activate(entry);\n                }\n            }\n        }\n        _initializeTargetsAndObservables() {\n            this._targetLinks = new Map();\n            this._observableSections = new Map();\n            const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);\n            for (const anchor of targetLinks){\n                // ensure that the anchor has an id and is not disabled\n                if (!anchor.hash || isDisabled(anchor)) {\n                    continue;\n                }\n                const observableSection = SelectorEngine.findOne(decodeURI(anchor.hash), this._element);\n                // ensure that the observableSection exists & is visible\n                if (isVisible(observableSection)) {\n                    this._targetLinks.set(decodeURI(anchor.hash), anchor);\n                    this._observableSections.set(anchor.hash, observableSection);\n                }\n            }\n        }\n        _process(target) {\n            if (this._activeTarget === target) {\n                return;\n            }\n            this._clearActiveClass(this._config.target);\n            this._activeTarget = target;\n            target.classList.add(CLASS_NAME_ACTIVE$1);\n            this._activateParents(target);\n            EventHandler.trigger(this._element, EVENT_ACTIVATE, {\n                relatedTarget: target\n            });\n        }\n        _activateParents(target) {\n            // Activate dropdown parents\n            if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {\n                SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);\n                return;\n            }\n            for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)){\n                // Set triggered links parents as active\n                // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor\n                for (const item of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)){\n                    item.classList.add(CLASS_NAME_ACTIVE$1);\n                }\n            }\n        }\n        _clearActiveClass(parent) {\n            parent.classList.remove(CLASS_NAME_ACTIVE$1);\n            const activeNodes = SelectorEngine.find(`${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`, parent);\n            for (const node of activeNodes){\n                node.classList.remove(CLASS_NAME_ACTIVE$1);\n            }\n        }\n        // Static\n        static jQueryInterface(config) {\n            return this.each(function() {\n                const data = ScrollSpy.getOrCreateInstance(this, config);\n                if (typeof config !== \"string\") {\n                    return;\n                }\n                if (data[config] === undefined || config.startsWith(\"_\") || config === \"constructor\") {\n                    throw new TypeError(`No method named \"${config}\"`);\n                }\n                data[config]();\n            });\n        }\n    }\n    /**\n   * Data API implementation\n   */ EventHandler.on(window, EVENT_LOAD_DATA_API$1, ()=>{\n        for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY)){\n            ScrollSpy.getOrCreateInstance(spy);\n        }\n    });\n    /**\n   * jQuery\n   */ defineJQueryPlugin(ScrollSpy);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap tab.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$1 = \"tab\";\n    const DATA_KEY$1 = \"bs.tab\";\n    const EVENT_KEY$1 = `.${DATA_KEY$1}`;\n    const EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;\n    const EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;\n    const EVENT_SHOW$1 = `show${EVENT_KEY$1}`;\n    const EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;\n    const EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`;\n    const EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`;\n    const EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`;\n    const ARROW_LEFT_KEY = \"ArrowLeft\";\n    const ARROW_RIGHT_KEY = \"ArrowRight\";\n    const ARROW_UP_KEY = \"ArrowUp\";\n    const ARROW_DOWN_KEY = \"ArrowDown\";\n    const HOME_KEY = \"Home\";\n    const END_KEY = \"End\";\n    const CLASS_NAME_ACTIVE = \"active\";\n    const CLASS_NAME_FADE$1 = \"fade\";\n    const CLASS_NAME_SHOW$1 = \"show\";\n    const CLASS_DROPDOWN = \"dropdown\";\n    const SELECTOR_DROPDOWN_TOGGLE = \".dropdown-toggle\";\n    const SELECTOR_DROPDOWN_MENU = \".dropdown-menu\";\n    const NOT_SELECTOR_DROPDOWN_TOGGLE = `:not(${SELECTOR_DROPDOWN_TOGGLE})`;\n    const SELECTOR_TAB_PANEL = '.list-group, .nav, [role=\"tablist\"]';\n    const SELECTOR_OUTER = \".nav-item, .list-group-item\";\n    const SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role=\"tab\"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;\n    const SELECTOR_DATA_TOGGLE = '[data-bs-toggle=\"tab\"], [data-bs-toggle=\"pill\"], [data-bs-toggle=\"list\"]'; // TODO: could only be `tab` in v6\n    const SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`;\n    const SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle=\"tab\"], .${CLASS_NAME_ACTIVE}[data-bs-toggle=\"pill\"], .${CLASS_NAME_ACTIVE}[data-bs-toggle=\"list\"]`;\n    /**\n   * Class definition\n   */ class Tab extends BaseComponent {\n        constructor(element){\n            super(element);\n            this._parent = this._element.closest(SELECTOR_TAB_PANEL);\n            if (!this._parent) {\n                return;\n            // TODO: should throw exception in v6\n            // throw new TypeError(`${element.outerHTML} has not a valid parent ${SELECTOR_INNER_ELEM}`)\n            }\n            // Set up initial aria attributes\n            this._setInitialAttributes(this._parent, this._getChildren());\n            EventHandler.on(this._element, EVENT_KEYDOWN, (event)=>this._keydown(event));\n        }\n        // Getters\n        static get NAME() {\n            return NAME$1;\n        }\n        // Public\n        show() {\n            // Shows this elem and deactivate the active sibling if exists\n            const innerElem = this._element;\n            if (this._elemIsActive(innerElem)) {\n                return;\n            }\n            // Search for active tab on same parent to deactivate it\n            const active = this._getActiveElem();\n            const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {\n                relatedTarget: innerElem\n            }) : null;\n            const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {\n                relatedTarget: active\n            });\n            if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {\n                return;\n            }\n            this._deactivate(active, innerElem);\n            this._activate(innerElem, active);\n        }\n        // Private\n        _activate(element, relatedElem) {\n            if (!element) {\n                return;\n            }\n            element.classList.add(CLASS_NAME_ACTIVE);\n            this._activate(SelectorEngine.getElementFromSelector(element)); // Search and activate/show the proper section\n            const complete = ()=>{\n                if (element.getAttribute(\"role\") !== \"tab\") {\n                    element.classList.add(CLASS_NAME_SHOW$1);\n                    return;\n                }\n                element.removeAttribute(\"tabindex\");\n                element.setAttribute(\"aria-selected\", true);\n                this._toggleDropDown(element, true);\n                EventHandler.trigger(element, EVENT_SHOWN$1, {\n                    relatedTarget: relatedElem\n                });\n            };\n            this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));\n        }\n        _deactivate(element, relatedElem) {\n            if (!element) {\n                return;\n            }\n            element.classList.remove(CLASS_NAME_ACTIVE);\n            element.blur();\n            this._deactivate(SelectorEngine.getElementFromSelector(element)); // Search and deactivate the shown section too\n            const complete = ()=>{\n                if (element.getAttribute(\"role\") !== \"tab\") {\n                    element.classList.remove(CLASS_NAME_SHOW$1);\n                    return;\n                }\n                element.setAttribute(\"aria-selected\", false);\n                element.setAttribute(\"tabindex\", \"-1\");\n                this._toggleDropDown(element, false);\n                EventHandler.trigger(element, EVENT_HIDDEN$1, {\n                    relatedTarget: relatedElem\n                });\n            };\n            this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));\n        }\n        _keydown(event) {\n            if (![\n                ARROW_LEFT_KEY,\n                ARROW_RIGHT_KEY,\n                ARROW_UP_KEY,\n                ARROW_DOWN_KEY,\n                HOME_KEY,\n                END_KEY\n            ].includes(event.key)) {\n                return;\n            }\n            event.stopPropagation(); // stopPropagation/preventDefault both added to support up/down keys without scrolling the page\n            event.preventDefault();\n            const children = this._getChildren().filter((element)=>!isDisabled(element));\n            let nextActiveElement;\n            if ([\n                HOME_KEY,\n                END_KEY\n            ].includes(event.key)) {\n                nextActiveElement = children[event.key === HOME_KEY ? 0 : children.length - 1];\n            } else {\n                const isNext = [\n                    ARROW_RIGHT_KEY,\n                    ARROW_DOWN_KEY\n                ].includes(event.key);\n                nextActiveElement = getNextActiveElement(children, event.target, isNext, true);\n            }\n            if (nextActiveElement) {\n                nextActiveElement.focus({\n                    preventScroll: true\n                });\n                Tab.getOrCreateInstance(nextActiveElement).show();\n            }\n        }\n        _getChildren() {\n            // collection of inner elements\n            return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);\n        }\n        _getActiveElem() {\n            return this._getChildren().find((child)=>this._elemIsActive(child)) || null;\n        }\n        _setInitialAttributes(parent, children) {\n            this._setAttributeIfNotExists(parent, \"role\", \"tablist\");\n            for (const child of children){\n                this._setInitialAttributesOnChild(child);\n            }\n        }\n        _setInitialAttributesOnChild(child) {\n            child = this._getInnerElement(child);\n            const isActive = this._elemIsActive(child);\n            const outerElem = this._getOuterElement(child);\n            child.setAttribute(\"aria-selected\", isActive);\n            if (outerElem !== child) {\n                this._setAttributeIfNotExists(outerElem, \"role\", \"presentation\");\n            }\n            if (!isActive) {\n                child.setAttribute(\"tabindex\", \"-1\");\n            }\n            this._setAttributeIfNotExists(child, \"role\", \"tab\");\n            // set attributes to the related panel too\n            this._setInitialAttributesOnTargetPanel(child);\n        }\n        _setInitialAttributesOnTargetPanel(child) {\n            const target = SelectorEngine.getElementFromSelector(child);\n            if (!target) {\n                return;\n            }\n            this._setAttributeIfNotExists(target, \"role\", \"tabpanel\");\n            if (child.id) {\n                this._setAttributeIfNotExists(target, \"aria-labelledby\", `${child.id}`);\n            }\n        }\n        _toggleDropDown(element, open) {\n            const outerElem = this._getOuterElement(element);\n            if (!outerElem.classList.contains(CLASS_DROPDOWN)) {\n                return;\n            }\n            const toggle = (selector, className)=>{\n                const element = SelectorEngine.findOne(selector, outerElem);\n                if (element) {\n                    element.classList.toggle(className, open);\n                }\n            };\n            toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);\n            toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);\n            outerElem.setAttribute(\"aria-expanded\", open);\n        }\n        _setAttributeIfNotExists(element, attribute, value) {\n            if (!element.hasAttribute(attribute)) {\n                element.setAttribute(attribute, value);\n            }\n        }\n        _elemIsActive(elem) {\n            return elem.classList.contains(CLASS_NAME_ACTIVE);\n        }\n        // Try to get the inner element (usually the .nav-link)\n        _getInnerElement(elem) {\n            return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);\n        }\n        // Try to get the outer element (usually the .nav-item)\n        _getOuterElement(elem) {\n            return elem.closest(SELECTOR_OUTER) || elem;\n        }\n        // Static\n        static jQueryInterface(config) {\n            return this.each(function() {\n                const data = Tab.getOrCreateInstance(this);\n                if (typeof config !== \"string\") {\n                    return;\n                }\n                if (data[config] === undefined || config.startsWith(\"_\") || config === \"constructor\") {\n                    throw new TypeError(`No method named \"${config}\"`);\n                }\n                data[config]();\n            });\n        }\n    }\n    /**\n   * Data API implementation\n   */ EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function(event) {\n        if ([\n            \"A\",\n            \"AREA\"\n        ].includes(this.tagName)) {\n            event.preventDefault();\n        }\n        if (isDisabled(this)) {\n            return;\n        }\n        Tab.getOrCreateInstance(this).show();\n    });\n    /**\n   * Initialize on focus\n   */ EventHandler.on(window, EVENT_LOAD_DATA_API, ()=>{\n        for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)){\n            Tab.getOrCreateInstance(element);\n        }\n    });\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Tab);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap toast.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME = \"toast\";\n    const DATA_KEY = \"bs.toast\";\n    const EVENT_KEY = `.${DATA_KEY}`;\n    const EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;\n    const EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;\n    const EVENT_FOCUSIN = `focusin${EVENT_KEY}`;\n    const EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;\n    const EVENT_HIDE = `hide${EVENT_KEY}`;\n    const EVENT_HIDDEN = `hidden${EVENT_KEY}`;\n    const EVENT_SHOW = `show${EVENT_KEY}`;\n    const EVENT_SHOWN = `shown${EVENT_KEY}`;\n    const CLASS_NAME_FADE = \"fade\";\n    const CLASS_NAME_HIDE = \"hide\"; // @deprecated - kept here only for backwards compatibility\n    const CLASS_NAME_SHOW = \"show\";\n    const CLASS_NAME_SHOWING = \"showing\";\n    const DefaultType = {\n        animation: \"boolean\",\n        autohide: \"boolean\",\n        delay: \"number\"\n    };\n    const Default = {\n        animation: true,\n        autohide: true,\n        delay: 5000\n    };\n    /**\n   * Class definition\n   */ class Toast extends BaseComponent {\n        constructor(element, config){\n            super(element, config);\n            this._timeout = null;\n            this._hasMouseInteraction = false;\n            this._hasKeyboardInteraction = false;\n            this._setListeners();\n        }\n        // Getters\n        static get Default() {\n            return Default;\n        }\n        static get DefaultType() {\n            return DefaultType;\n        }\n        static get NAME() {\n            return NAME;\n        }\n        // Public\n        show() {\n            const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);\n            if (showEvent.defaultPrevented) {\n                return;\n            }\n            this._clearTimeout();\n            if (this._config.animation) {\n                this._element.classList.add(CLASS_NAME_FADE);\n            }\n            const complete = ()=>{\n                this._element.classList.remove(CLASS_NAME_SHOWING);\n                EventHandler.trigger(this._element, EVENT_SHOWN);\n                this._maybeScheduleHide();\n            };\n            this._element.classList.remove(CLASS_NAME_HIDE); // @deprecated\n            reflow(this._element);\n            this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);\n            this._queueCallback(complete, this._element, this._config.animation);\n        }\n        hide() {\n            if (!this.isShown()) {\n                return;\n            }\n            const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);\n            if (hideEvent.defaultPrevented) {\n                return;\n            }\n            const complete = ()=>{\n                this._element.classList.add(CLASS_NAME_HIDE); // @deprecated\n                this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);\n                EventHandler.trigger(this._element, EVENT_HIDDEN);\n            };\n            this._element.classList.add(CLASS_NAME_SHOWING);\n            this._queueCallback(complete, this._element, this._config.animation);\n        }\n        dispose() {\n            this._clearTimeout();\n            if (this.isShown()) {\n                this._element.classList.remove(CLASS_NAME_SHOW);\n            }\n            super.dispose();\n        }\n        isShown() {\n            return this._element.classList.contains(CLASS_NAME_SHOW);\n        }\n        // Private\n        _maybeScheduleHide() {\n            if (!this._config.autohide) {\n                return;\n            }\n            if (this._hasMouseInteraction || this._hasKeyboardInteraction) {\n                return;\n            }\n            this._timeout = setTimeout(()=>{\n                this.hide();\n            }, this._config.delay);\n        }\n        _onInteraction(event, isInteracting) {\n            switch(event.type){\n                case \"mouseover\":\n                case \"mouseout\":\n                    {\n                        this._hasMouseInteraction = isInteracting;\n                        break;\n                    }\n                case \"focusin\":\n                case \"focusout\":\n                    {\n                        this._hasKeyboardInteraction = isInteracting;\n                        break;\n                    }\n            }\n            if (isInteracting) {\n                this._clearTimeout();\n                return;\n            }\n            const nextElement = event.relatedTarget;\n            if (this._element === nextElement || this._element.contains(nextElement)) {\n                return;\n            }\n            this._maybeScheduleHide();\n        }\n        _setListeners() {\n            EventHandler.on(this._element, EVENT_MOUSEOVER, (event)=>this._onInteraction(event, true));\n            EventHandler.on(this._element, EVENT_MOUSEOUT, (event)=>this._onInteraction(event, false));\n            EventHandler.on(this._element, EVENT_FOCUSIN, (event)=>this._onInteraction(event, true));\n            EventHandler.on(this._element, EVENT_FOCUSOUT, (event)=>this._onInteraction(event, false));\n        }\n        _clearTimeout() {\n            clearTimeout(this._timeout);\n            this._timeout = null;\n        }\n        // Static\n        static jQueryInterface(config) {\n            return this.each(function() {\n                const data = Toast.getOrCreateInstance(this, config);\n                if (typeof config === \"string\") {\n                    if (typeof data[config] === \"undefined\") {\n                        throw new TypeError(`No method named \"${config}\"`);\n                    }\n                    data[config](this);\n                }\n            });\n        }\n    }\n    /**\n   * Data API implementation\n   */ enableDismissTrigger(Toast);\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Toast);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap index.umd.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ const index_umd = {\n        Alert,\n        Button,\n        Carousel,\n        Collapse,\n        Dropdown,\n        Modal,\n        Offcanvas,\n        Popover,\n        ScrollSpy,\n        Tab,\n        Toast,\n        Tooltip\n    };\n    return index_umd;\n}); //# sourceMappingURL=bootstrap.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwLmpzIiwibWFwcGluZ3MiOiI7QUFBQTs7OztFQUlFLEdBQ0QsVUFBVUEsTUFBTSxFQUFFQyxPQUFPO0lBQ3hCLEtBQWlELEdBQWNFLE9BQU9ELE9BQU8sR0FBR0QsUUFBUUcsbUJBQU9BLENBQUMsNkVBQ2hHLENBQ29IO0FBQ3RILEdBQUcsUUFBTyxTQUFVTSxNQUFNO0lBQUk7SUFFNUIsU0FBU0MseUJBQXlCQyxDQUFDO1FBQ2pDLE1BQU1DLElBQUlDLE9BQU9DLE1BQU0sQ0FBQyxNQUFNO1lBQUUsQ0FBQ0MsT0FBT0MsV0FBVyxDQUFDLEVBQUU7Z0JBQUVDLE9BQU87WUFBUztRQUFFO1FBQzFFLElBQUlOLEdBQUc7WUFDTCxJQUFLLE1BQU1PLEtBQUtQLEVBQUc7Z0JBQ2pCLElBQUlPLE1BQU0sV0FBVztvQkFDbkIsTUFBTUMsSUFBSU4sT0FBT08sd0JBQXdCLENBQUNULEdBQUdPO29CQUM3Q0wsT0FBT1EsY0FBYyxDQUFDVCxHQUFHTSxHQUFHQyxFQUFFRyxHQUFHLEdBQUdILElBQUk7d0JBQ3RDSSxZQUFZO3dCQUNaRCxLQUFLLElBQU1YLENBQUMsQ0FBQ08sRUFBRTtvQkFDakI7Z0JBQ0Y7WUFDRjtRQUNGO1FBQ0FOLEVBQUVZLE9BQU8sR0FBR2I7UUFDWixPQUFPRSxPQUFPWSxNQUFNLENBQUNiO0lBQ3ZCO0lBRUEsTUFBTWMsb0JBQW9CLFdBQVcsR0FBRWhCLHlCQUF5QkQ7SUFFaEU7Ozs7O0dBS0MsR0FFRDs7R0FFQyxHQUVELE1BQU1rQixhQUFhLElBQUlDO0lBQ3ZCLE1BQU1DLE9BQU87UUFDWEMsS0FBSUMsT0FBTyxFQUFFQyxHQUFHLEVBQUVDLFFBQVE7WUFDeEIsSUFBSSxDQUFDTixXQUFXTyxHQUFHLENBQUNILFVBQVU7Z0JBQzVCSixXQUFXRyxHQUFHLENBQUNDLFNBQVMsSUFBSUg7WUFDOUI7WUFDQSxNQUFNTyxjQUFjUixXQUFXTCxHQUFHLENBQUNTO1lB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dEI7SUFFckI7O0dBRUMsR0FFRHo0QixtQkFBbUJ5NEI7SUFFbkI7Ozs7O0dBS0MsR0FFRCxNQUFNUSxZQUFZO1FBQ2hCNXNCO1FBQ0FhO1FBQ0FpRjtRQUNBeUU7UUFDQXNFO1FBQ0FnSTtRQUNBaUQ7UUFDQXNLO1FBQ0F5QjtRQUNBcUU7UUFDQWtDO1FBQ0EvSztJQUNGO0lBRUEsT0FBT3VMO0FBRVQsSUFDQSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hdXRvY2hlY2tlci8uL25vZGVfbW9kdWxlcy9ib290c3RyYXAvZGlzdC9qcy9ib290c3RyYXAuanM/OTA5NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAgKiBCb290c3RyYXAgdjUuMy4yIChodHRwczovL2dldGJvb3RzdHJhcC5jb20vKVxuICAqIENvcHlyaWdodCAyMDExLTIwMjMgVGhlIEJvb3RzdHJhcCBBdXRob3JzIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvZ3JhcGhzL2NvbnRyaWJ1dG9ycylcbiAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdAcG9wcGVyanMvY29yZScpKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ0Bwb3BwZXJqcy9jb3JlJ10sIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLmJvb3RzdHJhcCA9IGZhY3RvcnkoZ2xvYmFsLlBvcHBlcikpO1xufSkodGhpcywgKGZ1bmN0aW9uIChQb3BwZXIpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdChlKSB7XG4gICAgY29uc3QgbiA9IE9iamVjdC5jcmVhdGUobnVsbCwgeyBbU3ltYm9sLnRvU3RyaW5nVGFnXTogeyB2YWx1ZTogJ01vZHVsZScgfSB9KTtcbiAgICBpZiAoZSkge1xuICAgICAgZm9yIChjb25zdCBrIGluIGUpIHtcbiAgICAgICAgaWYgKGsgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgIGNvbnN0IGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiBlW2tdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbi5kZWZhdWx0ID0gZTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbiAgfVxuXG4gIGNvbnN0IFBvcHBlcl9fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdChQb3BwZXIpO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgZG9tL2RhdGEuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDb25zdGFudHNcbiAgICovXG5cbiAgY29uc3QgZWxlbWVudE1hcCA9IG5ldyBNYXAoKTtcbiAgY29uc3QgRGF0YSA9IHtcbiAgICBzZXQoZWxlbWVudCwga2V5LCBpbnN0YW5jZSkge1xuICAgICAgaWYgKCFlbGVtZW50TWFwLmhhcyhlbGVtZW50KSkge1xuICAgICAgICBlbGVtZW50TWFwLnNldChlbGVtZW50LCBuZXcgTWFwKCkpO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5zdGFuY2VNYXAgPSBlbGVtZW50TWFwLmdldChlbGVtZW50KTtcblxuICAgICAgLy8gbWFrZSBpdCBjbGVhciB3ZSBvbmx5IHdhbnQgb25lIGluc3RhbmNlIHBlciBlbGVtZW50XG4gICAgICAvLyBjYW4gYmUgcmVtb3ZlZCBsYXRlciB3aGVuIG11bHRpcGxlIGtleS9pbnN0YW5jZXMgYXJlIGZpbmUgdG8gYmUgdXNlZFxuICAgICAgaWYgKCFpbnN0YW5jZU1hcC5oYXMoa2V5KSAmJiBpbnN0YW5jZU1hcC5zaXplICE9PSAwKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEJvb3RzdHJhcCBkb2Vzbid0IGFsbG93IG1vcmUgdGhhbiBvbmUgaW5zdGFuY2UgcGVyIGVsZW1lbnQuIEJvdW5kIGluc3RhbmNlOiAke0FycmF5LmZyb20oaW5zdGFuY2VNYXAua2V5cygpKVswXX0uYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGluc3RhbmNlTWFwLnNldChrZXksIGluc3RhbmNlKTtcbiAgICB9LFxuICAgIGdldChlbGVtZW50LCBrZXkpIHtcbiAgICAgIGlmIChlbGVtZW50TWFwLmhhcyhlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gZWxlbWVudE1hcC5nZXQoZWxlbWVudCkuZ2V0KGtleSkgfHwgbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgcmVtb3ZlKGVsZW1lbnQsIGtleSkge1xuICAgICAgaWYgKCFlbGVtZW50TWFwLmhhcyhlbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpbnN0YW5jZU1hcCA9IGVsZW1lbnRNYXAuZ2V0KGVsZW1lbnQpO1xuICAgICAgaW5zdGFuY2VNYXAuZGVsZXRlKGtleSk7XG5cbiAgICAgIC8vIGZyZWUgdXAgZWxlbWVudCByZWZlcmVuY2VzIGlmIHRoZXJlIGFyZSBubyBpbnN0YW5jZXMgbGVmdCBmb3IgYW4gZWxlbWVudFxuICAgICAgaWYgKGluc3RhbmNlTWFwLnNpemUgPT09IDApIHtcbiAgICAgICAgZWxlbWVudE1hcC5kZWxldGUoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgdXRpbC9pbmRleC5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgY29uc3QgTUFYX1VJRCA9IDEwMDAwMDA7XG4gIGNvbnN0IE1JTExJU0VDT05EU19NVUxUSVBMSUVSID0gMTAwMDtcbiAgY29uc3QgVFJBTlNJVElPTl9FTkQgPSAndHJhbnNpdGlvbmVuZCc7XG5cbiAgLyoqXG4gICAqIFByb3Blcmx5IGVzY2FwZSBJRHMgc2VsZWN0b3JzIHRvIGhhbmRsZSB3ZWlyZCBJRHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBjb25zdCBwYXJzZVNlbGVjdG9yID0gc2VsZWN0b3IgPT4ge1xuICAgIGlmIChzZWxlY3RvciAmJiB3aW5kb3cuQ1NTICYmIHdpbmRvdy5DU1MuZXNjYXBlKSB7XG4gICAgICAvLyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yIG5lZWRzIGVzY2FwaW5nIHRvIGhhbmRsZSBJRHMgKGh0bWw1KykgY29udGFpbmluZyBmb3IgaW5zdGFuY2UgL1xuICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKC8jKFteXFxzXCIjJ10rKS9nLCAobWF0Y2gsIGlkKSA9PiBgIyR7Q1NTLmVzY2FwZShpZCl9YCk7XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RvcjtcbiAgfTtcblxuICAvLyBTaG91dC1vdXQgQW5ndXMgQ3JvbGwgKGh0dHBzOi8vZ29vLmdsL3B4d1FHcClcbiAgY29uc3QgdG9UeXBlID0gb2JqZWN0ID0+IHtcbiAgICBpZiAob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gYCR7b2JqZWN0fWA7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KS5tYXRjaCgvXFxzKFthLXpdKykvaSlbMV0udG9Mb3dlckNhc2UoKTtcbiAgfTtcblxuICAvKipcbiAgICogUHVibGljIFV0aWwgQVBJXG4gICAqL1xuXG4gIGNvbnN0IGdldFVJRCA9IHByZWZpeCA9PiB7XG4gICAgZG8ge1xuICAgICAgcHJlZml4ICs9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE1BWF9VSUQpO1xuICAgIH0gd2hpbGUgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHByZWZpeCkpO1xuICAgIHJldHVybiBwcmVmaXg7XG4gIH07XG4gIGNvbnN0IGdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50ID0gZWxlbWVudCA9PiB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvLyBHZXQgdHJhbnNpdGlvbi1kdXJhdGlvbiBvZiB0aGUgZWxlbWVudFxuICAgIGxldCB7XG4gICAgICB0cmFuc2l0aW9uRHVyYXRpb24sXG4gICAgICB0cmFuc2l0aW9uRGVsYXlcbiAgICB9ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgY29uc3QgZmxvYXRUcmFuc2l0aW9uRHVyYXRpb24gPSBOdW1iZXIucGFyc2VGbG9hdCh0cmFuc2l0aW9uRHVyYXRpb24pO1xuICAgIGNvbnN0IGZsb2F0VHJhbnNpdGlvbkRlbGF5ID0gTnVtYmVyLnBhcnNlRmxvYXQodHJhbnNpdGlvbkRlbGF5KTtcblxuICAgIC8vIFJldHVybiAwIGlmIGVsZW1lbnQgb3IgdHJhbnNpdGlvbiBkdXJhdGlvbiBpcyBub3QgZm91bmRcbiAgICBpZiAoIWZsb2F0VHJhbnNpdGlvbkR1cmF0aW9uICYmICFmbG9hdFRyYW5zaXRpb25EZWxheSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLy8gSWYgbXVsdGlwbGUgZHVyYXRpb25zIGFyZSBkZWZpbmVkLCB0YWtlIHRoZSBmaXJzdFxuICAgIHRyYW5zaXRpb25EdXJhdGlvbiA9IHRyYW5zaXRpb25EdXJhdGlvbi5zcGxpdCgnLCcpWzBdO1xuICAgIHRyYW5zaXRpb25EZWxheSA9IHRyYW5zaXRpb25EZWxheS5zcGxpdCgnLCcpWzBdO1xuICAgIHJldHVybiAoTnVtYmVyLnBhcnNlRmxvYXQodHJhbnNpdGlvbkR1cmF0aW9uKSArIE51bWJlci5wYXJzZUZsb2F0KHRyYW5zaXRpb25EZWxheSkpICogTUlMTElTRUNPTkRTX01VTFRJUExJRVI7XG4gIH07XG4gIGNvbnN0IHRyaWdnZXJUcmFuc2l0aW9uRW5kID0gZWxlbWVudCA9PiB7XG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChUUkFOU0lUSU9OX0VORCkpO1xuICB9O1xuICBjb25zdCBpc0VsZW1lbnQgPSBvYmplY3QgPT4ge1xuICAgIGlmICghb2JqZWN0IHx8IHR5cGVvZiBvYmplY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqZWN0LmpxdWVyeSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9iamVjdCA9IG9iamVjdFswXTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3Qubm9kZVR5cGUgIT09ICd1bmRlZmluZWQnO1xuICB9O1xuICBjb25zdCBnZXRFbGVtZW50ID0gb2JqZWN0ID0+IHtcbiAgICAvLyBpdCdzIGEgalF1ZXJ5IG9iamVjdCBvciBhIG5vZGUgZWxlbWVudFxuICAgIGlmIChpc0VsZW1lbnQob2JqZWN0KSkge1xuICAgICAgcmV0dXJuIG9iamVjdC5qcXVlcnkgPyBvYmplY3RbMF0gOiBvYmplY3Q7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJyAmJiBvYmplY3QubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocGFyc2VTZWxlY3RvcihvYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIGNvbnN0IGlzVmlzaWJsZSA9IGVsZW1lbnQgPT4ge1xuICAgIGlmICghaXNFbGVtZW50KGVsZW1lbnQpIHx8IGVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudElzVmlzaWJsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgndmlzaWJpbGl0eScpID09PSAndmlzaWJsZSc7XG4gICAgLy8gSGFuZGxlIGBkZXRhaWxzYCBlbGVtZW50IGFzIGl0cyBjb250ZW50IG1heSBmYWxzaWUgYXBwZWFyIHZpc2libGUgd2hlbiBpdCBpcyBjbG9zZWRcbiAgICBjb25zdCBjbG9zZWREZXRhaWxzID0gZWxlbWVudC5jbG9zZXN0KCdkZXRhaWxzOm5vdChbb3Blbl0pJyk7XG4gICAgaWYgKCFjbG9zZWREZXRhaWxzKSB7XG4gICAgICByZXR1cm4gZWxlbWVudElzVmlzaWJsZTtcbiAgICB9XG4gICAgaWYgKGNsb3NlZERldGFpbHMgIT09IGVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHN1bW1hcnkgPSBlbGVtZW50LmNsb3Nlc3QoJ3N1bW1hcnknKTtcbiAgICAgIGlmIChzdW1tYXJ5ICYmIHN1bW1hcnkucGFyZW50Tm9kZSAhPT0gY2xvc2VkRGV0YWlscykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoc3VtbWFyeSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50SXNWaXNpYmxlO1xuICB9O1xuICBjb25zdCBpc0Rpc2FibGVkID0gZWxlbWVudCA9PiB7XG4gICAgaWYgKCFlbGVtZW50IHx8IGVsZW1lbnQubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdkaXNhYmxlZCcpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50LmRpc2FibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGVsZW1lbnQuZGlzYWJsZWQ7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGlzYWJsZWQnKSAhPT0gJ2ZhbHNlJztcbiAgfTtcbiAgY29uc3QgZmluZFNoYWRvd1Jvb3QgPSBlbGVtZW50ID0+IHtcbiAgICBpZiAoIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hdHRhY2hTaGFkb3cpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIENhbiBmaW5kIHRoZSBzaGFkb3cgcm9vdCBvdGhlcndpc2UgaXQnbGwgcmV0dXJuIHRoZSBkb2N1bWVudFxuICAgIGlmICh0eXBlb2YgZWxlbWVudC5nZXRSb290Tm9kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3Qgcm9vdCA9IGVsZW1lbnQuZ2V0Um9vdE5vZGUoKTtcbiAgICAgIHJldHVybiByb290IGluc3RhbmNlb2YgU2hhZG93Um9vdCA/IHJvb3QgOiBudWxsO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIC8vIHdoZW4gd2UgZG9uJ3QgZmluZCBhIHNoYWRvdyByb290XG4gICAgaWYgKCFlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZmluZFNoYWRvd1Jvb3QoZWxlbWVudC5wYXJlbnROb2RlKTtcbiAgfTtcbiAgY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuXG4gIC8qKlxuICAgKiBUcmljayB0byByZXN0YXJ0IGFuIGVsZW1lbnQncyBhbmltYXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcmV0dXJuIHZvaWRcbiAgICpcbiAgICogQHNlZSBodHRwczovL3d3dy5jaGFyaXN0aGVvLmlvL2Jsb2cvMjAyMS8wMi9yZXN0YXJ0LWEtY3NzLWFuaW1hdGlvbi13aXRoLWphdmFzY3JpcHQvI3Jlc3RhcnRpbmctYS1jc3MtYW5pbWF0aW9uXG4gICAqL1xuICBjb25zdCByZWZsb3cgPSBlbGVtZW50ID0+IHtcbiAgICBlbGVtZW50Lm9mZnNldEhlaWdodDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbiAgfTtcblxuICBjb25zdCBnZXRqUXVlcnkgPSAoKSA9PiB7XG4gICAgaWYgKHdpbmRvdy5qUXVlcnkgJiYgIWRvY3VtZW50LmJvZHkuaGFzQXR0cmlidXRlKCdkYXRhLWJzLW5vLWpxdWVyeScpKSB7XG4gICAgICByZXR1cm4gd2luZG93LmpRdWVyeTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIGNvbnN0IERPTUNvbnRlbnRMb2FkZWRDYWxsYmFja3MgPSBbXTtcbiAgY29uc3Qgb25ET01Db250ZW50TG9hZGVkID0gY2FsbGJhY2sgPT4ge1xuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgIC8vIGFkZCBsaXN0ZW5lciBvbiB0aGUgZmlyc3QgY2FsbCB3aGVuIHRoZSBkb2N1bWVudCBpcyBpbiBsb2FkaW5nIHN0YXRlXG4gICAgICBpZiAoIURPTUNvbnRlbnRMb2FkZWRDYWxsYmFja3MubGVuZ3RoKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBET01Db250ZW50TG9hZGVkQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBET01Db250ZW50TG9hZGVkQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgaXNSVEwgPSAoKSA9PiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGlyID09PSAncnRsJztcbiAgY29uc3QgZGVmaW5lSlF1ZXJ5UGx1Z2luID0gcGx1Z2luID0+IHtcbiAgICBvbkRPTUNvbnRlbnRMb2FkZWQoKCkgPT4ge1xuICAgICAgY29uc3QgJCA9IGdldGpRdWVyeSgpO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoJCkge1xuICAgICAgICBjb25zdCBuYW1lID0gcGx1Z2luLk5BTUU7XG4gICAgICAgIGNvbnN0IEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bbmFtZV07XG4gICAgICAgICQuZm5bbmFtZV0gPSBwbHVnaW4ualF1ZXJ5SW50ZXJmYWNlO1xuICAgICAgICAkLmZuW25hbWVdLkNvbnN0cnVjdG9yID0gcGx1Z2luO1xuICAgICAgICAkLmZuW25hbWVdLm5vQ29uZmxpY3QgPSAoKSA9PiB7XG4gICAgICAgICAgJC5mbltuYW1lXSA9IEpRVUVSWV9OT19DT05GTElDVDtcbiAgICAgICAgICByZXR1cm4gcGx1Z2luLmpRdWVyeUludGVyZmFjZTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgZXhlY3V0ZSA9IChwb3NzaWJsZUNhbGxiYWNrLCBhcmdzID0gW10sIGRlZmF1bHRWYWx1ZSA9IHBvc3NpYmxlQ2FsbGJhY2spID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHBvc3NpYmxlQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBwb3NzaWJsZUNhbGxiYWNrKC4uLmFyZ3MpIDogZGVmYXVsdFZhbHVlO1xuICB9O1xuICBjb25zdCBleGVjdXRlQWZ0ZXJUcmFuc2l0aW9uID0gKGNhbGxiYWNrLCB0cmFuc2l0aW9uRWxlbWVudCwgd2FpdEZvclRyYW5zaXRpb24gPSB0cnVlKSA9PiB7XG4gICAgaWYgKCF3YWl0Rm9yVHJhbnNpdGlvbikge1xuICAgICAgZXhlY3V0ZShjYWxsYmFjayk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGR1cmF0aW9uUGFkZGluZyA9IDU7XG4gICAgY29uc3QgZW11bGF0ZWREdXJhdGlvbiA9IGdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRyYW5zaXRpb25FbGVtZW50KSArIGR1cmF0aW9uUGFkZGluZztcbiAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgY29uc3QgaGFuZGxlciA9ICh7XG4gICAgICB0YXJnZXRcbiAgICB9KSA9PiB7XG4gICAgICBpZiAodGFyZ2V0ICE9PSB0cmFuc2l0aW9uRWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgdHJhbnNpdGlvbkVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihUUkFOU0lUSU9OX0VORCwgaGFuZGxlcik7XG4gICAgICBleGVjdXRlKGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIHRyYW5zaXRpb25FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoVFJBTlNJVElPTl9FTkQsIGhhbmRsZXIpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgdHJpZ2dlclRyYW5zaXRpb25FbmQodHJhbnNpdGlvbkVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0sIGVtdWxhdGVkRHVyYXRpb24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHByZXZpb3VzL25leHQgZWxlbWVudCBvZiBhIGxpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXl9IGxpc3QgICAgVGhlIGxpc3Qgb2YgZWxlbWVudHNcbiAgICogQHBhcmFtIGFjdGl2ZUVsZW1lbnQgICBUaGUgYWN0aXZlIGVsZW1lbnRcbiAgICogQHBhcmFtIHNob3VsZEdldE5leHQgICBDaG9vc2UgdG8gZ2V0IG5leHQgb3IgcHJldmlvdXMgZWxlbWVudFxuICAgKiBAcGFyYW0gaXNDeWNsZUFsbG93ZWRcbiAgICogQHJldHVybiB7RWxlbWVudHxlbGVtfSBUaGUgcHJvcGVyIGVsZW1lbnRcbiAgICovXG4gIGNvbnN0IGdldE5leHRBY3RpdmVFbGVtZW50ID0gKGxpc3QsIGFjdGl2ZUVsZW1lbnQsIHNob3VsZEdldE5leHQsIGlzQ3ljbGVBbGxvd2VkKSA9PiB7XG4gICAgY29uc3QgbGlzdExlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICAgIGxldCBpbmRleCA9IGxpc3QuaW5kZXhPZihhY3RpdmVFbGVtZW50KTtcblxuICAgIC8vIGlmIHRoZSBlbGVtZW50IGRvZXMgbm90IGV4aXN0IGluIHRoZSBsaXN0IHJldHVybiBhbiBlbGVtZW50XG4gICAgLy8gZGVwZW5kaW5nIG9uIHRoZSBkaXJlY3Rpb24gYW5kIGlmIGN5Y2xlIGlzIGFsbG93ZWRcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm4gIXNob3VsZEdldE5leHQgJiYgaXNDeWNsZUFsbG93ZWQgPyBsaXN0W2xpc3RMZW5ndGggLSAxXSA6IGxpc3RbMF07XG4gICAgfVxuICAgIGluZGV4ICs9IHNob3VsZEdldE5leHQgPyAxIDogLTE7XG4gICAgaWYgKGlzQ3ljbGVBbGxvd2VkKSB7XG4gICAgICBpbmRleCA9IChpbmRleCArIGxpc3RMZW5ndGgpICUgbGlzdExlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3RbTWF0aC5tYXgoMCwgTWF0aC5taW4oaW5kZXgsIGxpc3RMZW5ndGggLSAxKSldO1xuICB9O1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgZG9tL2V2ZW50LWhhbmRsZXIuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIENvbnN0YW50c1xuICAgKi9cblxuICBjb25zdCBuYW1lc3BhY2VSZWdleCA9IC9bXi5dKig/PVxcLi4qKVxcLnwuKi87XG4gIGNvbnN0IHN0cmlwTmFtZVJlZ2V4ID0gL1xcLi4qLztcbiAgY29uc3Qgc3RyaXBVaWRSZWdleCA9IC86OlxcZCskLztcbiAgY29uc3QgZXZlbnRSZWdpc3RyeSA9IHt9OyAvLyBFdmVudHMgc3RvcmFnZVxuICBsZXQgdWlkRXZlbnQgPSAxO1xuICBjb25zdCBjdXN0b21FdmVudHMgPSB7XG4gICAgbW91c2VlbnRlcjogJ21vdXNlb3ZlcicsXG4gICAgbW91c2VsZWF2ZTogJ21vdXNlb3V0J1xuICB9O1xuICBjb25zdCBuYXRpdmVFdmVudHMgPSBuZXcgU2V0KFsnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2V1cCcsICdtb3VzZWRvd24nLCAnY29udGV4dG1lbnUnLCAnbW91c2V3aGVlbCcsICdET01Nb3VzZVNjcm9sbCcsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnLCAnbW91c2Vtb3ZlJywgJ3NlbGVjdHN0YXJ0JywgJ3NlbGVjdGVuZCcsICdrZXlkb3duJywgJ2tleXByZXNzJywgJ2tleXVwJywgJ29yaWVudGF0aW9uY2hhbmdlJywgJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJywgJ3RvdWNoZW5kJywgJ3RvdWNoY2FuY2VsJywgJ3BvaW50ZXJkb3duJywgJ3BvaW50ZXJtb3ZlJywgJ3BvaW50ZXJ1cCcsICdwb2ludGVybGVhdmUnLCAncG9pbnRlcmNhbmNlbCcsICdnZXN0dXJlc3RhcnQnLCAnZ2VzdHVyZWNoYW5nZScsICdnZXN0dXJlZW5kJywgJ2ZvY3VzJywgJ2JsdXInLCAnY2hhbmdlJywgJ3Jlc2V0JywgJ3NlbGVjdCcsICdzdWJtaXQnLCAnZm9jdXNpbicsICdmb2N1c291dCcsICdsb2FkJywgJ3VubG9hZCcsICdiZWZvcmV1bmxvYWQnLCAncmVzaXplJywgJ21vdmUnLCAnRE9NQ29udGVudExvYWRlZCcsICdyZWFkeXN0YXRlY2hhbmdlJywgJ2Vycm9yJywgJ2Fib3J0JywgJ3Njcm9sbCddKTtcblxuICAvKipcbiAgICogUHJpdmF0ZSBtZXRob2RzXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG1ha2VFdmVudFVpZChlbGVtZW50LCB1aWQpIHtcbiAgICByZXR1cm4gdWlkICYmIGAke3VpZH06OiR7dWlkRXZlbnQrK31gIHx8IGVsZW1lbnQudWlkRXZlbnQgfHwgdWlkRXZlbnQrKztcbiAgfVxuICBmdW5jdGlvbiBnZXRFbGVtZW50RXZlbnRzKGVsZW1lbnQpIHtcbiAgICBjb25zdCB1aWQgPSBtYWtlRXZlbnRVaWQoZWxlbWVudCk7XG4gICAgZWxlbWVudC51aWRFdmVudCA9IHVpZDtcbiAgICBldmVudFJlZ2lzdHJ5W3VpZF0gPSBldmVudFJlZ2lzdHJ5W3VpZF0gfHwge307XG4gICAgcmV0dXJuIGV2ZW50UmVnaXN0cnlbdWlkXTtcbiAgfVxuICBmdW5jdGlvbiBib290c3RyYXBIYW5kbGVyKGVsZW1lbnQsIGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZXIoZXZlbnQpIHtcbiAgICAgIGh5ZHJhdGVPYmooZXZlbnQsIHtcbiAgICAgICAgZGVsZWdhdGVUYXJnZXQ6IGVsZW1lbnRcbiAgICAgIH0pO1xuICAgICAgaWYgKGhhbmRsZXIub25lT2ZmKSB7XG4gICAgICAgIEV2ZW50SGFuZGxlci5vZmYoZWxlbWVudCwgZXZlbnQudHlwZSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZuLmFwcGx5KGVsZW1lbnQsIFtldmVudF0pO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gYm9vdHN0cmFwRGVsZWdhdGlvbkhhbmRsZXIoZWxlbWVudCwgc2VsZWN0b3IsIGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZXIoZXZlbnQpIHtcbiAgICAgIGNvbnN0IGRvbUVsZW1lbnRzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgIGZvciAobGV0IHtcbiAgICAgICAgdGFyZ2V0XG4gICAgICB9ID0gZXZlbnQ7IHRhcmdldCAmJiB0YXJnZXQgIT09IHRoaXM7IHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGZvciAoY29uc3QgZG9tRWxlbWVudCBvZiBkb21FbGVtZW50cykge1xuICAgICAgICAgIGlmIChkb21FbGVtZW50ICE9PSB0YXJnZXQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoeWRyYXRlT2JqKGV2ZW50LCB7XG4gICAgICAgICAgICBkZWxlZ2F0ZVRhcmdldDogdGFyZ2V0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGhhbmRsZXIub25lT2ZmKSB7XG4gICAgICAgICAgICBFdmVudEhhbmRsZXIub2ZmKGVsZW1lbnQsIGV2ZW50LnR5cGUsIHNlbGVjdG9yLCBmbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0YXJnZXQsIFtldmVudF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBmaW5kSGFuZGxlcihldmVudHMsIGNhbGxhYmxlLCBkZWxlZ2F0aW9uU2VsZWN0b3IgPSBudWxsKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoZXZlbnRzKS5maW5kKGV2ZW50ID0+IGV2ZW50LmNhbGxhYmxlID09PSBjYWxsYWJsZSAmJiBldmVudC5kZWxlZ2F0aW9uU2VsZWN0b3IgPT09IGRlbGVnYXRpb25TZWxlY3Rvcik7XG4gIH1cbiAgZnVuY3Rpb24gbm9ybWFsaXplUGFyYW1ldGVycyhvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKSB7XG4gICAgY29uc3QgaXNEZWxlZ2F0ZWQgPSB0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZyc7XG4gICAgLy8gVE9ETzogdG9vbHRpcCBwYXNzZXMgYGZhbHNlYCBpbnN0ZWFkIG9mIHNlbGVjdG9yLCBzbyB3ZSBuZWVkIHRvIGNoZWNrXG4gICAgY29uc3QgY2FsbGFibGUgPSBpc0RlbGVnYXRlZCA/IGRlbGVnYXRpb25GdW5jdGlvbiA6IGhhbmRsZXIgfHwgZGVsZWdhdGlvbkZ1bmN0aW9uO1xuICAgIGxldCB0eXBlRXZlbnQgPSBnZXRUeXBlRXZlbnQob3JpZ2luYWxUeXBlRXZlbnQpO1xuICAgIGlmICghbmF0aXZlRXZlbnRzLmhhcyh0eXBlRXZlbnQpKSB7XG4gICAgICB0eXBlRXZlbnQgPSBvcmlnaW5hbFR5cGVFdmVudDtcbiAgICB9XG4gICAgcmV0dXJuIFtpc0RlbGVnYXRlZCwgY2FsbGFibGUsIHR5cGVFdmVudF07XG4gIH1cbiAgZnVuY3Rpb24gYWRkSGFuZGxlcihlbGVtZW50LCBvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uLCBvbmVPZmYpIHtcbiAgICBpZiAodHlwZW9mIG9yaWdpbmFsVHlwZUV2ZW50ICE9PSAnc3RyaW5nJyB8fCAhZWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgW2lzRGVsZWdhdGVkLCBjYWxsYWJsZSwgdHlwZUV2ZW50XSA9IG5vcm1hbGl6ZVBhcmFtZXRlcnMob3JpZ2luYWxUeXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbik7XG5cbiAgICAvLyBpbiBjYXNlIG9mIG1vdXNlZW50ZXIgb3IgbW91c2VsZWF2ZSB3cmFwIHRoZSBoYW5kbGVyIHdpdGhpbiBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGZvciBpdHMgRE9NIHBvc2l0aW9uXG4gICAgLy8gdGhpcyBwcmV2ZW50cyB0aGUgaGFuZGxlciBmcm9tIGJlaW5nIGRpc3BhdGNoZWQgdGhlIHNhbWUgd2F5IGFzIG1vdXNlb3ZlciBvciBtb3VzZW91dCBkb2VzXG4gICAgaWYgKG9yaWdpbmFsVHlwZUV2ZW50IGluIGN1c3RvbUV2ZW50cykge1xuICAgICAgY29uc3Qgd3JhcEZ1bmN0aW9uID0gZm4gPT4ge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKCFldmVudC5yZWxhdGVkVGFyZ2V0IHx8IGV2ZW50LnJlbGF0ZWRUYXJnZXQgIT09IGV2ZW50LmRlbGVnYXRlVGFyZ2V0ICYmICFldmVudC5kZWxlZ2F0ZVRhcmdldC5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBjYWxsYWJsZSA9IHdyYXBGdW5jdGlvbihjYWxsYWJsZSk7XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50cyA9IGdldEVsZW1lbnRFdmVudHMoZWxlbWVudCk7XG4gICAgY29uc3QgaGFuZGxlcnMgPSBldmVudHNbdHlwZUV2ZW50XSB8fCAoZXZlbnRzW3R5cGVFdmVudF0gPSB7fSk7XG4gICAgY29uc3QgcHJldmlvdXNGdW5jdGlvbiA9IGZpbmRIYW5kbGVyKGhhbmRsZXJzLCBjYWxsYWJsZSwgaXNEZWxlZ2F0ZWQgPyBoYW5kbGVyIDogbnVsbCk7XG4gICAgaWYgKHByZXZpb3VzRnVuY3Rpb24pIHtcbiAgICAgIHByZXZpb3VzRnVuY3Rpb24ub25lT2ZmID0gcHJldmlvdXNGdW5jdGlvbi5vbmVPZmYgJiYgb25lT2ZmO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB1aWQgPSBtYWtlRXZlbnRVaWQoY2FsbGFibGUsIG9yaWdpbmFsVHlwZUV2ZW50LnJlcGxhY2UobmFtZXNwYWNlUmVnZXgsICcnKSk7XG4gICAgY29uc3QgZm4gPSBpc0RlbGVnYXRlZCA/IGJvb3RzdHJhcERlbGVnYXRpb25IYW5kbGVyKGVsZW1lbnQsIGhhbmRsZXIsIGNhbGxhYmxlKSA6IGJvb3RzdHJhcEhhbmRsZXIoZWxlbWVudCwgY2FsbGFibGUpO1xuICAgIGZuLmRlbGVnYXRpb25TZWxlY3RvciA9IGlzRGVsZWdhdGVkID8gaGFuZGxlciA6IG51bGw7XG4gICAgZm4uY2FsbGFibGUgPSBjYWxsYWJsZTtcbiAgICBmbi5vbmVPZmYgPSBvbmVPZmY7XG4gICAgZm4udWlkRXZlbnQgPSB1aWQ7XG4gICAgaGFuZGxlcnNbdWlkXSA9IGZuO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlRXZlbnQsIGZuLCBpc0RlbGVnYXRlZCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlSGFuZGxlcihlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvblNlbGVjdG9yKSB7XG4gICAgY29uc3QgZm4gPSBmaW5kSGFuZGxlcihldmVudHNbdHlwZUV2ZW50XSwgaGFuZGxlciwgZGVsZWdhdGlvblNlbGVjdG9yKTtcbiAgICBpZiAoIWZuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlRXZlbnQsIGZuLCBCb29sZWFuKGRlbGVnYXRpb25TZWxlY3RvcikpO1xuICAgIGRlbGV0ZSBldmVudHNbdHlwZUV2ZW50XVtmbi51aWRFdmVudF07XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlTmFtZXNwYWNlZEhhbmRsZXJzKGVsZW1lbnQsIGV2ZW50cywgdHlwZUV2ZW50LCBuYW1lc3BhY2UpIHtcbiAgICBjb25zdCBzdG9yZUVsZW1lbnRFdmVudCA9IGV2ZW50c1t0eXBlRXZlbnRdIHx8IHt9O1xuICAgIGZvciAoY29uc3QgW2hhbmRsZXJLZXksIGV2ZW50XSBvZiBPYmplY3QuZW50cmllcyhzdG9yZUVsZW1lbnRFdmVudCkpIHtcbiAgICAgIGlmIChoYW5kbGVyS2V5LmluY2x1ZGVzKG5hbWVzcGFjZSkpIHtcbiAgICAgICAgcmVtb3ZlSGFuZGxlcihlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgZXZlbnQuY2FsbGFibGUsIGV2ZW50LmRlbGVnYXRpb25TZWxlY3Rvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldFR5cGVFdmVudChldmVudCkge1xuICAgIC8vIGFsbG93IHRvIGdldCB0aGUgbmF0aXZlIGV2ZW50cyBmcm9tIG5hbWVzcGFjZWQgZXZlbnRzICgnY2xpY2suYnMuYnV0dG9uJyAtLT4gJ2NsaWNrJylcbiAgICBldmVudCA9IGV2ZW50LnJlcGxhY2Uoc3RyaXBOYW1lUmVnZXgsICcnKTtcbiAgICByZXR1cm4gY3VzdG9tRXZlbnRzW2V2ZW50XSB8fCBldmVudDtcbiAgfVxuICBjb25zdCBFdmVudEhhbmRsZXIgPSB7XG4gICAgb24oZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbikge1xuICAgICAgYWRkSGFuZGxlcihlbGVtZW50LCBldmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uLCBmYWxzZSk7XG4gICAgfSxcbiAgICBvbmUoZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbikge1xuICAgICAgYWRkSGFuZGxlcihlbGVtZW50LCBldmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uLCB0cnVlKTtcbiAgICB9LFxuICAgIG9mZihlbGVtZW50LCBvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKSB7XG4gICAgICBpZiAodHlwZW9mIG9yaWdpbmFsVHlwZUV2ZW50ICE9PSAnc3RyaW5nJyB8fCAhZWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBbaXNEZWxlZ2F0ZWQsIGNhbGxhYmxlLCB0eXBlRXZlbnRdID0gbm9ybWFsaXplUGFyYW1ldGVycyhvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKTtcbiAgICAgIGNvbnN0IGluTmFtZXNwYWNlID0gdHlwZUV2ZW50ICE9PSBvcmlnaW5hbFR5cGVFdmVudDtcbiAgICAgIGNvbnN0IGV2ZW50cyA9IGdldEVsZW1lbnRFdmVudHMoZWxlbWVudCk7XG4gICAgICBjb25zdCBzdG9yZUVsZW1lbnRFdmVudCA9IGV2ZW50c1t0eXBlRXZlbnRdIHx8IHt9O1xuICAgICAgY29uc3QgaXNOYW1lc3BhY2UgPSBvcmlnaW5hbFR5cGVFdmVudC5zdGFydHNXaXRoKCcuJyk7XG4gICAgICBpZiAodHlwZW9mIGNhbGxhYmxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBTaW1wbGVzdCBjYXNlOiBoYW5kbGVyIGlzIHBhc3NlZCwgcmVtb3ZlIHRoYXQgbGlzdGVuZXIgT05MWS5cbiAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhzdG9yZUVsZW1lbnRFdmVudCkubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlbW92ZUhhbmRsZXIoZWxlbWVudCwgZXZlbnRzLCB0eXBlRXZlbnQsIGNhbGxhYmxlLCBpc0RlbGVnYXRlZCA/IGhhbmRsZXIgOiBudWxsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzTmFtZXNwYWNlKSB7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudEV2ZW50IG9mIE9iamVjdC5rZXlzKGV2ZW50cykpIHtcbiAgICAgICAgICByZW1vdmVOYW1lc3BhY2VkSGFuZGxlcnMoZWxlbWVudCwgZXZlbnRzLCBlbGVtZW50RXZlbnQsIG9yaWdpbmFsVHlwZUV2ZW50LnNsaWNlKDEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBba2V5SGFuZGxlcnMsIGV2ZW50XSBvZiBPYmplY3QuZW50cmllcyhzdG9yZUVsZW1lbnRFdmVudCkpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlcktleSA9IGtleUhhbmRsZXJzLnJlcGxhY2Uoc3RyaXBVaWRSZWdleCwgJycpO1xuICAgICAgICBpZiAoIWluTmFtZXNwYWNlIHx8IG9yaWdpbmFsVHlwZUV2ZW50LmluY2x1ZGVzKGhhbmRsZXJLZXkpKSB7XG4gICAgICAgICAgcmVtb3ZlSGFuZGxlcihlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgZXZlbnQuY2FsbGFibGUsIGV2ZW50LmRlbGVnYXRpb25TZWxlY3Rvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHRyaWdnZXIoZWxlbWVudCwgZXZlbnQsIGFyZ3MpIHtcbiAgICAgIGlmICh0eXBlb2YgZXZlbnQgIT09ICdzdHJpbmcnIHx8ICFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgJCA9IGdldGpRdWVyeSgpO1xuICAgICAgY29uc3QgdHlwZUV2ZW50ID0gZ2V0VHlwZUV2ZW50KGV2ZW50KTtcbiAgICAgIGNvbnN0IGluTmFtZXNwYWNlID0gZXZlbnQgIT09IHR5cGVFdmVudDtcbiAgICAgIGxldCBqUXVlcnlFdmVudCA9IG51bGw7XG4gICAgICBsZXQgYnViYmxlcyA9IHRydWU7XG4gICAgICBsZXQgbmF0aXZlRGlzcGF0Y2ggPSB0cnVlO1xuICAgICAgbGV0IGRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICAgIGlmIChpbk5hbWVzcGFjZSAmJiAkKSB7XG4gICAgICAgIGpRdWVyeUV2ZW50ID0gJC5FdmVudChldmVudCwgYXJncyk7XG4gICAgICAgICQoZWxlbWVudCkudHJpZ2dlcihqUXVlcnlFdmVudCk7XG4gICAgICAgIGJ1YmJsZXMgPSAhalF1ZXJ5RXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKTtcbiAgICAgICAgbmF0aXZlRGlzcGF0Y2ggPSAhalF1ZXJ5RXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKTtcbiAgICAgICAgZGVmYXVsdFByZXZlbnRlZCA9IGpRdWVyeUV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpO1xuICAgICAgfVxuICAgICAgY29uc3QgZXZ0ID0gaHlkcmF0ZU9iaihuZXcgRXZlbnQoZXZlbnQsIHtcbiAgICAgICAgYnViYmxlcyxcbiAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgfSksIGFyZ3MpO1xuICAgICAgaWYgKGRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICBpZiAobmF0aXZlRGlzcGF0Y2gpIHtcbiAgICAgICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgICB9XG4gICAgICBpZiAoZXZ0LmRlZmF1bHRQcmV2ZW50ZWQgJiYgalF1ZXJ5RXZlbnQpIHtcbiAgICAgICAgalF1ZXJ5RXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBldnQ7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBoeWRyYXRlT2JqKG9iaiwgbWV0YSA9IHt9KSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobWV0YSkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgZG9tL21hbmlwdWxhdG9yLmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICBmdW5jdGlvbiBub3JtYWxpemVEYXRhKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSAndHJ1ZScpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09ICdmYWxzZScpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSBOdW1iZXIodmFsdWUpLnRvU3RyaW5nKCkpIHtcbiAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSAnbnVsbCcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gICAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBub3JtYWxpemVEYXRhS2V5KGtleSkge1xuICAgIHJldHVybiBrZXkucmVwbGFjZSgvW0EtWl0vZywgY2hyID0+IGAtJHtjaHIudG9Mb3dlckNhc2UoKX1gKTtcbiAgfVxuICBjb25zdCBNYW5pcHVsYXRvciA9IHtcbiAgICBzZXREYXRhQXR0cmlidXRlKGVsZW1lbnQsIGtleSwgdmFsdWUpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGBkYXRhLWJzLSR7bm9ybWFsaXplRGF0YUtleShrZXkpfWAsIHZhbHVlKTtcbiAgICB9LFxuICAgIHJlbW92ZURhdGFBdHRyaWJ1dGUoZWxlbWVudCwga2V5KSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShgZGF0YS1icy0ke25vcm1hbGl6ZURhdGFLZXkoa2V5KX1gKTtcbiAgICB9LFxuICAgIGdldERhdGFBdHRyaWJ1dGVzKGVsZW1lbnQpIHtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gICAgICBjb25zdCBic0tleXMgPSBPYmplY3Qua2V5cyhlbGVtZW50LmRhdGFzZXQpLmZpbHRlcihrZXkgPT4ga2V5LnN0YXJ0c1dpdGgoJ2JzJykgJiYgIWtleS5zdGFydHNXaXRoKCdic0NvbmZpZycpKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGJzS2V5cykge1xuICAgICAgICBsZXQgcHVyZUtleSA9IGtleS5yZXBsYWNlKC9eYnMvLCAnJyk7XG4gICAgICAgIHB1cmVLZXkgPSBwdXJlS2V5LmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgcHVyZUtleS5zbGljZSgxLCBwdXJlS2V5Lmxlbmd0aCk7XG4gICAgICAgIGF0dHJpYnV0ZXNbcHVyZUtleV0gPSBub3JtYWxpemVEYXRhKGVsZW1lbnQuZGF0YXNldFtrZXldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgIH0sXG4gICAgZ2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCBrZXkpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVEYXRhKGVsZW1lbnQuZ2V0QXR0cmlidXRlKGBkYXRhLWJzLSR7bm9ybWFsaXplRGF0YUtleShrZXkpfWApKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCB1dGlsL2NvbmZpZy5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cblxuICAvKipcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxuICAgKi9cblxuICBjbGFzcyBDb25maWcge1xuICAgIC8vIEdldHRlcnNcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGhhdmUgdG8gaW1wbGVtZW50IHRoZSBzdGF0aWMgbWV0aG9kIFwiTkFNRVwiLCBmb3IgZWFjaCBjb21wb25lbnQhJyk7XG4gICAgfVxuICAgIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgICBjb25maWcgPSB0aGlzLl9tZXJnZUNvbmZpZ09iaihjb25maWcpO1xuICAgICAgY29uZmlnID0gdGhpcy5fY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpO1xuICAgICAgdGhpcy5fdHlwZUNoZWNrQ29uZmlnKGNvbmZpZyk7XG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cbiAgICBfY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpIHtcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuICAgIF9tZXJnZUNvbmZpZ09iaihjb25maWcsIGVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGpzb25Db25maWcgPSBpc0VsZW1lbnQoZWxlbWVudCkgPyBNYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlKGVsZW1lbnQsICdjb25maWcnKSA6IHt9OyAvLyB0cnkgdG8gcGFyc2VcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4udGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0LFxuICAgICAgICAuLi4odHlwZW9mIGpzb25Db25maWcgPT09ICdvYmplY3QnID8ganNvbkNvbmZpZyA6IHt9KSxcbiAgICAgICAgLi4uKGlzRWxlbWVudChlbGVtZW50KSA/IE1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGVzKGVsZW1lbnQpIDoge30pLFxuICAgICAgICAuLi4odHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgPyBjb25maWcgOiB7fSlcbiAgICAgIH07XG4gICAgfVxuICAgIF90eXBlQ2hlY2tDb25maWcoY29uZmlnLCBjb25maWdUeXBlcyA9IHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpIHtcbiAgICAgIGZvciAoY29uc3QgW3Byb3BlcnR5LCBleHBlY3RlZFR5cGVzXSBvZiBPYmplY3QuZW50cmllcyhjb25maWdUeXBlcykpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjb25maWdbcHJvcGVydHldO1xuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSBpc0VsZW1lbnQodmFsdWUpID8gJ2VsZW1lbnQnIDogdG9UeXBlKHZhbHVlKTtcbiAgICAgICAgaWYgKCFuZXcgUmVnRXhwKGV4cGVjdGVkVHlwZXMpLnRlc3QodmFsdWVUeXBlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7dGhpcy5jb25zdHJ1Y3Rvci5OQU1FLnRvVXBwZXJDYXNlKCl9OiBPcHRpb24gXCIke3Byb3BlcnR5fVwiIHByb3ZpZGVkIHR5cGUgXCIke3ZhbHVlVHlwZX1cIiBidXQgZXhwZWN0ZWQgdHlwZSBcIiR7ZXhwZWN0ZWRUeXBlc31cIi5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgYmFzZS1jb21wb25lbnQuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIENvbnN0YW50c1xuICAgKi9cblxuICBjb25zdCBWRVJTSU9OID0gJzUuMy4yJztcblxuICAvKipcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxuICAgKi9cblxuICBjbGFzcyBCYXNlQ29tcG9uZW50IGV4dGVuZHMgQ29uZmlnIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICBlbGVtZW50ID0gZ2V0RWxlbWVudChlbGVtZW50KTtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xuICAgICAgRGF0YS5zZXQodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSwgdGhpcyk7XG4gICAgfVxuXG4gICAgLy8gUHVibGljXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgIERhdGEucmVtb3ZlKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVkpO1xuICAgICAgRXZlbnRIYW5kbGVyLm9mZih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkVWRU5UX0tFWSk7XG4gICAgICBmb3IgKGNvbnN0IHByb3BlcnR5TmFtZSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSkge1xuICAgICAgICB0aGlzW3Byb3BlcnR5TmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBfcXVldWVDYWxsYmFjayhjYWxsYmFjaywgZWxlbWVudCwgaXNBbmltYXRlZCA9IHRydWUpIHtcbiAgICAgIGV4ZWN1dGVBZnRlclRyYW5zaXRpb24oY2FsbGJhY2ssIGVsZW1lbnQsIGlzQW5pbWF0ZWQpO1xuICAgIH1cbiAgICBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgICAgY29uZmlnID0gdGhpcy5fbWVyZ2VDb25maWdPYmooY29uZmlnLCB0aGlzLl9lbGVtZW50KTtcbiAgICAgIGNvbmZpZyA9IHRoaXMuX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKTtcbiAgICAgIHRoaXMuX3R5cGVDaGVja0NvbmZpZyhjb25maWcpO1xuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG5cbiAgICAvLyBTdGF0aWNcbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIERhdGEuZ2V0KGdldEVsZW1lbnQoZWxlbWVudCksIHRoaXMuREFUQV9LRVkpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZShlbGVtZW50LCBjb25maWcgPSB7fSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UoZWxlbWVudCkgfHwgbmV3IHRoaXMoZWxlbWVudCwgdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgPyBjb25maWcgOiBudWxsKTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBWRVJTSU9OKCkge1xuICAgICAgcmV0dXJuIFZFUlNJT047XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgREFUQV9LRVkoKSB7XG4gICAgICByZXR1cm4gYGJzLiR7dGhpcy5OQU1FfWA7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgRVZFTlRfS0VZKCkge1xuICAgICAgcmV0dXJuIGAuJHt0aGlzLkRBVEFfS0VZfWA7XG4gICAgfVxuICAgIHN0YXRpYyBldmVudE5hbWUobmFtZSkge1xuICAgICAgcmV0dXJuIGAke25hbWV9JHt0aGlzLkVWRU5UX0tFWX1gO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgZG9tL3NlbGVjdG9yLWVuZ2luZS5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgY29uc3QgZ2V0U2VsZWN0b3IgPSBlbGVtZW50ID0+IHtcbiAgICBsZXQgc2VsZWN0b3IgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1icy10YXJnZXQnKTtcbiAgICBpZiAoIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSAnIycpIHtcbiAgICAgIGxldCBocmVmQXR0cmlidXRlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcblxuICAgICAgLy8gVGhlIG9ubHkgdmFsaWQgY29udGVudCB0aGF0IGNvdWxkIGRvdWJsZSBhcyBhIHNlbGVjdG9yIGFyZSBJRHMgb3IgY2xhc3NlcyxcbiAgICAgIC8vIHNvIGV2ZXJ5dGhpbmcgc3RhcnRpbmcgd2l0aCBgI2Agb3IgYC5gLiBJZiBhIFwicmVhbFwiIFVSTCBpcyB1c2VkIGFzIHRoZSBzZWxlY3RvcixcbiAgICAgIC8vIGBkb2N1bWVudC5xdWVyeVNlbGVjdG9yYCB3aWxsIHJpZ2h0ZnVsbHkgY29tcGxhaW4gaXQgaXMgaW52YWxpZC5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvaXNzdWVzLzMyMjczXG4gICAgICBpZiAoIWhyZWZBdHRyaWJ1dGUgfHwgIWhyZWZBdHRyaWJ1dGUuaW5jbHVkZXMoJyMnKSAmJiAhaHJlZkF0dHJpYnV0ZS5zdGFydHNXaXRoKCcuJykpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIEp1c3QgaW4gY2FzZSBzb21lIENNUyBwdXRzIG91dCBhIGZ1bGwgVVJMIHdpdGggdGhlIGFuY2hvciBhcHBlbmRlZFxuICAgICAgaWYgKGhyZWZBdHRyaWJ1dGUuaW5jbHVkZXMoJyMnKSAmJiAhaHJlZkF0dHJpYnV0ZS5zdGFydHNXaXRoKCcjJykpIHtcbiAgICAgICAgaHJlZkF0dHJpYnV0ZSA9IGAjJHtocmVmQXR0cmlidXRlLnNwbGl0KCcjJylbMV19YDtcbiAgICAgIH1cbiAgICAgIHNlbGVjdG9yID0gaHJlZkF0dHJpYnV0ZSAmJiBocmVmQXR0cmlidXRlICE9PSAnIycgPyBwYXJzZVNlbGVjdG9yKGhyZWZBdHRyaWJ1dGUudHJpbSgpKSA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RvcjtcbiAgfTtcbiAgY29uc3QgU2VsZWN0b3JFbmdpbmUgPSB7XG4gICAgZmluZChzZWxlY3RvciwgZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgcmV0dXJuIFtdLmNvbmNhdCguLi5FbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsLmNhbGwoZWxlbWVudCwgc2VsZWN0b3IpKTtcbiAgICB9LFxuICAgIGZpbmRPbmUoc2VsZWN0b3IsIGVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBFbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yLmNhbGwoZWxlbWVudCwgc2VsZWN0b3IpO1xuICAgIH0sXG4gICAgY2hpbGRyZW4oZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBbXS5jb25jYXQoLi4uZWxlbWVudC5jaGlsZHJlbikuZmlsdGVyKGNoaWxkID0+IGNoaWxkLm1hdGNoZXMoc2VsZWN0b3IpKTtcbiAgICB9LFxuICAgIHBhcmVudHMoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgICAgIGxldCBhbmNlc3RvciA9IGVsZW1lbnQucGFyZW50Tm9kZS5jbG9zZXN0KHNlbGVjdG9yKTtcbiAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICBwYXJlbnRzLnB1c2goYW5jZXN0b3IpO1xuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudE5vZGUuY2xvc2VzdChzZWxlY3Rvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50cztcbiAgICB9LFxuICAgIHByZXYoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICAgIGxldCBwcmV2aW91cyA9IGVsZW1lbnQucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICAgIHdoaWxlIChwcmV2aW91cykge1xuICAgICAgICBpZiAocHJldmlvdXMubWF0Y2hlcyhzZWxlY3RvcikpIHtcbiAgICAgICAgICByZXR1cm4gW3ByZXZpb3VzXTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IHByZXZpb3VzLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gW107XG4gICAgfSxcbiAgICAvLyBUT0RPOiB0aGlzIGlzIG5vdyB1bnVzZWQ7IHJlbW92ZSBsYXRlciBhbG9uZyB3aXRoIHByZXYoKVxuICAgIG5leHQoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICAgIGxldCBuZXh0ID0gZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICB3aGlsZSAobmV4dCkge1xuICAgICAgICBpZiAobmV4dC5tYXRjaGVzKHNlbGVjdG9yKSkge1xuICAgICAgICAgIHJldHVybiBbbmV4dF07XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCA9IG5leHQubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgZm9jdXNhYmxlQ2hpbGRyZW4oZWxlbWVudCkge1xuICAgICAgY29uc3QgZm9jdXNhYmxlcyA9IFsnYScsICdidXR0b24nLCAnaW5wdXQnLCAndGV4dGFyZWEnLCAnc2VsZWN0JywgJ2RldGFpbHMnLCAnW3RhYmluZGV4XScsICdbY29udGVudGVkaXRhYmxlPVwidHJ1ZVwiXSddLm1hcChzZWxlY3RvciA9PiBgJHtzZWxlY3Rvcn06bm90KFt0YWJpbmRleF49XCItXCJdKWApLmpvaW4oJywnKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmQoZm9jdXNhYmxlcywgZWxlbWVudCkuZmlsdGVyKGVsID0+ICFpc0Rpc2FibGVkKGVsKSAmJiBpc1Zpc2libGUoZWwpKTtcbiAgICB9LFxuICAgIGdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3RvcihlbGVtZW50KTtcbiAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShzZWxlY3RvcikgPyBzZWxlY3RvciA6IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGdldEVsZW1lbnRGcm9tU2VsZWN0b3IoZWxlbWVudCkge1xuICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3RvcihlbGVtZW50KTtcbiAgICAgIHJldHVybiBzZWxlY3RvciA/IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoc2VsZWN0b3IpIDogbnVsbDtcbiAgICB9LFxuICAgIGdldE11bHRpcGxlRWxlbWVudHNGcm9tU2VsZWN0b3IoZWxlbWVudCkge1xuICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3RvcihlbGVtZW50KTtcbiAgICAgIHJldHVybiBzZWxlY3RvciA/IFNlbGVjdG9yRW5naW5lLmZpbmQoc2VsZWN0b3IpIDogW107XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgdXRpbC9jb21wb25lbnQtZnVuY3Rpb25zLmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICBjb25zdCBlbmFibGVEaXNtaXNzVHJpZ2dlciA9IChjb21wb25lbnQsIG1ldGhvZCA9ICdoaWRlJykgPT4ge1xuICAgIGNvbnN0IGNsaWNrRXZlbnQgPSBgY2xpY2suZGlzbWlzcyR7Y29tcG9uZW50LkVWRU5UX0tFWX1gO1xuICAgIGNvbnN0IG5hbWUgPSBjb21wb25lbnQuTkFNRTtcbiAgICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIGNsaWNrRXZlbnQsIGBbZGF0YS1icy1kaXNtaXNzPVwiJHtuYW1lfVwiXWAsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKFsnQScsICdBUkVBJ10uaW5jbHVkZXModGhpcy50YWdOYW1lKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGlzYWJsZWQodGhpcykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFyZ2V0ID0gU2VsZWN0b3JFbmdpbmUuZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0aGlzKSB8fCB0aGlzLmNsb3Nlc3QoYC4ke25hbWV9YCk7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IGNvbXBvbmVudC5nZXRPckNyZWF0ZUluc3RhbmNlKHRhcmdldCk7XG5cbiAgICAgIC8vIE1ldGhvZCBhcmd1bWVudCBpcyBsZWZ0LCBmb3IgQWxlcnQgYW5kIG9ubHksIGFzIGl0IGRvZXNuJ3QgaW1wbGVtZW50IHRoZSAnaGlkZScgbWV0aG9kXG4gICAgICBpbnN0YW5jZVttZXRob2RdKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCBhbGVydC5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cblxuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IE5BTUUkZiA9ICdhbGVydCc7XG4gIGNvbnN0IERBVEFfS0VZJGEgPSAnYnMuYWxlcnQnO1xuICBjb25zdCBFVkVOVF9LRVkkYiA9IGAuJHtEQVRBX0tFWSRhfWA7XG4gIGNvbnN0IEVWRU5UX0NMT1NFID0gYGNsb3NlJHtFVkVOVF9LRVkkYn1gO1xuICBjb25zdCBFVkVOVF9DTE9TRUQgPSBgY2xvc2VkJHtFVkVOVF9LRVkkYn1gO1xuICBjb25zdCBDTEFTU19OQU1FX0ZBREUkNSA9ICdmYWRlJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDggPSAnc2hvdyc7XG5cbiAgLyoqXG4gICAqIENsYXNzIGRlZmluaXRpb25cbiAgICovXG5cbiAgY2xhc3MgQWxlcnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICAvLyBHZXR0ZXJzXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgcmV0dXJuIE5BTUUkZjtcbiAgICB9XG5cbiAgICAvLyBQdWJsaWNcbiAgICBjbG9zZSgpIHtcbiAgICAgIGNvbnN0IGNsb3NlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9DTE9TRSk7XG4gICAgICBpZiAoY2xvc2VFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckOCk7XG4gICAgICBjb25zdCBpc0FuaW1hdGVkID0gdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFJDUpO1xuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB0aGlzLl9kZXN0cm95RWxlbWVudCgpLCB0aGlzLl9lbGVtZW50LCBpc0FuaW1hdGVkKTtcbiAgICB9XG5cbiAgICAvLyBQcml2YXRlXG4gICAgX2Rlc3Ryb3lFbGVtZW50KCkge1xuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmUoKTtcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0NMT1NFRCk7XG4gICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICB9XG5cbiAgICAvLyBTdGF0aWNcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBBbGVydC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpO1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFbY29uZmlnXSA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5zdGFydHNXaXRoKCdfJykgfHwgY29uZmlnID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhW2NvbmZpZ10odGhpcyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cbiAgICovXG5cbiAgZW5hYmxlRGlzbWlzc1RyaWdnZXIoQWxlcnQsICdjbG9zZScpO1xuXG4gIC8qKlxuICAgKiBqUXVlcnlcbiAgICovXG5cbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKEFsZXJ0KTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwIGJ1dHRvbi5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cblxuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IE5BTUUkZSA9ICdidXR0b24nO1xuICBjb25zdCBEQVRBX0tFWSQ5ID0gJ2JzLmJ1dHRvbic7XG4gIGNvbnN0IEVWRU5UX0tFWSRhID0gYC4ke0RBVEFfS0VZJDl9YDtcbiAgY29uc3QgREFUQV9BUElfS0VZJDYgPSAnLmRhdGEtYXBpJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9BQ1RJVkUkMyA9ICdhY3RpdmUnO1xuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ1ID0gJ1tkYXRhLWJzLXRvZ2dsZT1cImJ1dHRvblwiXSc7XG4gIGNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJJDYgPSBgY2xpY2ske0VWRU5UX0tFWSRhfSR7REFUQV9BUElfS0VZJDZ9YDtcblxuICAvKipcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxuICAgKi9cblxuICBjbGFzcyBCdXR0b24gZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICAvLyBHZXR0ZXJzXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgcmV0dXJuIE5BTUUkZTtcbiAgICB9XG5cbiAgICAvLyBQdWJsaWNcbiAgICB0b2dnbGUoKSB7XG4gICAgICAvLyBUb2dnbGUgY2xhc3MgYW5kIHN5bmMgdGhlIGBhcmlhLXByZXNzZWRgIGF0dHJpYnV0ZSB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGAudG9nZ2xlKClgIG1ldGhvZFxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtcHJlc3NlZCcsIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShDTEFTU19OQU1FX0FDVElWRSQzKSk7XG4gICAgfVxuXG4gICAgLy8gU3RhdGljXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gQnV0dG9uLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcyk7XG4gICAgICAgIGlmIChjb25maWcgPT09ICd0b2dnbGUnKSB7XG4gICAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICAgKi9cblxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDYsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDUsIGV2ZW50ID0+IHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IGJ1dHRvbiA9IGV2ZW50LnRhcmdldC5jbG9zZXN0KFNFTEVDVE9SX0RBVEFfVE9HR0xFJDUpO1xuICAgIGNvbnN0IGRhdGEgPSBCdXR0b24uZ2V0T3JDcmVhdGVJbnN0YW5jZShidXR0b24pO1xuICAgIGRhdGEudG9nZ2xlKCk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBqUXVlcnlcbiAgICovXG5cbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKEJ1dHRvbik7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCB1dGlsL3N3aXBlLmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBDb25zdGFudHNcbiAgICovXG5cbiAgY29uc3QgTkFNRSRkID0gJ3N3aXBlJztcbiAgY29uc3QgRVZFTlRfS0VZJDkgPSAnLmJzLnN3aXBlJztcbiAgY29uc3QgRVZFTlRfVE9VQ0hTVEFSVCA9IGB0b3VjaHN0YXJ0JHtFVkVOVF9LRVkkOX1gO1xuICBjb25zdCBFVkVOVF9UT1VDSE1PVkUgPSBgdG91Y2htb3ZlJHtFVkVOVF9LRVkkOX1gO1xuICBjb25zdCBFVkVOVF9UT1VDSEVORCA9IGB0b3VjaGVuZCR7RVZFTlRfS0VZJDl9YDtcbiAgY29uc3QgRVZFTlRfUE9JTlRFUkRPV04gPSBgcG9pbnRlcmRvd24ke0VWRU5UX0tFWSQ5fWA7XG4gIGNvbnN0IEVWRU5UX1BPSU5URVJVUCA9IGBwb2ludGVydXAke0VWRU5UX0tFWSQ5fWA7XG4gIGNvbnN0IFBPSU5URVJfVFlQRV9UT1VDSCA9ICd0b3VjaCc7XG4gIGNvbnN0IFBPSU5URVJfVFlQRV9QRU4gPSAncGVuJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9QT0lOVEVSX0VWRU5UID0gJ3BvaW50ZXItZXZlbnQnO1xuICBjb25zdCBTV0lQRV9USFJFU0hPTEQgPSA0MDtcbiAgY29uc3QgRGVmYXVsdCRjID0ge1xuICAgIGVuZENhbGxiYWNrOiBudWxsLFxuICAgIGxlZnRDYWxsYmFjazogbnVsbCxcbiAgICByaWdodENhbGxiYWNrOiBudWxsXG4gIH07XG4gIGNvbnN0IERlZmF1bHRUeXBlJGMgPSB7XG4gICAgZW5kQ2FsbGJhY2s6ICcoZnVuY3Rpb258bnVsbCknLFxuICAgIGxlZnRDYWxsYmFjazogJyhmdW5jdGlvbnxudWxsKScsXG4gICAgcmlnaHRDYWxsYmFjazogJyhmdW5jdGlvbnxudWxsKSdcbiAgfTtcblxuICAvKipcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxuICAgKi9cblxuICBjbGFzcyBTd2lwZSBleHRlbmRzIENvbmZpZyB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICBpZiAoIWVsZW1lbnQgfHwgIVN3aXBlLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XG4gICAgICB0aGlzLl9kZWx0YVggPSAwO1xuICAgICAgdGhpcy5fc3VwcG9ydFBvaW50ZXJFdmVudHMgPSBCb29sZWFuKHdpbmRvdy5Qb2ludGVyRXZlbnQpO1xuICAgICAgdGhpcy5faW5pdEV2ZW50cygpO1xuICAgIH1cblxuICAgIC8vIEdldHRlcnNcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdCRjO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJGM7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICAgIHJldHVybiBOQU1FJGQ7XG4gICAgfVxuXG4gICAgLy8gUHVibGljXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZWxlbWVudCwgRVZFTlRfS0VZJDkpO1xuICAgIH1cblxuICAgIC8vIFByaXZhdGVcbiAgICBfc3RhcnQoZXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy5fc3VwcG9ydFBvaW50ZXJFdmVudHMpIHtcbiAgICAgICAgdGhpcy5fZGVsdGFYID0gZXZlbnQudG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fZXZlbnRJc1BvaW50ZXJQZW5Ub3VjaChldmVudCkpIHtcbiAgICAgICAgdGhpcy5fZGVsdGFYID0gZXZlbnQuY2xpZW50WDtcbiAgICAgIH1cbiAgICB9XG4gICAgX2VuZChldmVudCkge1xuICAgICAgaWYgKHRoaXMuX2V2ZW50SXNQb2ludGVyUGVuVG91Y2goZXZlbnQpKSB7XG4gICAgICAgIHRoaXMuX2RlbHRhWCA9IGV2ZW50LmNsaWVudFggLSB0aGlzLl9kZWx0YVg7XG4gICAgICB9XG4gICAgICB0aGlzLl9oYW5kbGVTd2lwZSgpO1xuICAgICAgZXhlY3V0ZSh0aGlzLl9jb25maWcuZW5kQ2FsbGJhY2spO1xuICAgIH1cbiAgICBfbW92ZShldmVudCkge1xuICAgICAgdGhpcy5fZGVsdGFYID0gZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDEgPyAwIDogZXZlbnQudG91Y2hlc1swXS5jbGllbnRYIC0gdGhpcy5fZGVsdGFYO1xuICAgIH1cbiAgICBfaGFuZGxlU3dpcGUoKSB7XG4gICAgICBjb25zdCBhYnNEZWx0YVggPSBNYXRoLmFicyh0aGlzLl9kZWx0YVgpO1xuICAgICAgaWYgKGFic0RlbHRhWCA8PSBTV0lQRV9USFJFU0hPTEQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZGlyZWN0aW9uID0gYWJzRGVsdGFYIC8gdGhpcy5fZGVsdGFYO1xuICAgICAgdGhpcy5fZGVsdGFYID0gMDtcbiAgICAgIGlmICghZGlyZWN0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV4ZWN1dGUoZGlyZWN0aW9uID4gMCA/IHRoaXMuX2NvbmZpZy5yaWdodENhbGxiYWNrIDogdGhpcy5fY29uZmlnLmxlZnRDYWxsYmFjayk7XG4gICAgfVxuICAgIF9pbml0RXZlbnRzKCkge1xuICAgICAgaWYgKHRoaXMuX3N1cHBvcnRQb2ludGVyRXZlbnRzKSB7XG4gICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9QT0lOVEVSRE9XTiwgZXZlbnQgPT4gdGhpcy5fc3RhcnQoZXZlbnQpKTtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1BPSU5URVJVUCwgZXZlbnQgPT4gdGhpcy5fZW5kKGV2ZW50KSk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1BPSU5URVJfRVZFTlQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1RPVUNIU1RBUlQsIGV2ZW50ID0+IHRoaXMuX3N0YXJ0KGV2ZW50KSk7XG4gICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9UT1VDSE1PVkUsIGV2ZW50ID0+IHRoaXMuX21vdmUoZXZlbnQpKTtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1RPVUNIRU5ELCBldmVudCA9PiB0aGlzLl9lbmQoZXZlbnQpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX2V2ZW50SXNQb2ludGVyUGVuVG91Y2goZXZlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdXBwb3J0UG9pbnRlckV2ZW50cyAmJiAoZXZlbnQucG9pbnRlclR5cGUgPT09IFBPSU5URVJfVFlQRV9QRU4gfHwgZXZlbnQucG9pbnRlclR5cGUgPT09IFBPSU5URVJfVFlQRV9UT1VDSCk7XG4gICAgfVxuXG4gICAgLy8gU3RhdGljXG4gICAgc3RhdGljIGlzU3VwcG9ydGVkKCkge1xuICAgICAgcmV0dXJuICdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgY2Fyb3VzZWwuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIENvbnN0YW50c1xuICAgKi9cblxuICBjb25zdCBOQU1FJGMgPSAnY2Fyb3VzZWwnO1xuICBjb25zdCBEQVRBX0tFWSQ4ID0gJ2JzLmNhcm91c2VsJztcbiAgY29uc3QgRVZFTlRfS0VZJDggPSBgLiR7REFUQV9LRVkkOH1gO1xuICBjb25zdCBEQVRBX0FQSV9LRVkkNSA9ICcuZGF0YS1hcGknO1xuICBjb25zdCBBUlJPV19MRUZUX0tFWSQxID0gJ0Fycm93TGVmdCc7XG4gIGNvbnN0IEFSUk9XX1JJR0hUX0tFWSQxID0gJ0Fycm93UmlnaHQnO1xuICBjb25zdCBUT1VDSEVWRU5UX0NPTVBBVF9XQUlUID0gNTAwOyAvLyBUaW1lIGZvciBtb3VzZSBjb21wYXQgZXZlbnRzIHRvIGZpcmUgYWZ0ZXIgdG91Y2hcblxuICBjb25zdCBPUkRFUl9ORVhUID0gJ25leHQnO1xuICBjb25zdCBPUkRFUl9QUkVWID0gJ3ByZXYnO1xuICBjb25zdCBESVJFQ1RJT05fTEVGVCA9ICdsZWZ0JztcbiAgY29uc3QgRElSRUNUSU9OX1JJR0hUID0gJ3JpZ2h0JztcbiAgY29uc3QgRVZFTlRfU0xJREUgPSBgc2xpZGUke0VWRU5UX0tFWSQ4fWA7XG4gIGNvbnN0IEVWRU5UX1NMSUQgPSBgc2xpZCR7RVZFTlRfS0VZJDh9YDtcbiAgY29uc3QgRVZFTlRfS0VZRE9XTiQxID0gYGtleWRvd24ke0VWRU5UX0tFWSQ4fWA7XG4gIGNvbnN0IEVWRU5UX01PVVNFRU5URVIkMSA9IGBtb3VzZWVudGVyJHtFVkVOVF9LRVkkOH1gO1xuICBjb25zdCBFVkVOVF9NT1VTRUxFQVZFJDEgPSBgbW91c2VsZWF2ZSR7RVZFTlRfS0VZJDh9YDtcbiAgY29uc3QgRVZFTlRfRFJBR19TVEFSVCA9IGBkcmFnc3RhcnQke0VWRU5UX0tFWSQ4fWA7XG4gIGNvbnN0IEVWRU5UX0xPQURfREFUQV9BUEkkMyA9IGBsb2FkJHtFVkVOVF9LRVkkOH0ke0RBVEFfQVBJX0tFWSQ1fWA7XG4gIGNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJJDUgPSBgY2xpY2ske0VWRU5UX0tFWSQ4fSR7REFUQV9BUElfS0VZJDV9YDtcbiAgY29uc3QgQ0xBU1NfTkFNRV9DQVJPVVNFTCA9ICdjYXJvdXNlbCc7XG4gIGNvbnN0IENMQVNTX05BTUVfQUNUSVZFJDIgPSAnYWN0aXZlJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9TTElERSA9ICdzbGlkZSc7XG4gIGNvbnN0IENMQVNTX05BTUVfRU5EID0gJ2Nhcm91c2VsLWl0ZW0tZW5kJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9TVEFSVCA9ICdjYXJvdXNlbC1pdGVtLXN0YXJ0JztcbiAgY29uc3QgQ0xBU1NfTkFNRV9ORVhUID0gJ2Nhcm91c2VsLWl0ZW0tbmV4dCc7XG4gIGNvbnN0IENMQVNTX05BTUVfUFJFViA9ICdjYXJvdXNlbC1pdGVtLXByZXYnO1xuICBjb25zdCBTRUxFQ1RPUl9BQ1RJVkUgPSAnLmFjdGl2ZSc7XG4gIGNvbnN0IFNFTEVDVE9SX0lURU0gPSAnLmNhcm91c2VsLWl0ZW0nO1xuICBjb25zdCBTRUxFQ1RPUl9BQ1RJVkVfSVRFTSA9IFNFTEVDVE9SX0FDVElWRSArIFNFTEVDVE9SX0lURU07XG4gIGNvbnN0IFNFTEVDVE9SX0lURU1fSU1HID0gJy5jYXJvdXNlbC1pdGVtIGltZyc7XG4gIGNvbnN0IFNFTEVDVE9SX0lORElDQVRPUlMgPSAnLmNhcm91c2VsLWluZGljYXRvcnMnO1xuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1NMSURFID0gJ1tkYXRhLWJzLXNsaWRlXSwgW2RhdGEtYnMtc2xpZGUtdG9dJztcbiAgY29uc3QgU0VMRUNUT1JfREFUQV9SSURFID0gJ1tkYXRhLWJzLXJpZGU9XCJjYXJvdXNlbFwiXSc7XG4gIGNvbnN0IEtFWV9UT19ESVJFQ1RJT04gPSB7XG4gICAgW0FSUk9XX0xFRlRfS0VZJDFdOiBESVJFQ1RJT05fUklHSFQsXG4gICAgW0FSUk9XX1JJR0hUX0tFWSQxXTogRElSRUNUSU9OX0xFRlRcbiAgfTtcbiAgY29uc3QgRGVmYXVsdCRiID0ge1xuICAgIGludGVydmFsOiA1MDAwLFxuICAgIGtleWJvYXJkOiB0cnVlLFxuICAgIHBhdXNlOiAnaG92ZXInLFxuICAgIHJpZGU6IGZhbHNlLFxuICAgIHRvdWNoOiB0cnVlLFxuICAgIHdyYXA6IHRydWVcbiAgfTtcbiAgY29uc3QgRGVmYXVsdFR5cGUkYiA9IHtcbiAgICBpbnRlcnZhbDogJyhudW1iZXJ8Ym9vbGVhbiknLFxuICAgIC8vIFRPRE86djYgcmVtb3ZlIGJvb2xlYW4gc3VwcG9ydFxuICAgIGtleWJvYXJkOiAnYm9vbGVhbicsXG4gICAgcGF1c2U6ICcoc3RyaW5nfGJvb2xlYW4pJyxcbiAgICByaWRlOiAnKGJvb2xlYW58c3RyaW5nKScsXG4gICAgdG91Y2g6ICdib29sZWFuJyxcbiAgICB3cmFwOiAnYm9vbGVhbidcbiAgfTtcblxuICAvKipcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxuICAgKi9cblxuICBjbGFzcyBDYXJvdXNlbCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKTtcbiAgICAgIHRoaXMuX2ludGVydmFsID0gbnVsbDtcbiAgICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAgICAgdGhpcy5faXNTbGlkaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLnRvdWNoVGltZW91dCA9IG51bGw7XG4gICAgICB0aGlzLl9zd2lwZUhlbHBlciA9IG51bGw7XG4gICAgICB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfSU5ESUNBVE9SUywgdGhpcy5fZWxlbWVudCk7XG4gICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5yaWRlID09PSBDTEFTU19OQU1FX0NBUk9VU0VMKSB7XG4gICAgICAgIHRoaXMuY3ljbGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZXR0ZXJzXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgICAgcmV0dXJuIERlZmF1bHQkYjtcbiAgICB9XG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSRiO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgICByZXR1cm4gTkFNRSRjO1xuICAgIH1cblxuICAgIC8vIFB1YmxpY1xuICAgIG5leHQoKSB7XG4gICAgICB0aGlzLl9zbGlkZShPUkRFUl9ORVhUKTtcbiAgICB9XG4gICAgbmV4dFdoZW5WaXNpYmxlKCkge1xuICAgICAgLy8gRklYTUUgVE9ETyB1c2UgYGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZWBcbiAgICAgIC8vIERvbid0IGNhbGwgbmV4dCB3aGVuIHRoZSBwYWdlIGlzbid0IHZpc2libGVcbiAgICAgIC8vIG9yIHRoZSBjYXJvdXNlbCBvciBpdHMgcGFyZW50IGlzbid0IHZpc2libGVcbiAgICAgIGlmICghZG9jdW1lbnQuaGlkZGVuICYmIGlzVmlzaWJsZSh0aGlzLl9lbGVtZW50KSkge1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJldigpIHtcbiAgICAgIHRoaXMuX3NsaWRlKE9SREVSX1BSRVYpO1xuICAgIH1cbiAgICBwYXVzZSgpIHtcbiAgICAgIGlmICh0aGlzLl9pc1NsaWRpbmcpIHtcbiAgICAgICAgdHJpZ2dlclRyYW5zaXRpb25FbmQodGhpcy5fZWxlbWVudCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jbGVhckludGVydmFsKCk7XG4gICAgfVxuICAgIGN5Y2xlKCkge1xuICAgICAgdGhpcy5fY2xlYXJJbnRlcnZhbCgpO1xuICAgICAgdGhpcy5fdXBkYXRlSW50ZXJ2YWwoKTtcbiAgICAgIHRoaXMuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5uZXh0V2hlblZpc2libGUoKSwgdGhpcy5fY29uZmlnLmludGVydmFsKTtcbiAgICB9XG4gICAgX21heWJlRW5hYmxlQ3ljbGUoKSB7XG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5yaWRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9pc1NsaWRpbmcpIHtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uZSh0aGlzLl9lbGVtZW50LCBFVkVOVF9TTElELCAoKSA9PiB0aGlzLmN5Y2xlKCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmN5Y2xlKCk7XG4gICAgfVxuICAgIHRvKGluZGV4KSB7XG4gICAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2dldEl0ZW1zKCk7XG4gICAgICBpZiAoaW5kZXggPiBpdGVtcy5sZW5ndGggLSAxIHx8IGluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5faXNTbGlkaW5nKSB7XG4gICAgICAgIEV2ZW50SGFuZGxlci5vbmUodGhpcy5fZWxlbWVudCwgRVZFTlRfU0xJRCwgKCkgPT4gdGhpcy50byhpbmRleCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBhY3RpdmVJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleCh0aGlzLl9nZXRBY3RpdmUoKSk7XG4gICAgICBpZiAoYWN0aXZlSW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9yZGVyID0gaW5kZXggPiBhY3RpdmVJbmRleCA/IE9SREVSX05FWFQgOiBPUkRFUl9QUkVWO1xuICAgICAgdGhpcy5fc2xpZGUob3JkZXIsIGl0ZW1zW2luZGV4XSk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICBpZiAodGhpcy5fc3dpcGVIZWxwZXIpIHtcbiAgICAgICAgdGhpcy5fc3dpcGVIZWxwZXIuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIC8vIFByaXZhdGVcbiAgICBfY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpIHtcbiAgICAgIGNvbmZpZy5kZWZhdWx0SW50ZXJ2YWwgPSBjb25maWcuaW50ZXJ2YWw7XG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cbiAgICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICBpZiAodGhpcy5fY29uZmlnLmtleWJvYXJkKSB7XG4gICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVlET1dOJDEsIGV2ZW50ID0+IHRoaXMuX2tleWRvd24oZXZlbnQpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9jb25maWcucGF1c2UgPT09ICdob3ZlcicpIHtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFRU5URVIkMSwgKCkgPT4gdGhpcy5wYXVzZSgpKTtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFTEVBVkUkMSwgKCkgPT4gdGhpcy5fbWF5YmVFbmFibGVDeWNsZSgpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9jb25maWcudG91Y2ggJiYgU3dpcGUuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICB0aGlzLl9hZGRUb3VjaEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICB9XG4gICAgfVxuICAgIF9hZGRUb3VjaEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgZm9yIChjb25zdCBpbWcgb2YgU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9JVEVNX0lNRywgdGhpcy5fZWxlbWVudCkpIHtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKGltZywgRVZFTlRfRFJBR19TVEFSVCwgZXZlbnQgPT4gZXZlbnQucHJldmVudERlZmF1bHQoKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBlbmRDYWxsQmFjayA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5wYXVzZSAhPT0gJ2hvdmVyJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGl0J3MgYSB0b3VjaC1lbmFibGVkIGRldmljZSwgbW91c2VlbnRlci9sZWF2ZSBhcmUgZmlyZWQgYXNcbiAgICAgICAgLy8gcGFydCBvZiB0aGUgbW91c2UgY29tcGF0aWJpbGl0eSBldmVudHMgb24gZmlyc3QgdGFwIC0gdGhlIGNhcm91c2VsXG4gICAgICAgIC8vIHdvdWxkIHN0b3AgY3ljbGluZyB1bnRpbCB1c2VyIHRhcHBlZCBvdXQgb2YgaXQ7XG4gICAgICAgIC8vIGhlcmUsIHdlIGxpc3RlbiBmb3IgdG91Y2hlbmQsIGV4cGxpY2l0bHkgcGF1c2UgdGhlIGNhcm91c2VsXG4gICAgICAgIC8vIChhcyBpZiBpdCdzIHRoZSBzZWNvbmQgdGltZSB3ZSB0YXAgb24gaXQsIG1vdXNlZW50ZXIgY29tcGF0IGV2ZW50XG4gICAgICAgIC8vIGlzIE5PVCBmaXJlZCkgYW5kIGFmdGVyIGEgdGltZW91dCAodG8gYWxsb3cgZm9yIG1vdXNlIGNvbXBhdGliaWxpdHlcbiAgICAgICAgLy8gZXZlbnRzIHRvIGZpcmUpIHdlIGV4cGxpY2l0bHkgcmVzdGFydCBjeWNsaW5nXG5cbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICBpZiAodGhpcy50b3VjaFRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50b3VjaFRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG91Y2hUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLl9tYXliZUVuYWJsZUN5Y2xlKCksIFRPVUNIRVZFTlRfQ09NUEFUX1dBSVQgKyB0aGlzLl9jb25maWcuaW50ZXJ2YWwpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHN3aXBlQ29uZmlnID0ge1xuICAgICAgICBsZWZ0Q2FsbGJhY2s6ICgpID0+IHRoaXMuX3NsaWRlKHRoaXMuX2RpcmVjdGlvblRvT3JkZXIoRElSRUNUSU9OX0xFRlQpKSxcbiAgICAgICAgcmlnaHRDYWxsYmFjazogKCkgPT4gdGhpcy5fc2xpZGUodGhpcy5fZGlyZWN0aW9uVG9PcmRlcihESVJFQ1RJT05fUklHSFQpKSxcbiAgICAgICAgZW5kQ2FsbGJhY2s6IGVuZENhbGxCYWNrXG4gICAgICB9O1xuICAgICAgdGhpcy5fc3dpcGVIZWxwZXIgPSBuZXcgU3dpcGUodGhpcy5fZWxlbWVudCwgc3dpcGVDb25maWcpO1xuICAgIH1cbiAgICBfa2V5ZG93bihldmVudCkge1xuICAgICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IEtFWV9UT19ESVJFQ1RJT05bZXZlbnQua2V5XTtcbiAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5fc2xpZGUodGhpcy5fZGlyZWN0aW9uVG9PcmRlcihkaXJlY3Rpb24pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX2dldEl0ZW1JbmRleChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0SXRlbXMoKS5pbmRleE9mKGVsZW1lbnQpO1xuICAgIH1cbiAgICBfc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudChpbmRleCkge1xuICAgICAgaWYgKCF0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBhY3RpdmVJbmRpY2F0b3IgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0FDVElWRSwgdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQpO1xuICAgICAgYWN0aXZlSW5kaWNhdG9yLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUkMik7XG4gICAgICBhY3RpdmVJbmRpY2F0b3IucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWN1cnJlbnQnKTtcbiAgICAgIGNvbnN0IG5ld0FjdGl2ZUluZGljYXRvciA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoYFtkYXRhLWJzLXNsaWRlLXRvPVwiJHtpbmRleH1cIl1gLCB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCk7XG4gICAgICBpZiAobmV3QWN0aXZlSW5kaWNhdG9yKSB7XG4gICAgICAgIG5ld0FjdGl2ZUluZGljYXRvci5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDIpO1xuICAgICAgICBuZXdBY3RpdmVJbmRpY2F0b3Iuc2V0QXR0cmlidXRlKCdhcmlhLWN1cnJlbnQnLCAndHJ1ZScpO1xuICAgICAgfVxuICAgIH1cbiAgICBfdXBkYXRlSW50ZXJ2YWwoKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fYWN0aXZlRWxlbWVudCB8fCB0aGlzLl9nZXRBY3RpdmUoKTtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBlbGVtZW50SW50ZXJ2YWwgPSBOdW1iZXIucGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtaW50ZXJ2YWwnKSwgMTApO1xuICAgICAgdGhpcy5fY29uZmlnLmludGVydmFsID0gZWxlbWVudEludGVydmFsIHx8IHRoaXMuX2NvbmZpZy5kZWZhdWx0SW50ZXJ2YWw7XG4gICAgfVxuICAgIF9zbGlkZShvcmRlciwgZWxlbWVudCA9IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLl9pc1NsaWRpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IHRoaXMuX2dldEFjdGl2ZSgpO1xuICAgICAgY29uc3QgaXNOZXh0ID0gb3JkZXIgPT09IE9SREVSX05FWFQ7XG4gICAgICBjb25zdCBuZXh0RWxlbWVudCA9IGVsZW1lbnQgfHwgZ2V0TmV4dEFjdGl2ZUVsZW1lbnQodGhpcy5fZ2V0SXRlbXMoKSwgYWN0aXZlRWxlbWVudCwgaXNOZXh0LCB0aGlzLl9jb25maWcud3JhcCk7XG4gICAgICBpZiAobmV4dEVsZW1lbnQgPT09IGFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV4dEVsZW1lbnRJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleChuZXh0RWxlbWVudCk7XG4gICAgICBjb25zdCB0cmlnZ2VyRXZlbnQgPSBldmVudE5hbWUgPT4ge1xuICAgICAgICByZXR1cm4gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgZXZlbnROYW1lLCB7XG4gICAgICAgICAgcmVsYXRlZFRhcmdldDogbmV4dEVsZW1lbnQsXG4gICAgICAgICAgZGlyZWN0aW9uOiB0aGlzLl9vcmRlclRvRGlyZWN0aW9uKG9yZGVyKSxcbiAgICAgICAgICBmcm9tOiB0aGlzLl9nZXRJdGVtSW5kZXgoYWN0aXZlRWxlbWVudCksXG4gICAgICAgICAgdG86IG5leHRFbGVtZW50SW5kZXhcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2xpZGVFdmVudCA9IHRyaWdnZXJFdmVudChFVkVOVF9TTElERSk7XG4gICAgICBpZiAoc2xpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghYWN0aXZlRWxlbWVudCB8fCAhbmV4dEVsZW1lbnQpIHtcbiAgICAgICAgLy8gU29tZSB3ZWlyZG5lc3MgaXMgaGFwcGVuaW5nLCBzbyB3ZSBiYWlsXG4gICAgICAgIC8vIFRPRE86IGNoYW5nZSB0ZXN0cyB0aGF0IHVzZSBlbXB0eSBkaXZzIHRvIGF2b2lkIHRoaXMgY2hlY2tcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNDeWNsaW5nID0gQm9vbGVhbih0aGlzLl9pbnRlcnZhbCk7XG4gICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICB0aGlzLl9pc1NsaWRpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5fc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudChuZXh0RWxlbWVudEluZGV4KTtcbiAgICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBuZXh0RWxlbWVudDtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbmFsQ2xhc3NOYW1lID0gaXNOZXh0ID8gQ0xBU1NfTkFNRV9TVEFSVCA6IENMQVNTX05BTUVfRU5EO1xuICAgICAgY29uc3Qgb3JkZXJDbGFzc05hbWUgPSBpc05leHQgPyBDTEFTU19OQU1FX05FWFQgOiBDTEFTU19OQU1FX1BSRVY7XG4gICAgICBuZXh0RWxlbWVudC5jbGFzc0xpc3QuYWRkKG9yZGVyQ2xhc3NOYW1lKTtcbiAgICAgIHJlZmxvdyhuZXh0RWxlbWVudCk7XG4gICAgICBhY3RpdmVFbGVtZW50LmNsYXNzTGlzdC5hZGQoZGlyZWN0aW9uYWxDbGFzc05hbWUpO1xuICAgICAgbmV4dEVsZW1lbnQuY2xhc3NMaXN0LmFkZChkaXJlY3Rpb25hbENsYXNzTmFtZSk7XG4gICAgICBjb25zdCBjb21wbGV0ZUNhbGxCYWNrID0gKCkgPT4ge1xuICAgICAgICBuZXh0RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGRpcmVjdGlvbmFsQ2xhc3NOYW1lLCBvcmRlckNsYXNzTmFtZSk7XG4gICAgICAgIG5leHRFbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMik7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0FDVElWRSQyLCBvcmRlckNsYXNzTmFtZSwgZGlyZWN0aW9uYWxDbGFzc05hbWUpO1xuICAgICAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdHJpZ2dlckV2ZW50KEVWRU5UX1NMSUQpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGVDYWxsQmFjaywgYWN0aXZlRWxlbWVudCwgdGhpcy5faXNBbmltYXRlZCgpKTtcbiAgICAgIGlmIChpc0N5Y2xpbmcpIHtcbiAgICAgICAgdGhpcy5jeWNsZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBfaXNBbmltYXRlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NMSURFKTtcbiAgICB9XG4gICAgX2dldEFjdGl2ZSgpIHtcbiAgICAgIHJldHVybiBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0FDVElWRV9JVEVNLCB0aGlzLl9lbGVtZW50KTtcbiAgICB9XG4gICAgX2dldEl0ZW1zKCkge1xuICAgICAgcmV0dXJuIFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfSVRFTSwgdGhpcy5fZWxlbWVudCk7XG4gICAgfVxuICAgIF9jbGVhckludGVydmFsKCkge1xuICAgICAgaWYgKHRoaXMuX2ludGVydmFsKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIF9kaXJlY3Rpb25Ub09yZGVyKGRpcmVjdGlvbikge1xuICAgICAgaWYgKGlzUlRMKCkpIHtcbiAgICAgICAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX0xFRlQgPyBPUkRFUl9QUkVWIDogT1JERVJfTkVYVDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkaXJlY3Rpb24gPT09IERJUkVDVElPTl9MRUZUID8gT1JERVJfTkVYVCA6IE9SREVSX1BSRVY7XG4gICAgfVxuICAgIF9vcmRlclRvRGlyZWN0aW9uKG9yZGVyKSB7XG4gICAgICBpZiAoaXNSVEwoKSkge1xuICAgICAgICByZXR1cm4gb3JkZXIgPT09IE9SREVSX1BSRVYgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmRlciA9PT0gT1JERVJfUFJFViA/IERJUkVDVElPTl9SSUdIVCA6IERJUkVDVElPTl9MRUZUO1xuICAgIH1cblxuICAgIC8vIFN0YXRpY1xuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IENhcm91c2VsLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgZGF0YS50byhjb25maWcpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQgfHwgY29uZmlnLnN0YXJ0c1dpdGgoJ18nKSB8fCBjb25maWcgPT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cbiAgICovXG5cbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQ1LCBTRUxFQ1RPUl9EQVRBX1NMSURFLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBTZWxlY3RvckVuZ2luZS5nZXRFbGVtZW50RnJvbVNlbGVjdG9yKHRoaXMpO1xuICAgIGlmICghdGFyZ2V0IHx8ICF0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfQ0FST1VTRUwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgY2Fyb3VzZWwgPSBDYXJvdXNlbC5nZXRPckNyZWF0ZUluc3RhbmNlKHRhcmdldCk7XG4gICAgY29uc3Qgc2xpZGVJbmRleCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLXNsaWRlLXRvJyk7XG4gICAgaWYgKHNsaWRlSW5kZXgpIHtcbiAgICAgIGNhcm91c2VsLnRvKHNsaWRlSW5kZXgpO1xuICAgICAgY2Fyb3VzZWwuX21heWJlRW5hYmxlQ3ljbGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKE1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGUodGhpcywgJ3NsaWRlJykgPT09ICduZXh0Jykge1xuICAgICAgY2Fyb3VzZWwubmV4dCgpO1xuICAgICAgY2Fyb3VzZWwuX21heWJlRW5hYmxlQ3ljbGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2Fyb3VzZWwucHJldigpO1xuICAgIGNhcm91c2VsLl9tYXliZUVuYWJsZUN5Y2xlKCk7XG4gIH0pO1xuICBFdmVudEhhbmRsZXIub24od2luZG93LCBFVkVOVF9MT0FEX0RBVEFfQVBJJDMsICgpID0+IHtcbiAgICBjb25zdCBjYXJvdXNlbHMgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfUklERSk7XG4gICAgZm9yIChjb25zdCBjYXJvdXNlbCBvZiBjYXJvdXNlbHMpIHtcbiAgICAgIENhcm91c2VsLmdldE9yQ3JlYXRlSW5zdGFuY2UoY2Fyb3VzZWwpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIGpRdWVyeVxuICAgKi9cblxuICBkZWZpbmVKUXVlcnlQbHVnaW4oQ2Fyb3VzZWwpO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgY29sbGFwc2UuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIENvbnN0YW50c1xuICAgKi9cblxuICBjb25zdCBOQU1FJGIgPSAnY29sbGFwc2UnO1xuICBjb25zdCBEQVRBX0tFWSQ3ID0gJ2JzLmNvbGxhcHNlJztcbiAgY29uc3QgRVZFTlRfS0VZJDcgPSBgLiR7REFUQV9LRVkkN31gO1xuICBjb25zdCBEQVRBX0FQSV9LRVkkNCA9ICcuZGF0YS1hcGknO1xuICBjb25zdCBFVkVOVF9TSE9XJDYgPSBgc2hvdyR7RVZFTlRfS0VZJDd9YDtcbiAgY29uc3QgRVZFTlRfU0hPV04kNiA9IGBzaG93biR7RVZFTlRfS0VZJDd9YDtcbiAgY29uc3QgRVZFTlRfSElERSQ2ID0gYGhpZGUke0VWRU5UX0tFWSQ3fWA7XG4gIGNvbnN0IEVWRU5UX0hJRERFTiQ2ID0gYGhpZGRlbiR7RVZFTlRfS0VZJDd9YDtcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNCA9IGBjbGljayR7RVZFTlRfS0VZJDd9JHtEQVRBX0FQSV9LRVkkNH1gO1xuICBjb25zdCBDTEFTU19OQU1FX1NIT1ckNyA9ICdzaG93JztcbiAgY29uc3QgQ0xBU1NfTkFNRV9DT0xMQVBTRSA9ICdjb2xsYXBzZSc7XG4gIGNvbnN0IENMQVNTX05BTUVfQ09MTEFQU0lORyA9ICdjb2xsYXBzaW5nJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9DT0xMQVBTRUQgPSAnY29sbGFwc2VkJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9ERUVQRVJfQ0hJTERSRU4gPSBgOnNjb3BlIC4ke0NMQVNTX05BTUVfQ09MTEFQU0V9IC4ke0NMQVNTX05BTUVfQ09MTEFQU0V9YDtcbiAgY29uc3QgQ0xBU1NfTkFNRV9IT1JJWk9OVEFMID0gJ2NvbGxhcHNlLWhvcml6b250YWwnO1xuICBjb25zdCBXSURUSCA9ICd3aWR0aCc7XG4gIGNvbnN0IEhFSUdIVCA9ICdoZWlnaHQnO1xuICBjb25zdCBTRUxFQ1RPUl9BQ1RJVkVTID0gJy5jb2xsYXBzZS5zaG93LCAuY29sbGFwc2UuY29sbGFwc2luZyc7XG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFJDQgPSAnW2RhdGEtYnMtdG9nZ2xlPVwiY29sbGFwc2VcIl0nO1xuICBjb25zdCBEZWZhdWx0JGEgPSB7XG4gICAgcGFyZW50OiBudWxsLFxuICAgIHRvZ2dsZTogdHJ1ZVxuICB9O1xuICBjb25zdCBEZWZhdWx0VHlwZSRhID0ge1xuICAgIHBhcmVudDogJyhudWxsfGVsZW1lbnQpJyxcbiAgICB0b2dnbGU6ICdib29sZWFuJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGFzcyBkZWZpbml0aW9uXG4gICAqL1xuXG4gIGNsYXNzIENvbGxhcHNlIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl90cmlnZ2VyQXJyYXkgPSBbXTtcbiAgICAgIGNvbnN0IHRvZ2dsZUxpc3QgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfVE9HR0xFJDQpO1xuICAgICAgZm9yIChjb25zdCBlbGVtIG9mIHRvZ2dsZUxpc3QpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBTZWxlY3RvckVuZ2luZS5nZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW0pO1xuICAgICAgICBjb25zdCBmaWx0ZXJFbGVtZW50ID0gU2VsZWN0b3JFbmdpbmUuZmluZChzZWxlY3RvcikuZmlsdGVyKGZvdW5kRWxlbWVudCA9PiBmb3VuZEVsZW1lbnQgPT09IHRoaXMuX2VsZW1lbnQpO1xuICAgICAgICBpZiAoc2VsZWN0b3IgIT09IG51bGwgJiYgZmlsdGVyRWxlbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLl90cmlnZ2VyQXJyYXkucHVzaChlbGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5faW5pdGlhbGl6ZUNoaWxkcmVuKCk7XG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5wYXJlbnQpIHtcbiAgICAgICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHRoaXMuX3RyaWdnZXJBcnJheSwgdGhpcy5faXNTaG93bigpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9jb25maWcudG9nZ2xlKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2V0dGVyc1xuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0JGE7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkYTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgcmV0dXJuIE5BTUUkYjtcbiAgICB9XG5cbiAgICAvLyBQdWJsaWNcbiAgICB0b2dnbGUoKSB7XG4gICAgICBpZiAodGhpcy5faXNTaG93bigpKSB7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHNob3coKSB7XG4gICAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8IHRoaXMuX2lzU2hvd24oKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgYWN0aXZlQ2hpbGRyZW4gPSBbXTtcblxuICAgICAgLy8gZmluZCBhY3RpdmUgY2hpbGRyZW5cbiAgICAgIGlmICh0aGlzLl9jb25maWcucGFyZW50KSB7XG4gICAgICAgIGFjdGl2ZUNoaWxkcmVuID0gdGhpcy5fZ2V0Rmlyc3RMZXZlbENoaWxkcmVuKFNFTEVDVE9SX0FDVElWRVMpLmZpbHRlcihlbGVtZW50ID0+IGVsZW1lbnQgIT09IHRoaXMuX2VsZW1lbnQpLm1hcChlbGVtZW50ID0+IENvbGxhcHNlLmdldE9yQ3JlYXRlSW5zdGFuY2UoZWxlbWVudCwge1xuICAgICAgICAgIHRvZ2dsZTogZmFsc2VcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgaWYgKGFjdGl2ZUNoaWxkcmVuLmxlbmd0aCAmJiBhY3RpdmVDaGlsZHJlblswXS5faXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXJ0RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XJDYpO1xuICAgICAgaWYgKHN0YXJ0RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGFjdGl2ZUluc3RhbmNlIG9mIGFjdGl2ZUNoaWxkcmVuKSB7XG4gICAgICAgIGFjdGl2ZUluc3RhbmNlLmhpZGUoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IHRoaXMuX2dldERpbWVuc2lvbigpO1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQ09MTEFQU0UpO1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQ09MTEFQU0lORyk7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSAwO1xuICAgICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHRoaXMuX3RyaWdnZXJBcnJheSwgdHJ1ZSk7XG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xuICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTSU5HKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQ09MTEFQU0UsIENMQVNTX05BTUVfU0hPVyQ3KTtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gJyc7XG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOJDYpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGNhcGl0YWxpemVkRGltZW5zaW9uID0gZGltZW5zaW9uWzBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoMSk7XG4gICAgICBjb25zdCBzY3JvbGxTaXplID0gYHNjcm9sbCR7Y2FwaXRhbGl6ZWREaW1lbnNpb259YDtcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMuX2VsZW1lbnQsIHRydWUpO1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gYCR7dGhpcy5fZWxlbWVudFtzY3JvbGxTaXplXX1weGA7XG4gICAgfVxuICAgIGhpZGUoKSB7XG4gICAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8ICF0aGlzLl9pc1Nob3duKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhcnRFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUkNik7XG4gICAgICBpZiAoc3RhcnRFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IHRoaXMuX2dldERpbWVuc2lvbigpO1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gYCR7dGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtkaW1lbnNpb25dfXB4YDtcbiAgICAgIHJlZmxvdyh0aGlzLl9lbGVtZW50KTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNJTkcpO1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQ09MTEFQU0UsIENMQVNTX05BTUVfU0hPVyQ3KTtcbiAgICAgIGZvciAoY29uc3QgdHJpZ2dlciBvZiB0aGlzLl90cmlnZ2VyQXJyYXkpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmdldEVsZW1lbnRGcm9tU2VsZWN0b3IodHJpZ2dlcik7XG4gICAgICAgIGlmIChlbGVtZW50ICYmICF0aGlzLl9pc1Nob3duKGVsZW1lbnQpKSB7XG4gICAgICAgICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKFt0cmlnZ2VyXSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xuICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTSU5HKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQ09MTEFQU0UpO1xuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURERU4kNik7XG4gICAgICB9O1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gJyc7XG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCB0aGlzLl9lbGVtZW50LCB0cnVlKTtcbiAgICB9XG4gICAgX2lzU2hvd24oZWxlbWVudCA9IHRoaXMuX2VsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1ckNyk7XG4gICAgfVxuXG4gICAgLy8gUHJpdmF0ZVxuICAgIF9jb25maWdBZnRlck1lcmdlKGNvbmZpZykge1xuICAgICAgY29uZmlnLnRvZ2dsZSA9IEJvb2xlYW4oY29uZmlnLnRvZ2dsZSk7IC8vIENvZXJjZSBzdHJpbmcgdmFsdWVzXG4gICAgICBjb25maWcucGFyZW50ID0gZ2V0RWxlbWVudChjb25maWcucGFyZW50KTtcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuICAgIF9nZXREaW1lbnNpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9IT1JJWk9OVEFMKSA/IFdJRFRIIDogSEVJR0hUO1xuICAgIH1cbiAgICBfaW5pdGlhbGl6ZUNoaWxkcmVuKCkge1xuICAgICAgaWYgKCF0aGlzLl9jb25maWcucGFyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5fZ2V0Rmlyc3RMZXZlbENoaWxkcmVuKFNFTEVDVE9SX0RBVEFfVE9HR0xFJDQpO1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGNoaWxkcmVuKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkID0gU2VsZWN0b3JFbmdpbmUuZ2V0RWxlbWVudEZyb21TZWxlY3RvcihlbGVtZW50KTtcbiAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKFtlbGVtZW50XSwgdGhpcy5faXNTaG93bihzZWxlY3RlZCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIF9nZXRGaXJzdExldmVsQ2hpbGRyZW4oc2VsZWN0b3IpIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gU2VsZWN0b3JFbmdpbmUuZmluZChDTEFTU19OQU1FX0RFRVBFUl9DSElMRFJFTiwgdGhpcy5fY29uZmlnLnBhcmVudCk7XG4gICAgICAvLyByZW1vdmUgY2hpbGRyZW4gaWYgZ3JlYXRlciBkZXB0aFxuICAgICAgcmV0dXJuIFNlbGVjdG9yRW5naW5lLmZpbmQoc2VsZWN0b3IsIHRoaXMuX2NvbmZpZy5wYXJlbnQpLmZpbHRlcihlbGVtZW50ID0+ICFjaGlsZHJlbi5pbmNsdWRlcyhlbGVtZW50KSk7XG4gICAgfVxuICAgIF9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModHJpZ2dlckFycmF5LCBpc09wZW4pIHtcbiAgICAgIGlmICghdHJpZ2dlckFycmF5Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdHJpZ2dlckFycmF5KSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShDTEFTU19OQU1FX0NPTExBUFNFRCwgIWlzT3Blbik7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgaXNPcGVuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTdGF0aWNcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgY29uc3QgX2NvbmZpZyA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnICYmIC9zaG93fGhpZGUvLnRlc3QoY29uZmlnKSkge1xuICAgICAgICBfY29uZmlnLnRvZ2dsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBDb2xsYXBzZS5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIF9jb25maWcpO1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cbiAgICovXG5cbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQ0LCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ0LCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBwcmV2ZW50RGVmYXVsdCBvbmx5IGZvciA8YT4gZWxlbWVudHMgKHdoaWNoIGNoYW5nZSB0aGUgVVJMKSBub3QgaW5zaWRlIHRoZSBjb2xsYXBzaWJsZSBlbGVtZW50XG4gICAgaWYgKGV2ZW50LnRhcmdldC50YWdOYW1lID09PSAnQScgfHwgZXZlbnQuZGVsZWdhdGVUYXJnZXQgJiYgZXZlbnQuZGVsZWdhdGVUYXJnZXQudGFnTmFtZSA9PT0gJ0EnKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgU2VsZWN0b3JFbmdpbmUuZ2V0TXVsdGlwbGVFbGVtZW50c0Zyb21TZWxlY3Rvcih0aGlzKSkge1xuICAgICAgQ29sbGFwc2UuZ2V0T3JDcmVhdGVJbnN0YW5jZShlbGVtZW50LCB7XG4gICAgICAgIHRvZ2dsZTogZmFsc2VcbiAgICAgIH0pLnRvZ2dsZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIGpRdWVyeVxuICAgKi9cblxuICBkZWZpbmVKUXVlcnlQbHVnaW4oQ29sbGFwc2UpO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgZHJvcGRvd24uanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIENvbnN0YW50c1xuICAgKi9cblxuICBjb25zdCBOQU1FJGEgPSAnZHJvcGRvd24nO1xuICBjb25zdCBEQVRBX0tFWSQ2ID0gJ2JzLmRyb3Bkb3duJztcbiAgY29uc3QgRVZFTlRfS0VZJDYgPSBgLiR7REFUQV9LRVkkNn1gO1xuICBjb25zdCBEQVRBX0FQSV9LRVkkMyA9ICcuZGF0YS1hcGknO1xuICBjb25zdCBFU0NBUEVfS0VZJDIgPSAnRXNjYXBlJztcbiAgY29uc3QgVEFCX0tFWSQxID0gJ1RhYic7XG4gIGNvbnN0IEFSUk9XX1VQX0tFWSQxID0gJ0Fycm93VXAnO1xuICBjb25zdCBBUlJPV19ET1dOX0tFWSQxID0gJ0Fycm93RG93bic7XG4gIGNvbnN0IFJJR0hUX01PVVNFX0JVVFRPTiA9IDI7IC8vIE1vdXNlRXZlbnQuYnV0dG9uIHZhbHVlIGZvciB0aGUgc2Vjb25kYXJ5IGJ1dHRvbiwgdXN1YWxseSB0aGUgcmlnaHQgYnV0dG9uXG5cbiAgY29uc3QgRVZFTlRfSElERSQ1ID0gYGhpZGUke0VWRU5UX0tFWSQ2fWA7XG4gIGNvbnN0IEVWRU5UX0hJRERFTiQ1ID0gYGhpZGRlbiR7RVZFTlRfS0VZJDZ9YDtcbiAgY29uc3QgRVZFTlRfU0hPVyQ1ID0gYHNob3cke0VWRU5UX0tFWSQ2fWA7XG4gIGNvbnN0IEVWRU5UX1NIT1dOJDUgPSBgc2hvd24ke0VWRU5UX0tFWSQ2fWA7XG4gIGNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJJDMgPSBgY2xpY2ske0VWRU5UX0tFWSQ2fSR7REFUQV9BUElfS0VZJDN9YDtcbiAgY29uc3QgRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSA9IGBrZXlkb3duJHtFVkVOVF9LRVkkNn0ke0RBVEFfQVBJX0tFWSQzfWA7XG4gIGNvbnN0IEVWRU5UX0tFWVVQX0RBVEFfQVBJID0gYGtleXVwJHtFVkVOVF9LRVkkNn0ke0RBVEFfQVBJX0tFWSQzfWA7XG4gIGNvbnN0IENMQVNTX05BTUVfU0hPVyQ2ID0gJ3Nob3cnO1xuICBjb25zdCBDTEFTU19OQU1FX0RST1BVUCA9ICdkcm9wdXAnO1xuICBjb25zdCBDTEFTU19OQU1FX0RST1BFTkQgPSAnZHJvcGVuZCc7XG4gIGNvbnN0IENMQVNTX05BTUVfRFJPUFNUQVJUID0gJ2Ryb3BzdGFydCc7XG4gIGNvbnN0IENMQVNTX05BTUVfRFJPUFVQX0NFTlRFUiA9ICdkcm9wdXAtY2VudGVyJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9EUk9QRE9XTl9DRU5URVIgPSAnZHJvcGRvd24tY2VudGVyJztcbiAgY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUkMyA9ICdbZGF0YS1icy10b2dnbGU9XCJkcm9wZG93blwiXTpub3QoLmRpc2FibGVkKTpub3QoOmRpc2FibGVkKSc7XG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFX1NIT1dOID0gYCR7U0VMRUNUT1JfREFUQV9UT0dHTEUkM30uJHtDTEFTU19OQU1FX1NIT1ckNn1gO1xuICBjb25zdCBTRUxFQ1RPUl9NRU5VID0gJy5kcm9wZG93bi1tZW51JztcbiAgY29uc3QgU0VMRUNUT1JfTkFWQkFSID0gJy5uYXZiYXInO1xuICBjb25zdCBTRUxFQ1RPUl9OQVZCQVJfTkFWID0gJy5uYXZiYXItbmF2JztcbiAgY29uc3QgU0VMRUNUT1JfVklTSUJMRV9JVEVNUyA9ICcuZHJvcGRvd24tbWVudSAuZHJvcGRvd24taXRlbTpub3QoLmRpc2FibGVkKTpub3QoOmRpc2FibGVkKSc7XG4gIGNvbnN0IFBMQUNFTUVOVF9UT1AgPSBpc1JUTCgpID8gJ3RvcC1lbmQnIDogJ3RvcC1zdGFydCc7XG4gIGNvbnN0IFBMQUNFTUVOVF9UT1BFTkQgPSBpc1JUTCgpID8gJ3RvcC1zdGFydCcgOiAndG9wLWVuZCc7XG4gIGNvbnN0IFBMQUNFTUVOVF9CT1RUT00gPSBpc1JUTCgpID8gJ2JvdHRvbS1lbmQnIDogJ2JvdHRvbS1zdGFydCc7XG4gIGNvbnN0IFBMQUNFTUVOVF9CT1RUT01FTkQgPSBpc1JUTCgpID8gJ2JvdHRvbS1zdGFydCcgOiAnYm90dG9tLWVuZCc7XG4gIGNvbnN0IFBMQUNFTUVOVF9SSUdIVCA9IGlzUlRMKCkgPyAnbGVmdC1zdGFydCcgOiAncmlnaHQtc3RhcnQnO1xuICBjb25zdCBQTEFDRU1FTlRfTEVGVCA9IGlzUlRMKCkgPyAncmlnaHQtc3RhcnQnIDogJ2xlZnQtc3RhcnQnO1xuICBjb25zdCBQTEFDRU1FTlRfVE9QQ0VOVEVSID0gJ3RvcCc7XG4gIGNvbnN0IFBMQUNFTUVOVF9CT1RUT01DRU5URVIgPSAnYm90dG9tJztcbiAgY29uc3QgRGVmYXVsdCQ5ID0ge1xuICAgIGF1dG9DbG9zZTogdHJ1ZSxcbiAgICBib3VuZGFyeTogJ2NsaXBwaW5nUGFyZW50cycsXG4gICAgZGlzcGxheTogJ2R5bmFtaWMnLFxuICAgIG9mZnNldDogWzAsIDJdLFxuICAgIHBvcHBlckNvbmZpZzogbnVsbCxcbiAgICByZWZlcmVuY2U6ICd0b2dnbGUnXG4gIH07XG4gIGNvbnN0IERlZmF1bHRUeXBlJDkgPSB7XG4gICAgYXV0b0Nsb3NlOiAnKGJvb2xlYW58c3RyaW5nKScsXG4gICAgYm91bmRhcnk6ICcoc3RyaW5nfGVsZW1lbnQpJyxcbiAgICBkaXNwbGF5OiAnc3RyaW5nJyxcbiAgICBvZmZzZXQ6ICcoYXJyYXl8c3RyaW5nfGZ1bmN0aW9uKScsXG4gICAgcG9wcGVyQ29uZmlnOiAnKG51bGx8b2JqZWN0fGZ1bmN0aW9uKScsXG4gICAgcmVmZXJlbmNlOiAnKHN0cmluZ3xlbGVtZW50fG9iamVjdCknXG4gIH07XG5cbiAgLyoqXG4gICAqIENsYXNzIGRlZmluaXRpb25cbiAgICovXG5cbiAgY2xhc3MgRHJvcGRvd24gZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZyk7XG4gICAgICB0aGlzLl9wb3BwZXIgPSBudWxsO1xuICAgICAgdGhpcy5fcGFyZW50ID0gdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlOyAvLyBkcm9wZG93biB3cmFwcGVyXG4gICAgICAvLyBUT0RPOiB2NiByZXZlcnQgIzM3MDExICYgY2hhbmdlIG1hcmt1cCBodHRwczovL2dldGJvb3RzdHJhcC5jb20vZG9jcy81LjMvZm9ybXMvaW5wdXQtZ3JvdXAvXG4gICAgICB0aGlzLl9tZW51ID0gU2VsZWN0b3JFbmdpbmUubmV4dCh0aGlzLl9lbGVtZW50LCBTRUxFQ1RPUl9NRU5VKVswXSB8fCBTZWxlY3RvckVuZ2luZS5wcmV2KHRoaXMuX2VsZW1lbnQsIFNFTEVDVE9SX01FTlUpWzBdIHx8IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfTUVOVSwgdGhpcy5fcGFyZW50KTtcbiAgICAgIHRoaXMuX2luTmF2YmFyID0gdGhpcy5fZGV0ZWN0TmF2YmFyKCk7XG4gICAgfVxuXG4gICAgLy8gR2V0dGVyc1xuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0JDk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkOTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgcmV0dXJuIE5BTUUkYTtcbiAgICB9XG5cbiAgICAvLyBQdWJsaWNcbiAgICB0b2dnbGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXNTaG93bigpID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coKTtcbiAgICB9XG4gICAgc2hvdygpIHtcbiAgICAgIGlmIChpc0Rpc2FibGVkKHRoaXMuX2VsZW1lbnQpIHx8IHRoaXMuX2lzU2hvd24oKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0ge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVyQ1LCByZWxhdGVkVGFyZ2V0KTtcbiAgICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9jcmVhdGVQb3BwZXIoKTtcblxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIGFkZCBleHRyYVxuICAgICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB0byB0aGUgYm9keSdzIGltbWVkaWF0ZSBjaGlsZHJlbjtcbiAgICAgIC8vIG9ubHkgbmVlZGVkIGJlY2F1c2Ugb2YgYnJva2VuIGV2ZW50IGRlbGVnYXRpb24gb24gaU9TXG4gICAgICAvLyBodHRwczovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTQvMDIvbW91c2VfZXZlbnRfYnViLmh0bWxcbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgIXRoaXMuX3BhcmVudC5jbG9zZXN0KFNFTEVDVE9SX05BVkJBUl9OQVYpKSB7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikpIHtcbiAgICAgICAgICBFdmVudEhhbmRsZXIub24oZWxlbWVudCwgJ21vdXNlb3ZlcicsIG5vb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9lbGVtZW50LmZvY3VzKCk7XG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRydWUpO1xuICAgICAgdGhpcy5fbWVudS5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQ2KTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckNik7XG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XTiQ1LCByZWxhdGVkVGFyZ2V0KTtcbiAgICB9XG4gICAgaGlkZSgpIHtcbiAgICAgIGlmIChpc0Rpc2FibGVkKHRoaXMuX2VsZW1lbnQpIHx8ICF0aGlzLl9pc1Nob3duKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxuICAgICAgfTtcbiAgICAgIHRoaXMuX2NvbXBsZXRlSGlkZShyZWxhdGVkVGFyZ2V0KTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcbiAgICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgdXBkYXRlKCkge1xuICAgICAgdGhpcy5faW5OYXZiYXIgPSB0aGlzLl9kZXRlY3ROYXZiYXIoKTtcbiAgICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcbiAgICAgICAgdGhpcy5fcG9wcGVyLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFByaXZhdGVcbiAgICBfY29tcGxldGVIaWRlKHJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUkNSwgcmVsYXRlZFRhcmdldCk7XG4gICAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgcmVtb3ZlIHRoZSBleHRyYVxuICAgICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB3ZSBhZGRlZCBmb3IgaU9TIHN1cHBvcnRcbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKSkge1xuICAgICAgICAgIEV2ZW50SGFuZGxlci5vZmYoZWxlbWVudCwgJ21vdXNlb3ZlcicsIG5vb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fcG9wcGVyKSB7XG4gICAgICAgIHRoaXMuX3BvcHBlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9tZW51LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDYpO1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQ2KTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG4gICAgICBNYW5pcHVsYXRvci5yZW1vdmVEYXRhQXR0cmlidXRlKHRoaXMuX21lbnUsICdwb3BwZXInKTtcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTiQ1LCByZWxhdGVkVGFyZ2V0KTtcbiAgICB9XG4gICAgX2dldENvbmZpZyhjb25maWcpIHtcbiAgICAgIGNvbmZpZyA9IHN1cGVyLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZmVyZW5jZSA9PT0gJ29iamVjdCcgJiYgIWlzRWxlbWVudChjb25maWcucmVmZXJlbmNlKSAmJiB0eXBlb2YgY29uZmlnLnJlZmVyZW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gUG9wcGVyIHZpcnR1YWwgZWxlbWVudHMgcmVxdWlyZSBhIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBtZXRob2RcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtOQU1FJGEudG9VcHBlckNhc2UoKX06IE9wdGlvbiBcInJlZmVyZW5jZVwiIHByb3ZpZGVkIHR5cGUgXCJvYmplY3RcIiB3aXRob3V0IGEgcmVxdWlyZWQgXCJnZXRCb3VuZGluZ0NsaWVudFJlY3RcIiBtZXRob2QuYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cbiAgICBfY3JlYXRlUG9wcGVyKCkge1xuICAgICAgaWYgKHR5cGVvZiBQb3BwZXJfX25hbWVzcGFjZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9vdHN0cmFwXFwncyBkcm9wZG93bnMgcmVxdWlyZSBQb3BwZXIgKGh0dHBzOi8vcG9wcGVyLmpzLm9yZyknKTtcbiAgICAgIH1cbiAgICAgIGxldCByZWZlcmVuY2VFbGVtZW50ID0gdGhpcy5fZWxlbWVudDtcbiAgICAgIGlmICh0aGlzLl9jb25maWcucmVmZXJlbmNlID09PSAncGFyZW50Jykge1xuICAgICAgICByZWZlcmVuY2VFbGVtZW50ID0gdGhpcy5fcGFyZW50O1xuICAgICAgfSBlbHNlIGlmIChpc0VsZW1lbnQodGhpcy5fY29uZmlnLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IGdldEVsZW1lbnQodGhpcy5fY29uZmlnLnJlZmVyZW5jZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9jb25maWcucmVmZXJlbmNlID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZWZlcmVuY2VFbGVtZW50ID0gdGhpcy5fY29uZmlnLnJlZmVyZW5jZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBvcHBlckNvbmZpZyA9IHRoaXMuX2dldFBvcHBlckNvbmZpZygpO1xuICAgICAgdGhpcy5fcG9wcGVyID0gUG9wcGVyX19uYW1lc3BhY2UuY3JlYXRlUG9wcGVyKHJlZmVyZW5jZUVsZW1lbnQsIHRoaXMuX21lbnUsIHBvcHBlckNvbmZpZyk7XG4gICAgfVxuICAgIF9pc1Nob3duKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21lbnUuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVyQ2KTtcbiAgICB9XG4gICAgX2dldFBsYWNlbWVudCgpIHtcbiAgICAgIGNvbnN0IHBhcmVudERyb3Bkb3duID0gdGhpcy5fcGFyZW50O1xuICAgICAgaWYgKHBhcmVudERyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BFTkQpKSB7XG4gICAgICAgIHJldHVybiBQTEFDRU1FTlRfUklHSFQ7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50RHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRFJPUFNUQVJUKSkge1xuICAgICAgICByZXR1cm4gUExBQ0VNRU5UX0xFRlQ7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50RHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRFJPUFVQX0NFTlRFUikpIHtcbiAgICAgICAgcmV0dXJuIFBMQUNFTUVOVF9UT1BDRU5URVI7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50RHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRFJPUERPV05fQ0VOVEVSKSkge1xuICAgICAgICByZXR1cm4gUExBQ0VNRU5UX0JPVFRPTUNFTlRFUjtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgbmVlZCB0byB0cmltIHRoZSB2YWx1ZSBiZWNhdXNlIGN1c3RvbSBwcm9wZXJ0aWVzIGNhbiBhbHNvIGluY2x1ZGUgc3BhY2VzXG4gICAgICBjb25zdCBpc0VuZCA9IGdldENvbXB1dGVkU3R5bGUodGhpcy5fbWVudSkuZ2V0UHJvcGVydHlWYWx1ZSgnLS1icy1wb3NpdGlvbicpLnRyaW0oKSA9PT0gJ2VuZCc7XG4gICAgICBpZiAocGFyZW50RHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRFJPUFVQKSkge1xuICAgICAgICByZXR1cm4gaXNFbmQgPyBQTEFDRU1FTlRfVE9QRU5EIDogUExBQ0VNRU5UX1RPUDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0VuZCA/IFBMQUNFTUVOVF9CT1RUT01FTkQgOiBQTEFDRU1FTlRfQk9UVE9NO1xuICAgIH1cbiAgICBfZGV0ZWN0TmF2YmFyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuY2xvc2VzdChTRUxFQ1RPUl9OQVZCQVIpICE9PSBudWxsO1xuICAgIH1cbiAgICBfZ2V0T2Zmc2V0KCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBvZmZzZXRcbiAgICAgIH0gPSB0aGlzLl9jb25maWc7XG4gICAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG9mZnNldC5zcGxpdCgnLCcpLm1hcCh2YWx1ZSA9PiBOdW1iZXIucGFyc2VJbnQodmFsdWUsIDEwKSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gcG9wcGVyRGF0YSA9PiBvZmZzZXQocG9wcGVyRGF0YSwgdGhpcy5fZWxlbWVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgICBfZ2V0UG9wcGVyQ29uZmlnKCkge1xuICAgICAgY29uc3QgZGVmYXVsdEJzUG9wcGVyQ29uZmlnID0ge1xuICAgICAgICBwbGFjZW1lbnQ6IHRoaXMuX2dldFBsYWNlbWVudCgpLFxuICAgICAgICBtb2RpZmllcnM6IFt7XG4gICAgICAgICAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgYm91bmRhcnk6IHRoaXMuX2NvbmZpZy5ib3VuZGFyeVxuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KClcbiAgICAgICAgICB9XG4gICAgICAgIH1dXG4gICAgICB9O1xuXG4gICAgICAvLyBEaXNhYmxlIFBvcHBlciBpZiB3ZSBoYXZlIGEgc3RhdGljIGRpc3BsYXkgb3IgRHJvcGRvd24gaXMgaW4gTmF2YmFyXG4gICAgICBpZiAodGhpcy5faW5OYXZiYXIgfHwgdGhpcy5fY29uZmlnLmRpc3BsYXkgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgIE1hbmlwdWxhdG9yLnNldERhdGFBdHRyaWJ1dGUodGhpcy5fbWVudSwgJ3BvcHBlcicsICdzdGF0aWMnKTsgLy8gVE9ETzogdjYgcmVtb3ZlXG4gICAgICAgIGRlZmF1bHRCc1BvcHBlckNvbmZpZy5tb2RpZmllcnMgPSBbe1xuICAgICAgICAgIG5hbWU6ICdhcHBseVN0eWxlcycsXG4gICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgfV07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5kZWZhdWx0QnNQb3BwZXJDb25maWcsXG4gICAgICAgIC4uLmV4ZWN1dGUodGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZywgW2RlZmF1bHRCc1BvcHBlckNvbmZpZ10pXG4gICAgICB9O1xuICAgIH1cbiAgICBfc2VsZWN0TWVudUl0ZW0oe1xuICAgICAga2V5LFxuICAgICAgdGFyZ2V0XG4gICAgfSkge1xuICAgICAgY29uc3QgaXRlbXMgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX1ZJU0lCTEVfSVRFTVMsIHRoaXMuX21lbnUpLmZpbHRlcihlbGVtZW50ID0+IGlzVmlzaWJsZShlbGVtZW50KSk7XG4gICAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRhcmdldCBpc24ndCBpbmNsdWRlZCBpbiBpdGVtcyAoZS5nLiB3aGVuIGV4cGFuZGluZyB0aGUgZHJvcGRvd24pXG4gICAgICAvLyBhbGxvdyBjeWNsaW5nIHRvIGdldCB0aGUgbGFzdCBpdGVtIGluIGNhc2Uga2V5IGVxdWFscyBBUlJPV19VUF9LRVlcbiAgICAgIGdldE5leHRBY3RpdmVFbGVtZW50KGl0ZW1zLCB0YXJnZXQsIGtleSA9PT0gQVJST1dfRE9XTl9LRVkkMSwgIWl0ZW1zLmluY2x1ZGVzKHRhcmdldCkpLmZvY3VzKCk7XG4gICAgfVxuXG4gICAgLy8gU3RhdGljXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gRHJvcGRvd24uZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhW2NvbmZpZ10oKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgY2xlYXJNZW51cyhldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gUklHSFRfTU9VU0VfQlVUVE9OIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcgJiYgZXZlbnQua2V5ICE9PSBUQUJfS0VZJDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3BlblRvZ2dsZXMgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfVE9HR0xFX1NIT1dOKTtcbiAgICAgIGZvciAoY29uc3QgdG9nZ2xlIG9mIG9wZW5Ub2dnbGVzKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBEcm9wZG93bi5nZXRJbnN0YW5jZSh0b2dnbGUpO1xuICAgICAgICBpZiAoIWNvbnRleHQgfHwgY29udGV4dC5fY29uZmlnLmF1dG9DbG9zZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wb3NlZFBhdGggPSBldmVudC5jb21wb3NlZFBhdGgoKTtcbiAgICAgICAgY29uc3QgaXNNZW51VGFyZ2V0ID0gY29tcG9zZWRQYXRoLmluY2x1ZGVzKGNvbnRleHQuX21lbnUpO1xuICAgICAgICBpZiAoY29tcG9zZWRQYXRoLmluY2x1ZGVzKGNvbnRleHQuX2VsZW1lbnQpIHx8IGNvbnRleHQuX2NvbmZpZy5hdXRvQ2xvc2UgPT09ICdpbnNpZGUnICYmICFpc01lbnVUYXJnZXQgfHwgY29udGV4dC5fY29uZmlnLmF1dG9DbG9zZSA9PT0gJ291dHNpZGUnICYmIGlzTWVudVRhcmdldCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGFiIG5hdmlnYXRpb24gdGhyb3VnaCB0aGUgZHJvcGRvd24gbWVudSBvciBldmVudHMgZnJvbSBjb250YWluZWQgaW5wdXRzIHNob3VsZG4ndCBjbG9zZSB0aGUgbWVudVxuICAgICAgICBpZiAoY29udGV4dC5fbWVudS5jb250YWlucyhldmVudC50YXJnZXQpICYmIChldmVudC50eXBlID09PSAna2V5dXAnICYmIGV2ZW50LmtleSA9PT0gVEFCX0tFWSQxIHx8IC9pbnB1dHxzZWxlY3R8b3B0aW9ufHRleHRhcmVhfGZvcm0vaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0ge1xuICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IGNvbnRleHQuX2VsZW1lbnRcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdjbGljaycpIHtcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0LmNsaWNrRXZlbnQgPSBldmVudDtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0Ll9jb21wbGV0ZUhpZGUocmVsYXRlZFRhcmdldCk7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBkYXRhQXBpS2V5ZG93bkhhbmRsZXIoZXZlbnQpIHtcbiAgICAgIC8vIElmIG5vdCBhbiBVUCB8IERPV04gfCBFU0NBUEUga2V5ID0+IG5vdCBhIGRyb3Bkb3duIGNvbW1hbmRcbiAgICAgIC8vIElmIGlucHV0L3RleHRhcmVhICYmIGlmIGtleSBpcyBvdGhlciB0aGFuIEVTQ0FQRSA9PiBub3QgYSBkcm9wZG93biBjb21tYW5kXG5cbiAgICAgIGNvbnN0IGlzSW5wdXQgPSAvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKTtcbiAgICAgIGNvbnN0IGlzRXNjYXBlRXZlbnQgPSBldmVudC5rZXkgPT09IEVTQ0FQRV9LRVkkMjtcbiAgICAgIGNvbnN0IGlzVXBPckRvd25FdmVudCA9IFtBUlJPV19VUF9LRVkkMSwgQVJST1dfRE9XTl9LRVkkMV0uaW5jbHVkZXMoZXZlbnQua2V5KTtcbiAgICAgIGlmICghaXNVcE9yRG93bkV2ZW50ICYmICFpc0VzY2FwZUV2ZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc0lucHV0ICYmICFpc0VzY2FwZUV2ZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIC8vIFRPRE86IHY2IHJldmVydCAjMzcwMTEgJiBjaGFuZ2UgbWFya3VwIGh0dHBzOi8vZ2V0Ym9vdHN0cmFwLmNvbS9kb2NzLzUuMy9mb3Jtcy9pbnB1dC1ncm91cC9cbiAgICAgIGNvbnN0IGdldFRvZ2dsZUJ1dHRvbiA9IHRoaXMubWF0Y2hlcyhTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzKSA/IHRoaXMgOiBTZWxlY3RvckVuZ2luZS5wcmV2KHRoaXMsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMpWzBdIHx8IFNlbGVjdG9yRW5naW5lLm5leHQodGhpcywgU0VMRUNUT1JfREFUQV9UT0dHTEUkMylbMF0gfHwgU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzLCBldmVudC5kZWxlZ2F0ZVRhcmdldC5wYXJlbnROb2RlKTtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gRHJvcGRvd24uZ2V0T3JDcmVhdGVJbnN0YW5jZShnZXRUb2dnbGVCdXR0b24pO1xuICAgICAgaWYgKGlzVXBPckRvd25FdmVudCkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgaW5zdGFuY2Uuc2hvdygpO1xuICAgICAgICBpbnN0YW5jZS5fc2VsZWN0TWVudUl0ZW0oZXZlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaW5zdGFuY2UuX2lzU2hvd24oKSkge1xuICAgICAgICAvLyBlbHNlIGlzIGVzY2FwZSBhbmQgd2UgY2hlY2sgaWYgaXQgaXMgc2hvd25cbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGluc3RhbmNlLmhpZGUoKTtcbiAgICAgICAgZ2V0VG9nZ2xlQnV0dG9uLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gICAqL1xuXG4gIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSwgU0VMRUNUT1JfREFUQV9UT0dHTEUkMywgRHJvcGRvd24uZGF0YUFwaUtleWRvd25IYW5kbGVyKTtcbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9LRVlET1dOX0RBVEFfQVBJLCBTRUxFQ1RPUl9NRU5VLCBEcm9wZG93bi5kYXRhQXBpS2V5ZG93bkhhbmRsZXIpO1xuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDMsIERyb3Bkb3duLmNsZWFyTWVudXMpO1xuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0tFWVVQX0RBVEFfQVBJLCBEcm9wZG93bi5jbGVhck1lbnVzKTtcbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQzLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIERyb3Bkb3duLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcykudG9nZ2xlKCk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBqUXVlcnlcbiAgICovXG5cbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKERyb3Bkb3duKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwIHV0aWwvYmFja2Ryb3AuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIENvbnN0YW50c1xuICAgKi9cblxuICBjb25zdCBOQU1FJDkgPSAnYmFja2Ryb3AnO1xuICBjb25zdCBDTEFTU19OQU1FX0ZBREUkNCA9ICdmYWRlJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDUgPSAnc2hvdyc7XG4gIGNvbnN0IEVWRU5UX01PVVNFRE9XTiA9IGBtb3VzZWRvd24uYnMuJHtOQU1FJDl9YDtcbiAgY29uc3QgRGVmYXVsdCQ4ID0ge1xuICAgIGNsYXNzTmFtZTogJ21vZGFsLWJhY2tkcm9wJyxcbiAgICBjbGlja0NhbGxiYWNrOiBudWxsLFxuICAgIGlzQW5pbWF0ZWQ6IGZhbHNlLFxuICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAvLyBpZiBmYWxzZSwgd2UgdXNlIHRoZSBiYWNrZHJvcCBoZWxwZXIgd2l0aG91dCBhZGRpbmcgYW55IGVsZW1lbnQgdG8gdGhlIGRvbVxuICAgIHJvb3RFbGVtZW50OiAnYm9keScgLy8gZ2l2ZSB0aGUgY2hvaWNlIHRvIHBsYWNlIGJhY2tkcm9wIHVuZGVyIGRpZmZlcmVudCBlbGVtZW50c1xuICB9O1xuXG4gIGNvbnN0IERlZmF1bHRUeXBlJDggPSB7XG4gICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICBjbGlja0NhbGxiYWNrOiAnKGZ1bmN0aW9ufG51bGwpJyxcbiAgICBpc0FuaW1hdGVkOiAnYm9vbGVhbicsXG4gICAgaXNWaXNpYmxlOiAnYm9vbGVhbicsXG4gICAgcm9vdEVsZW1lbnQ6ICcoZWxlbWVudHxzdHJpbmcpJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGFzcyBkZWZpbml0aW9uXG4gICAqL1xuXG4gIGNsYXNzIEJhY2tkcm9wIGV4dGVuZHMgQ29uZmlnIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICAgIHRoaXMuX2lzQXBwZW5kZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIEdldHRlcnNcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdCQ4O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDg7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICAgIHJldHVybiBOQU1FJDk7XG4gICAgfVxuXG4gICAgLy8gUHVibGljXG4gICAgc2hvdyhjYWxsYmFjaykge1xuICAgICAgaWYgKCF0aGlzLl9jb25maWcuaXNWaXNpYmxlKSB7XG4gICAgICAgIGV4ZWN1dGUoY2FsbGJhY2spO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9hcHBlbmQoKTtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9nZXRFbGVtZW50KCk7XG4gICAgICBpZiAodGhpcy5fY29uZmlnLmlzQW5pbWF0ZWQpIHtcbiAgICAgICAgcmVmbG93KGVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQ1KTtcbiAgICAgIHRoaXMuX2VtdWxhdGVBbmltYXRpb24oKCkgPT4ge1xuICAgICAgICBleGVjdXRlKGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBoaWRlKGNhbGxiYWNrKSB7XG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5pc1Zpc2libGUpIHtcbiAgICAgICAgZXhlY3V0ZShjYWxsYmFjayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2dldEVsZW1lbnQoKS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQ1KTtcbiAgICAgIHRoaXMuX2VtdWxhdGVBbmltYXRpb24oKCkgPT4ge1xuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgZXhlY3V0ZShjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgIGlmICghdGhpcy5faXNBcHBlbmRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFRE9XTik7XG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZSgpO1xuICAgICAgdGhpcy5faXNBcHBlbmRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFByaXZhdGVcbiAgICBfZ2V0RWxlbWVudCgpIHtcbiAgICAgIGlmICghdGhpcy5fZWxlbWVudCkge1xuICAgICAgICBjb25zdCBiYWNrZHJvcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBiYWNrZHJvcC5jbGFzc05hbWUgPSB0aGlzLl9jb25maWcuY2xhc3NOYW1lO1xuICAgICAgICBpZiAodGhpcy5fY29uZmlnLmlzQW5pbWF0ZWQpIHtcbiAgICAgICAgICBiYWNrZHJvcC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfRkFERSQ0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbGVtZW50ID0gYmFja2Ryb3A7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudDtcbiAgICB9XG4gICAgX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKSB7XG4gICAgICAvLyB1c2UgZ2V0RWxlbWVudCgpIHdpdGggdGhlIGRlZmF1bHQgXCJib2R5XCIgdG8gZ2V0IGEgZnJlc2ggRWxlbWVudCBvbiBlYWNoIGluc3RhbnRpYXRpb25cbiAgICAgIGNvbmZpZy5yb290RWxlbWVudCA9IGdldEVsZW1lbnQoY29uZmlnLnJvb3RFbGVtZW50KTtcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuICAgIF9hcHBlbmQoKSB7XG4gICAgICBpZiAodGhpcy5faXNBcHBlbmRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZ2V0RWxlbWVudCgpO1xuICAgICAgdGhpcy5fY29uZmlnLnJvb3RFbGVtZW50LmFwcGVuZChlbGVtZW50KTtcbiAgICAgIEV2ZW50SGFuZGxlci5vbihlbGVtZW50LCBFVkVOVF9NT1VTRURPV04sICgpID0+IHtcbiAgICAgICAgZXhlY3V0ZSh0aGlzLl9jb25maWcuY2xpY2tDYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2lzQXBwZW5kZWQgPSB0cnVlO1xuICAgIH1cbiAgICBfZW11bGF0ZUFuaW1hdGlvbihjYWxsYmFjaykge1xuICAgICAgZXhlY3V0ZUFmdGVyVHJhbnNpdGlvbihjYWxsYmFjaywgdGhpcy5fZ2V0RWxlbWVudCgpLCB0aGlzLl9jb25maWcuaXNBbmltYXRlZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCB1dGlsL2ZvY3VzdHJhcC5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cblxuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IE5BTUUkOCA9ICdmb2N1c3RyYXAnO1xuICBjb25zdCBEQVRBX0tFWSQ1ID0gJ2JzLmZvY3VzdHJhcCc7XG4gIGNvbnN0IEVWRU5UX0tFWSQ1ID0gYC4ke0RBVEFfS0VZJDV9YDtcbiAgY29uc3QgRVZFTlRfRk9DVVNJTiQyID0gYGZvY3VzaW4ke0VWRU5UX0tFWSQ1fWA7XG4gIGNvbnN0IEVWRU5UX0tFWURPV05fVEFCID0gYGtleWRvd24udGFiJHtFVkVOVF9LRVkkNX1gO1xuICBjb25zdCBUQUJfS0VZID0gJ1RhYic7XG4gIGNvbnN0IFRBQl9OQVZfRk9SV0FSRCA9ICdmb3J3YXJkJztcbiAgY29uc3QgVEFCX05BVl9CQUNLV0FSRCA9ICdiYWNrd2FyZCc7XG4gIGNvbnN0IERlZmF1bHQkNyA9IHtcbiAgICBhdXRvZm9jdXM6IHRydWUsXG4gICAgdHJhcEVsZW1lbnQ6IG51bGwgLy8gVGhlIGVsZW1lbnQgdG8gdHJhcCBmb2N1cyBpbnNpZGUgb2ZcbiAgfTtcblxuICBjb25zdCBEZWZhdWx0VHlwZSQ3ID0ge1xuICAgIGF1dG9mb2N1czogJ2Jvb2xlYW4nLFxuICAgIHRyYXBFbGVtZW50OiAnZWxlbWVudCdcbiAgfTtcblxuICAvKipcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxuICAgKi9cblxuICBjbGFzcyBGb2N1c1RyYXAgZXh0ZW5kcyBDb25maWcge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xuICAgICAgdGhpcy5faXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2xhc3RUYWJOYXZEaXJlY3Rpb24gPSBudWxsO1xuICAgIH1cblxuICAgIC8vIEdldHRlcnNcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdCQ3O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDc7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICAgIHJldHVybiBOQU1FJDg7XG4gICAgfVxuXG4gICAgLy8gUHVibGljXG4gICAgYWN0aXZhdGUoKSB7XG4gICAgICBpZiAodGhpcy5faXNBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5hdXRvZm9jdXMpIHtcbiAgICAgICAgdGhpcy5fY29uZmlnLnRyYXBFbGVtZW50LmZvY3VzKCk7XG4gICAgICB9XG4gICAgICBFdmVudEhhbmRsZXIub2ZmKGRvY3VtZW50LCBFVkVOVF9LRVkkNSk7IC8vIGd1YXJkIGFnYWluc3QgaW5maW5pdGUgZm9jdXMgbG9vcFxuICAgICAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9GT0NVU0lOJDIsIGV2ZW50ID0+IHRoaXMuX2hhbmRsZUZvY3VzaW4oZXZlbnQpKTtcbiAgICAgIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfS0VZRE9XTl9UQUIsIGV2ZW50ID0+IHRoaXMuX2hhbmRsZUtleWRvd24oZXZlbnQpKTtcbiAgICAgIHRoaXMuX2lzQWN0aXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgZGVhY3RpdmF0ZSgpIHtcbiAgICAgIGlmICghdGhpcy5faXNBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5faXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYoZG9jdW1lbnQsIEVWRU5UX0tFWSQ1KTtcbiAgICB9XG5cbiAgICAvLyBQcml2YXRlXG4gICAgX2hhbmRsZUZvY3VzaW4oZXZlbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHJhcEVsZW1lbnRcbiAgICAgIH0gPSB0aGlzLl9jb25maWc7XG4gICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBkb2N1bWVudCB8fCBldmVudC50YXJnZXQgPT09IHRyYXBFbGVtZW50IHx8IHRyYXBFbGVtZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZWxlbWVudHMgPSBTZWxlY3RvckVuZ2luZS5mb2N1c2FibGVDaGlsZHJlbih0cmFwRWxlbWVudCk7XG4gICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRyYXBFbGVtZW50LmZvY3VzKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2xhc3RUYWJOYXZEaXJlY3Rpb24gPT09IFRBQl9OQVZfQkFDS1dBUkQpIHtcbiAgICAgICAgZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV0uZm9jdXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnRzWzBdLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfVxuICAgIF9oYW5kbGVLZXlkb3duKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQua2V5ICE9PSBUQUJfS0VZKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xhc3RUYWJOYXZEaXJlY3Rpb24gPSBldmVudC5zaGlmdEtleSA/IFRBQl9OQVZfQkFDS1dBUkQgOiBUQUJfTkFWX0ZPUldBUkQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCB1dGlsL3Njcm9sbEJhci5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cblxuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IFNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQgPSAnLmZpeGVkLXRvcCwgLmZpeGVkLWJvdHRvbSwgLmlzLWZpeGVkLCAuc3RpY2t5LXRvcCc7XG4gIGNvbnN0IFNFTEVDVE9SX1NUSUNLWV9DT05URU5UID0gJy5zdGlja3ktdG9wJztcbiAgY29uc3QgUFJPUEVSVFlfUEFERElORyA9ICdwYWRkaW5nLXJpZ2h0JztcbiAgY29uc3QgUFJPUEVSVFlfTUFSR0lOID0gJ21hcmdpbi1yaWdodCc7XG5cbiAgLyoqXG4gICAqIENsYXNzIGRlZmluaXRpb25cbiAgICovXG5cbiAgY2xhc3MgU2Nyb2xsQmFySGVscGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBkb2N1bWVudC5ib2R5O1xuICAgIH1cblxuICAgIC8vIFB1YmxpY1xuICAgIGdldFdpZHRoKCkge1xuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy9pbm5lcldpZHRoI3VzYWdlX25vdGVzXG4gICAgICBjb25zdCBkb2N1bWVudFdpZHRoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgICAgcmV0dXJuIE1hdGguYWJzKHdpbmRvdy5pbm5lcldpZHRoIC0gZG9jdW1lbnRXaWR0aCk7XG4gICAgfVxuICAgIGhpZGUoKSB7XG4gICAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgIHRoaXMuX2Rpc2FibGVPdmVyRmxvdygpO1xuICAgICAgLy8gZ2l2ZSBwYWRkaW5nIHRvIGVsZW1lbnQgdG8gYmFsYW5jZSB0aGUgaGlkZGVuIHNjcm9sbGJhciB3aWR0aFxuICAgICAgdGhpcy5fc2V0RWxlbWVudEF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCwgUFJPUEVSVFlfUEFERElORywgY2FsY3VsYXRlZFZhbHVlID0+IGNhbGN1bGF0ZWRWYWx1ZSArIHdpZHRoKTtcbiAgICAgIC8vIHRyaWNrOiBXZSBhZGp1c3QgcG9zaXRpdmUgcGFkZGluZ1JpZ2h0IGFuZCBuZWdhdGl2ZSBtYXJnaW5SaWdodCB0byBzdGlja3ktdG9wIGVsZW1lbnRzIHRvIGtlZXAgc2hvd2luZyBmdWxsd2lkdGhcbiAgICAgIHRoaXMuX3NldEVsZW1lbnRBdHRyaWJ1dGVzKFNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQsIFBST1BFUlRZX1BBRERJTkcsIGNhbGN1bGF0ZWRWYWx1ZSA9PiBjYWxjdWxhdGVkVmFsdWUgKyB3aWR0aCk7XG4gICAgICB0aGlzLl9zZXRFbGVtZW50QXR0cmlidXRlcyhTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCwgUFJPUEVSVFlfTUFSR0lOLCBjYWxjdWxhdGVkVmFsdWUgPT4gY2FsY3VsYXRlZFZhbHVlIC0gd2lkdGgpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCwgJ292ZXJmbG93Jyk7XG4gICAgICB0aGlzLl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQsIFBST1BFUlRZX1BBRERJTkcpO1xuICAgICAgdGhpcy5fcmVzZXRFbGVtZW50QXR0cmlidXRlcyhTRUxFQ1RPUl9GSVhFRF9DT05URU5ULCBQUk9QRVJUWV9QQURESU5HKTtcbiAgICAgIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXMoU0VMRUNUT1JfU1RJQ0tZX0NPTlRFTlQsIFBST1BFUlRZX01BUkdJTik7XG4gICAgfVxuICAgIGlzT3ZlcmZsb3dpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRXaWR0aCgpID4gMDtcbiAgICB9XG5cbiAgICAvLyBQcml2YXRlXG4gICAgX2Rpc2FibGVPdmVyRmxvdygpIHtcbiAgICAgIHRoaXMuX3NhdmVJbml0aWFsQXR0cmlidXRlKHRoaXMuX2VsZW1lbnQsICdvdmVyZmxvdycpO1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgIH1cbiAgICBfc2V0RWxlbWVudEF0dHJpYnV0ZXMoc2VsZWN0b3IsIHN0eWxlUHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgIGNvbnN0IG1hbmlwdWxhdGlvbkNhbGxCYWNrID0gZWxlbWVudCA9PiB7XG4gICAgICAgIGlmIChlbGVtZW50ICE9PSB0aGlzLl9lbGVtZW50ICYmIHdpbmRvdy5pbm5lcldpZHRoID4gZWxlbWVudC5jbGllbnRXaWR0aCArIHNjcm9sbGJhcldpZHRoKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NhdmVJbml0aWFsQXR0cmlidXRlKGVsZW1lbnQsIHN0eWxlUHJvcGVydHkpO1xuICAgICAgICBjb25zdCBjYWxjdWxhdGVkVmFsdWUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKHN0eWxlUHJvcGVydHkpO1xuICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KHN0eWxlUHJvcGVydHksIGAke2NhbGxiYWNrKE51bWJlci5wYXJzZUZsb2F0KGNhbGN1bGF0ZWRWYWx1ZSkpfXB4YCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5fYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayhzZWxlY3RvciwgbWFuaXB1bGF0aW9uQ2FsbEJhY2spO1xuICAgIH1cbiAgICBfc2F2ZUluaXRpYWxBdHRyaWJ1dGUoZWxlbWVudCwgc3R5bGVQcm9wZXJ0eSkge1xuICAgICAgY29uc3QgYWN0dWFsVmFsdWUgPSBlbGVtZW50LnN0eWxlLmdldFByb3BlcnR5VmFsdWUoc3R5bGVQcm9wZXJ0eSk7XG4gICAgICBpZiAoYWN0dWFsVmFsdWUpIHtcbiAgICAgICAgTWFuaXB1bGF0b3Iuc2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZVByb3BlcnR5LCBhY3R1YWxWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKHNlbGVjdG9yLCBzdHlsZVByb3BlcnR5KSB7XG4gICAgICBjb25zdCBtYW5pcHVsYXRpb25DYWxsQmFjayA9IGVsZW1lbnQgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IE1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGUoZWxlbWVudCwgc3R5bGVQcm9wZXJ0eSk7XG4gICAgICAgIC8vIFdlIG9ubHkgd2FudCB0byByZW1vdmUgdGhlIHByb3BlcnR5IGlmIHRoZSB2YWx1ZSBpcyBgbnVsbGA7IHRoZSB2YWx1ZSBjYW4gYWxzbyBiZSB6ZXJvXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkoc3R5bGVQcm9wZXJ0eSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIE1hbmlwdWxhdG9yLnJlbW92ZURhdGFBdHRyaWJ1dGUoZWxlbWVudCwgc3R5bGVQcm9wZXJ0eSk7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoc3R5bGVQcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuX2FwcGx5TWFuaXB1bGF0aW9uQ2FsbGJhY2soc2VsZWN0b3IsIG1hbmlwdWxhdGlvbkNhbGxCYWNrKTtcbiAgICB9XG4gICAgX2FwcGx5TWFuaXB1bGF0aW9uQ2FsbGJhY2soc2VsZWN0b3IsIGNhbGxCYWNrKSB7XG4gICAgICBpZiAoaXNFbGVtZW50KHNlbGVjdG9yKSkge1xuICAgICAgICBjYWxsQmFjayhzZWxlY3Rvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qgc2VsIG9mIFNlbGVjdG9yRW5naW5lLmZpbmQoc2VsZWN0b3IsIHRoaXMuX2VsZW1lbnQpKSB7XG4gICAgICAgIGNhbGxCYWNrKHNlbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCBtb2RhbC5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cblxuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IE5BTUUkNyA9ICdtb2RhbCc7XG4gIGNvbnN0IERBVEFfS0VZJDQgPSAnYnMubW9kYWwnO1xuICBjb25zdCBFVkVOVF9LRVkkNCA9IGAuJHtEQVRBX0tFWSQ0fWA7XG4gIGNvbnN0IERBVEFfQVBJX0tFWSQyID0gJy5kYXRhLWFwaSc7XG4gIGNvbnN0IEVTQ0FQRV9LRVkkMSA9ICdFc2NhcGUnO1xuICBjb25zdCBFVkVOVF9ISURFJDQgPSBgaGlkZSR7RVZFTlRfS0VZJDR9YDtcbiAgY29uc3QgRVZFTlRfSElERV9QUkVWRU5URUQkMSA9IGBoaWRlUHJldmVudGVkJHtFVkVOVF9LRVkkNH1gO1xuICBjb25zdCBFVkVOVF9ISURERU4kNCA9IGBoaWRkZW4ke0VWRU5UX0tFWSQ0fWA7XG4gIGNvbnN0IEVWRU5UX1NIT1ckNCA9IGBzaG93JHtFVkVOVF9LRVkkNH1gO1xuICBjb25zdCBFVkVOVF9TSE9XTiQ0ID0gYHNob3duJHtFVkVOVF9LRVkkNH1gO1xuICBjb25zdCBFVkVOVF9SRVNJWkUkMSA9IGByZXNpemUke0VWRU5UX0tFWSQ0fWA7XG4gIGNvbnN0IEVWRU5UX0NMSUNLX0RJU01JU1MgPSBgY2xpY2suZGlzbWlzcyR7RVZFTlRfS0VZJDR9YDtcbiAgY29uc3QgRVZFTlRfTU9VU0VET1dOX0RJU01JU1MgPSBgbW91c2Vkb3duLmRpc21pc3Mke0VWRU5UX0tFWSQ0fWA7XG4gIGNvbnN0IEVWRU5UX0tFWURPV05fRElTTUlTUyQxID0gYGtleWRvd24uZGlzbWlzcyR7RVZFTlRfS0VZJDR9YDtcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMiA9IGBjbGljayR7RVZFTlRfS0VZJDR9JHtEQVRBX0FQSV9LRVkkMn1gO1xuICBjb25zdCBDTEFTU19OQU1FX09QRU4gPSAnbW9kYWwtb3Blbic7XG4gIGNvbnN0IENMQVNTX05BTUVfRkFERSQzID0gJ2ZhZGUnO1xuICBjb25zdCBDTEFTU19OQU1FX1NIT1ckNCA9ICdzaG93JztcbiAgY29uc3QgQ0xBU1NfTkFNRV9TVEFUSUMgPSAnbW9kYWwtc3RhdGljJztcbiAgY29uc3QgT1BFTl9TRUxFQ1RPUiQxID0gJy5tb2RhbC5zaG93JztcbiAgY29uc3QgU0VMRUNUT1JfRElBTE9HID0gJy5tb2RhbC1kaWFsb2cnO1xuICBjb25zdCBTRUxFQ1RPUl9NT0RBTF9CT0RZID0gJy5tb2RhbC1ib2R5JztcbiAgY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUkMiA9ICdbZGF0YS1icy10b2dnbGU9XCJtb2RhbFwiXSc7XG4gIGNvbnN0IERlZmF1bHQkNiA9IHtcbiAgICBiYWNrZHJvcDogdHJ1ZSxcbiAgICBmb2N1czogdHJ1ZSxcbiAgICBrZXlib2FyZDogdHJ1ZVxuICB9O1xuICBjb25zdCBEZWZhdWx0VHlwZSQ2ID0ge1xuICAgIGJhY2tkcm9wOiAnKGJvb2xlYW58c3RyaW5nKScsXG4gICAgZm9jdXM6ICdib29sZWFuJyxcbiAgICBrZXlib2FyZDogJ2Jvb2xlYW4nXG4gIH07XG5cbiAgLyoqXG4gICAqIENsYXNzIGRlZmluaXRpb25cbiAgICovXG5cbiAgY2xhc3MgTW9kYWwgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZyk7XG4gICAgICB0aGlzLl9kaWFsb2cgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0RJQUxPRywgdGhpcy5fZWxlbWVudCk7XG4gICAgICB0aGlzLl9iYWNrZHJvcCA9IHRoaXMuX2luaXRpYWxpemVCYWNrRHJvcCgpO1xuICAgICAgdGhpcy5fZm9jdXN0cmFwID0gdGhpcy5faW5pdGlhbGl6ZUZvY3VzVHJhcCgpO1xuICAgICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9zY3JvbGxCYXIgPSBuZXcgU2Nyb2xsQmFySGVscGVyKCk7XG4gICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIC8vIEdldHRlcnNcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdCQ2O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDY7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICAgIHJldHVybiBOQU1FJDc7XG4gICAgfVxuXG4gICAgLy8gUHVibGljXG4gICAgdG9nZ2xlKHJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc1Nob3duID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3cocmVsYXRlZFRhcmdldCk7XG4gICAgfVxuICAgIHNob3cocmVsYXRlZFRhcmdldCkge1xuICAgICAgaWYgKHRoaXMuX2lzU2hvd24gfHwgdGhpcy5faXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1ckNCwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0XG4gICAgICB9KTtcbiAgICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9pc1Nob3duID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWU7XG4gICAgICB0aGlzLl9zY3JvbGxCYXIuaGlkZSgpO1xuICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfT1BFTik7XG4gICAgICB0aGlzLl9hZGp1c3REaWFsb2coKTtcbiAgICAgIHRoaXMuX2JhY2tkcm9wLnNob3coKCkgPT4gdGhpcy5fc2hvd0VsZW1lbnQocmVsYXRlZFRhcmdldCkpO1xuICAgIH1cbiAgICBoaWRlKCkge1xuICAgICAgaWYgKCF0aGlzLl9pc1Nob3duIHx8IHRoaXMuX2lzVHJhbnNpdGlvbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFJDQpO1xuICAgICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWU7XG4gICAgICB0aGlzLl9mb2N1c3RyYXAuZGVhY3RpdmF0ZSgpO1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQ0KTtcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soKCkgPT4gdGhpcy5faGlkZU1vZGFsKCksIHRoaXMuX2VsZW1lbnQsIHRoaXMuX2lzQW5pbWF0ZWQoKSk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICBFdmVudEhhbmRsZXIub2ZmKHdpbmRvdywgRVZFTlRfS0VZJDQpO1xuICAgICAgRXZlbnRIYW5kbGVyLm9mZih0aGlzLl9kaWFsb2csIEVWRU5UX0tFWSQ0KTtcbiAgICAgIHRoaXMuX2JhY2tkcm9wLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX2ZvY3VzdHJhcC5kZWFjdGl2YXRlKCk7XG4gICAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGhhbmRsZVVwZGF0ZSgpIHtcbiAgICAgIHRoaXMuX2FkanVzdERpYWxvZygpO1xuICAgIH1cblxuICAgIC8vIFByaXZhdGVcbiAgICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xuICAgICAgcmV0dXJuIG5ldyBCYWNrZHJvcCh7XG4gICAgICAgIGlzVmlzaWJsZTogQm9vbGVhbih0aGlzLl9jb25maWcuYmFja2Ryb3ApLFxuICAgICAgICAvLyAnc3RhdGljJyBvcHRpb24gd2lsbCBiZSB0cmFuc2xhdGVkIHRvIHRydWUsIGFuZCBib29sZWFucyB3aWxsIGtlZXAgdGhlaXIgdmFsdWUsXG4gICAgICAgIGlzQW5pbWF0ZWQ6IHRoaXMuX2lzQW5pbWF0ZWQoKVxuICAgICAgfSk7XG4gICAgfVxuICAgIF9pbml0aWFsaXplRm9jdXNUcmFwKCkge1xuICAgICAgcmV0dXJuIG5ldyBGb2N1c1RyYXAoe1xuICAgICAgICB0cmFwRWxlbWVudDogdGhpcy5fZWxlbWVudFxuICAgICAgfSk7XG4gICAgfVxuICAgIF9zaG93RWxlbWVudChyZWxhdGVkVGFyZ2V0KSB7XG4gICAgICAvLyB0cnkgdG8gYXBwZW5kIGR5bmFtaWMgbW9kYWxcbiAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyh0aGlzLl9lbGVtZW50KSkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZCh0aGlzLl9lbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLW1vZGFsJywgdHJ1ZSk7XG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdkaWFsb2cnKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2Nyb2xsVG9wID0gMDtcbiAgICAgIGNvbnN0IG1vZGFsQm9keSA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfTU9EQUxfQk9EWSwgdGhpcy5fZGlhbG9nKTtcbiAgICAgIGlmIChtb2RhbEJvZHkpIHtcbiAgICAgICAgbW9kYWxCb2R5LnNjcm9sbFRvcCA9IDA7XG4gICAgICB9XG4gICAgICByZWZsb3codGhpcy5fZWxlbWVudCk7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDQpO1xuICAgICAgY29uc3QgdHJhbnNpdGlvbkNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fY29uZmlnLmZvY3VzKSB7XG4gICAgICAgICAgdGhpcy5fZm9jdXN0cmFwLmFjdGl2YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOJDQsIHtcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2sodHJhbnNpdGlvbkNvbXBsZXRlLCB0aGlzLl9kaWFsb2csIHRoaXMuX2lzQW5pbWF0ZWQoKSk7XG4gICAgfVxuICAgIF9hZGRFdmVudExpc3RlbmVycygpIHtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVlET1dOX0RJU01JU1MkMSwgZXZlbnQgPT4ge1xuICAgICAgICBpZiAoZXZlbnQua2V5ICE9PSBFU0NBUEVfS0VZJDEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5rZXlib2FyZCkge1xuICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCk7XG4gICAgICB9KTtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX1JFU0laRSQxLCAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9pc1Nob3duICYmICF0aGlzLl9pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgICAgICB0aGlzLl9hZGp1c3REaWFsb2coKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VET1dOX0RJU01JU1MsIGV2ZW50ID0+IHtcbiAgICAgICAgLy8gYSBiYWQgdHJpY2sgdG8gc2VncmVnYXRlIGNsaWNrcyB0aGF0IG1heSBzdGFydCBpbnNpZGUgZGlhbG9nIGJ1dCBlbmQgb3V0c2lkZSwgYW5kIGF2b2lkIGxpc3RlbiB0byBzY3JvbGxiYXIgY2xpY2tzXG4gICAgICAgIEV2ZW50SGFuZGxlci5vbmUodGhpcy5fZWxlbWVudCwgRVZFTlRfQ0xJQ0tfRElTTUlTUywgZXZlbnQyID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudCAhPT0gZXZlbnQudGFyZ2V0IHx8IHRoaXMuX2VsZW1lbnQgIT09IGV2ZW50Mi50YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5iYWNrZHJvcCA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5iYWNrZHJvcCkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBfaGlkZU1vZGFsKCkge1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgdHJ1ZSk7XG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcpO1xuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3JvbGUnKTtcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5fYmFja2Ryb3AuaGlkZSgoKSA9PiB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX09QRU4pO1xuICAgICAgICB0aGlzLl9yZXNldEFkanVzdG1lbnRzKCk7XG4gICAgICAgIHRoaXMuX3Njcm9sbEJhci5yZXNldCgpO1xuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURERU4kNCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgX2lzQW5pbWF0ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFJDMpO1xuICAgIH1cbiAgICBfdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpIHtcbiAgICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREVfUFJFVkVOVEVEJDEpO1xuICAgICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzTW9kYWxPdmVyZmxvd2luZyA9IHRoaXMuX2VsZW1lbnQuc2Nyb2xsSGVpZ2h0ID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICAgIGNvbnN0IGluaXRpYWxPdmVyZmxvd1kgPSB0aGlzLl9lbGVtZW50LnN0eWxlLm92ZXJmbG93WTtcbiAgICAgIC8vIHJldHVybiBpZiB0aGUgZm9sbG93aW5nIGJhY2tncm91bmQgdHJhbnNpdGlvbiBoYXNuJ3QgeWV0IGNvbXBsZXRlZFxuICAgICAgaWYgKGluaXRpYWxPdmVyZmxvd1kgPT09ICdoaWRkZW4nIHx8IHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU1RBVElDKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWlzTW9kYWxPdmVyZmxvd2luZykge1xuICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLm92ZXJmbG93WSA9ICdoaWRkZW4nO1xuICAgICAgfVxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU1RBVElDKTtcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TVEFUSUMpO1xuICAgICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLm92ZXJmbG93WSA9IGluaXRpYWxPdmVyZmxvd1k7XG4gICAgICAgIH0sIHRoaXMuX2RpYWxvZyk7XG4gICAgICB9LCB0aGlzLl9kaWFsb2cpO1xuICAgICAgdGhpcy5fZWxlbWVudC5mb2N1cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBmb2xsb3dpbmcgbWV0aG9kcyBhcmUgdXNlZCB0byBoYW5kbGUgb3ZlcmZsb3dpbmcgbW9kYWxzXG4gICAgICovXG5cbiAgICBfYWRqdXN0RGlhbG9nKCkge1xuICAgICAgY29uc3QgaXNNb2RhbE92ZXJmbG93aW5nID0gdGhpcy5fZWxlbWVudC5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgY29uc3Qgc2Nyb2xsYmFyV2lkdGggPSB0aGlzLl9zY3JvbGxCYXIuZ2V0V2lkdGgoKTtcbiAgICAgIGNvbnN0IGlzQm9keU92ZXJmbG93aW5nID0gc2Nyb2xsYmFyV2lkdGggPiAwO1xuICAgICAgaWYgKGlzQm9keU92ZXJmbG93aW5nICYmICFpc01vZGFsT3ZlcmZsb3dpbmcpIHtcbiAgICAgICAgY29uc3QgcHJvcGVydHkgPSBpc1JUTCgpID8gJ3BhZGRpbmdMZWZ0JyA6ICdwYWRkaW5nUmlnaHQnO1xuICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW3Byb3BlcnR5XSA9IGAke3Njcm9sbGJhcldpZHRofXB4YDtcbiAgICAgIH1cbiAgICAgIGlmICghaXNCb2R5T3ZlcmZsb3dpbmcgJiYgaXNNb2RhbE92ZXJmbG93aW5nKSB7XG4gICAgICAgIGNvbnN0IHByb3BlcnR5ID0gaXNSVEwoKSA/ICdwYWRkaW5nUmlnaHQnIDogJ3BhZGRpbmdMZWZ0JztcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtwcm9wZXJ0eV0gPSBgJHtzY3JvbGxiYXJXaWR0aH1weGA7XG4gICAgICB9XG4gICAgfVxuICAgIF9yZXNldEFkanVzdG1lbnRzKCkge1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nTGVmdCA9ICcnO1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSAnJztcbiAgICB9XG5cbiAgICAvLyBTdGF0aWNcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZywgcmVsYXRlZFRhcmdldCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBNb2RhbC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbY29uZmlnXShyZWxhdGVkVGFyZ2V0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICAgKi9cblxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDIsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGNvbnN0IHRhcmdldCA9IFNlbGVjdG9yRW5naW5lLmdldEVsZW1lbnRGcm9tU2VsZWN0b3IodGhpcyk7XG4gICAgaWYgKFsnQScsICdBUkVBJ10uaW5jbHVkZXModGhpcy50YWdOYW1lKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgRXZlbnRIYW5kbGVyLm9uZSh0YXJnZXQsIEVWRU5UX1NIT1ckNCwgc2hvd0V2ZW50ID0+IHtcbiAgICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAvLyBvbmx5IHJlZ2lzdGVyIGZvY3VzIHJlc3RvcmVyIGlmIG1vZGFsIHdpbGwgYWN0dWFsbHkgZ2V0IHNob3duXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIEV2ZW50SGFuZGxlci5vbmUodGFyZ2V0LCBFVkVOVF9ISURERU4kNCwgKCkgPT4ge1xuICAgICAgICBpZiAoaXNWaXNpYmxlKHRoaXMpKSB7XG4gICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIGF2b2lkIGNvbmZsaWN0IHdoZW4gY2xpY2tpbmcgbW9kYWwgdG9nZ2xlciB3aGlsZSBhbm90aGVyIG9uZSBpcyBvcGVuXG4gICAgY29uc3QgYWxyZWFkeU9wZW4gPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKE9QRU5fU0VMRUNUT1IkMSk7XG4gICAgaWYgKGFscmVhZHlPcGVuKSB7XG4gICAgICBNb2RhbC5nZXRJbnN0YW5jZShhbHJlYWR5T3BlbikuaGlkZSgpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gTW9kYWwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0YXJnZXQpO1xuICAgIGRhdGEudG9nZ2xlKHRoaXMpO1xuICB9KTtcbiAgZW5hYmxlRGlzbWlzc1RyaWdnZXIoTW9kYWwpO1xuXG4gIC8qKlxuICAgKiBqUXVlcnlcbiAgICovXG5cbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKE1vZGFsKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwIG9mZmNhbnZhcy5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cblxuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IE5BTUUkNiA9ICdvZmZjYW52YXMnO1xuICBjb25zdCBEQVRBX0tFWSQzID0gJ2JzLm9mZmNhbnZhcyc7XG4gIGNvbnN0IEVWRU5UX0tFWSQzID0gYC4ke0RBVEFfS0VZJDN9YDtcbiAgY29uc3QgREFUQV9BUElfS0VZJDEgPSAnLmRhdGEtYXBpJztcbiAgY29uc3QgRVZFTlRfTE9BRF9EQVRBX0FQSSQyID0gYGxvYWQke0VWRU5UX0tFWSQzfSR7REFUQV9BUElfS0VZJDF9YDtcbiAgY29uc3QgRVNDQVBFX0tFWSA9ICdFc2NhcGUnO1xuICBjb25zdCBDTEFTU19OQU1FX1NIT1ckMyA9ICdzaG93JztcbiAgY29uc3QgQ0xBU1NfTkFNRV9TSE9XSU5HJDEgPSAnc2hvd2luZyc7XG4gIGNvbnN0IENMQVNTX05BTUVfSElESU5HID0gJ2hpZGluZyc7XG4gIGNvbnN0IENMQVNTX05BTUVfQkFDS0RST1AgPSAnb2ZmY2FudmFzLWJhY2tkcm9wJztcbiAgY29uc3QgT1BFTl9TRUxFQ1RPUiA9ICcub2ZmY2FudmFzLnNob3cnO1xuICBjb25zdCBFVkVOVF9TSE9XJDMgPSBgc2hvdyR7RVZFTlRfS0VZJDN9YDtcbiAgY29uc3QgRVZFTlRfU0hPV04kMyA9IGBzaG93biR7RVZFTlRfS0VZJDN9YDtcbiAgY29uc3QgRVZFTlRfSElERSQzID0gYGhpZGUke0VWRU5UX0tFWSQzfWA7XG4gIGNvbnN0IEVWRU5UX0hJREVfUFJFVkVOVEVEID0gYGhpZGVQcmV2ZW50ZWQke0VWRU5UX0tFWSQzfWA7XG4gIGNvbnN0IEVWRU5UX0hJRERFTiQzID0gYGhpZGRlbiR7RVZFTlRfS0VZJDN9YDtcbiAgY29uc3QgRVZFTlRfUkVTSVpFID0gYHJlc2l6ZSR7RVZFTlRfS0VZJDN9YDtcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMSA9IGBjbGljayR7RVZFTlRfS0VZJDN9JHtEQVRBX0FQSV9LRVkkMX1gO1xuICBjb25zdCBFVkVOVF9LRVlET1dOX0RJU01JU1MgPSBga2V5ZG93bi5kaXNtaXNzJHtFVkVOVF9LRVkkM31gO1xuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQxID0gJ1tkYXRhLWJzLXRvZ2dsZT1cIm9mZmNhbnZhc1wiXSc7XG4gIGNvbnN0IERlZmF1bHQkNSA9IHtcbiAgICBiYWNrZHJvcDogdHJ1ZSxcbiAgICBrZXlib2FyZDogdHJ1ZSxcbiAgICBzY3JvbGw6IGZhbHNlXG4gIH07XG4gIGNvbnN0IERlZmF1bHRUeXBlJDUgPSB7XG4gICAgYmFja2Ryb3A6ICcoYm9vbGVhbnxzdHJpbmcpJyxcbiAgICBrZXlib2FyZDogJ2Jvb2xlYW4nLFxuICAgIHNjcm9sbDogJ2Jvb2xlYW4nXG4gIH07XG5cbiAgLyoqXG4gICAqIENsYXNzIGRlZmluaXRpb25cbiAgICovXG5cbiAgY2xhc3MgT2ZmY2FudmFzIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xuICAgICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xuICAgICAgdGhpcy5fYmFja2Ryb3AgPSB0aGlzLl9pbml0aWFsaXplQmFja0Ryb3AoKTtcbiAgICAgIHRoaXMuX2ZvY3VzdHJhcCA9IHRoaXMuX2luaXRpYWxpemVGb2N1c1RyYXAoKTtcbiAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgLy8gR2V0dGVyc1xuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0JDU7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkNTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgcmV0dXJuIE5BTUUkNjtcbiAgICB9XG5cbiAgICAvLyBQdWJsaWNcbiAgICB0b2dnbGUocmVsYXRlZFRhcmdldCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzU2hvd24gPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdyhyZWxhdGVkVGFyZ2V0KTtcbiAgICB9XG4gICAgc2hvdyhyZWxhdGVkVGFyZ2V0KSB7XG4gICAgICBpZiAodGhpcy5faXNTaG93bikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XJDMsIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldFxuICAgICAgfSk7XG4gICAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5faXNTaG93biA9IHRydWU7XG4gICAgICB0aGlzLl9iYWNrZHJvcC5zaG93KCk7XG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5zY3JvbGwpIHtcbiAgICAgICAgbmV3IFNjcm9sbEJhckhlbHBlcigpLmhpZGUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLW1vZGFsJywgdHJ1ZSk7XG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdkaWFsb2cnKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1dJTkckMSk7XG4gICAgICBjb25zdCBjb21wbGV0ZUNhbGxCYWNrID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuX2NvbmZpZy5zY3JvbGwgfHwgdGhpcy5fY29uZmlnLmJhY2tkcm9wKSB7XG4gICAgICAgICAgdGhpcy5fZm9jdXN0cmFwLmFjdGl2YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQzKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPV0lORyQxKTtcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPV04kMywge1xuICAgICAgICAgIHJlbGF0ZWRUYXJnZXRcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZUNhbGxCYWNrLCB0aGlzLl9lbGVtZW50LCB0cnVlKTtcbiAgICB9XG4gICAgaGlkZSgpIHtcbiAgICAgIGlmICghdGhpcy5faXNTaG93bikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFJDMpO1xuICAgICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZvY3VzdHJhcC5kZWFjdGl2YXRlKCk7XG4gICAgICB0aGlzLl9lbGVtZW50LmJsdXIoKTtcbiAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0hJRElORyk7XG4gICAgICB0aGlzLl9iYWNrZHJvcC5oaWRlKCk7XG4gICAgICBjb25zdCBjb21wbGV0ZUNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDMsIENMQVNTX05BTUVfSElESU5HKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3JvbGUnKTtcbiAgICAgICAgaWYgKCF0aGlzLl9jb25maWcuc2Nyb2xsKSB7XG4gICAgICAgICAgbmV3IFNjcm9sbEJhckhlbHBlcigpLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOJDMpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGVDYWxsYmFjaywgdGhpcy5fZWxlbWVudCwgdHJ1ZSk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICB0aGlzLl9iYWNrZHJvcC5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9mb2N1c3RyYXAuZGVhY3RpdmF0ZSgpO1xuICAgICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIC8vIFByaXZhdGVcbiAgICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xuICAgICAgY29uc3QgY2xpY2tDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5iYWNrZHJvcCA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFX1BSRVZFTlRFRCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgfTtcblxuICAgICAgLy8gJ3N0YXRpYycgb3B0aW9uIHdpbGwgYmUgdHJhbnNsYXRlZCB0byB0cnVlLCBhbmQgYm9vbGVhbnMgd2lsbCBrZWVwIHRoZWlyIHZhbHVlXG4gICAgICBjb25zdCBpc1Zpc2libGUgPSBCb29sZWFuKHRoaXMuX2NvbmZpZy5iYWNrZHJvcCk7XG4gICAgICByZXR1cm4gbmV3IEJhY2tkcm9wKHtcbiAgICAgICAgY2xhc3NOYW1lOiBDTEFTU19OQU1FX0JBQ0tEUk9QLFxuICAgICAgICBpc1Zpc2libGUsXG4gICAgICAgIGlzQW5pbWF0ZWQ6IHRydWUsXG4gICAgICAgIHJvb3RFbGVtZW50OiB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUsXG4gICAgICAgIGNsaWNrQ2FsbGJhY2s6IGlzVmlzaWJsZSA/IGNsaWNrQ2FsbGJhY2sgOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gICAgX2luaXRpYWxpemVGb2N1c1RyYXAoKSB7XG4gICAgICByZXR1cm4gbmV3IEZvY3VzVHJhcCh7XG4gICAgICAgIHRyYXBFbGVtZW50OiB0aGlzLl9lbGVtZW50XG4gICAgICB9KTtcbiAgICB9XG4gICAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0tFWURPV05fRElTTUlTUywgZXZlbnQgPT4ge1xuICAgICAgICBpZiAoZXZlbnQua2V5ICE9PSBFU0NBUEVfS0VZKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jb25maWcua2V5Ym9hcmQpIHtcbiAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERV9QUkVWRU5URUQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gU3RhdGljXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gT2ZmY2FudmFzLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCB8fCBjb25maWcuc3RhcnRzV2l0aCgnXycpIHx8IGNvbmZpZyA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtjb25maWddKHRoaXMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gICAqL1xuXG4gIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMSwgU0VMRUNUT1JfREFUQV9UT0dHTEUkMSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gU2VsZWN0b3JFbmdpbmUuZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0aGlzKTtcbiAgICBpZiAoWydBJywgJ0FSRUEnXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBpZiAoaXNEaXNhYmxlZCh0aGlzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBFdmVudEhhbmRsZXIub25lKHRhcmdldCwgRVZFTlRfSElEREVOJDMsICgpID0+IHtcbiAgICAgIC8vIGZvY3VzIG9uIHRyaWdnZXIgd2hlbiBpdCBpcyBjbG9zZWRcbiAgICAgIGlmIChpc1Zpc2libGUodGhpcykpIHtcbiAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gYXZvaWQgY29uZmxpY3Qgd2hlbiBjbGlja2luZyBhIHRvZ2dsZXIgb2YgYW4gb2ZmY2FudmFzLCB3aGlsZSBhbm90aGVyIGlzIG9wZW5cbiAgICBjb25zdCBhbHJlYWR5T3BlbiA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoT1BFTl9TRUxFQ1RPUik7XG4gICAgaWYgKGFscmVhZHlPcGVuICYmIGFscmVhZHlPcGVuICE9PSB0YXJnZXQpIHtcbiAgICAgIE9mZmNhbnZhcy5nZXRJbnN0YW5jZShhbHJlYWR5T3BlbikuaGlkZSgpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gT2ZmY2FudmFzLmdldE9yQ3JlYXRlSW5zdGFuY2UodGFyZ2V0KTtcbiAgICBkYXRhLnRvZ2dsZSh0aGlzKTtcbiAgfSk7XG4gIEV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX0xPQURfREFUQV9BUEkkMiwgKCkgPT4ge1xuICAgIGZvciAoY29uc3Qgc2VsZWN0b3Igb2YgU2VsZWN0b3JFbmdpbmUuZmluZChPUEVOX1NFTEVDVE9SKSkge1xuICAgICAgT2ZmY2FudmFzLmdldE9yQ3JlYXRlSW5zdGFuY2Uoc2VsZWN0b3IpLnNob3coKTtcbiAgICB9XG4gIH0pO1xuICBFdmVudEhhbmRsZXIub24od2luZG93LCBFVkVOVF9SRVNJWkUsICgpID0+IHtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgU2VsZWN0b3JFbmdpbmUuZmluZCgnW2FyaWEtbW9kYWxdW2NsYXNzKj1zaG93XVtjbGFzcyo9b2ZmY2FudmFzLV0nKSkge1xuICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gIT09ICdmaXhlZCcpIHtcbiAgICAgICAgT2ZmY2FudmFzLmdldE9yQ3JlYXRlSW5zdGFuY2UoZWxlbWVudCkuaGlkZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGVuYWJsZURpc21pc3NUcmlnZ2VyKE9mZmNhbnZhcyk7XG5cbiAgLyoqXG4gICAqIGpRdWVyeVxuICAgKi9cblxuICBkZWZpbmVKUXVlcnlQbHVnaW4oT2ZmY2FudmFzKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwIHV0aWwvc2FuaXRpemVyLmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAvLyBqcy1kb2NzLXN0YXJ0IGFsbG93LWxpc3RcbiAgY29uc3QgQVJJQV9BVFRSSUJVVEVfUEFUVEVSTiA9IC9eYXJpYS1bXFx3LV0qJC9pO1xuICBjb25zdCBEZWZhdWx0QWxsb3dsaXN0ID0ge1xuICAgIC8vIEdsb2JhbCBhdHRyaWJ1dGVzIGFsbG93ZWQgb24gYW55IHN1cHBsaWVkIGVsZW1lbnQgYmVsb3cuXG4gICAgJyonOiBbJ2NsYXNzJywgJ2RpcicsICdpZCcsICdsYW5nJywgJ3JvbGUnLCBBUklBX0FUVFJJQlVURV9QQVRURVJOXSxcbiAgICBhOiBbJ3RhcmdldCcsICdocmVmJywgJ3RpdGxlJywgJ3JlbCddLFxuICAgIGFyZWE6IFtdLFxuICAgIGI6IFtdLFxuICAgIGJyOiBbXSxcbiAgICBjb2w6IFtdLFxuICAgIGNvZGU6IFtdLFxuICAgIGRpdjogW10sXG4gICAgZW06IFtdLFxuICAgIGhyOiBbXSxcbiAgICBoMTogW10sXG4gICAgaDI6IFtdLFxuICAgIGgzOiBbXSxcbiAgICBoNDogW10sXG4gICAgaDU6IFtdLFxuICAgIGg2OiBbXSxcbiAgICBpOiBbXSxcbiAgICBpbWc6IFsnc3JjJywgJ3NyY3NldCcsICdhbHQnLCAndGl0bGUnLCAnd2lkdGgnLCAnaGVpZ2h0J10sXG4gICAgbGk6IFtdLFxuICAgIG9sOiBbXSxcbiAgICBwOiBbXSxcbiAgICBwcmU6IFtdLFxuICAgIHM6IFtdLFxuICAgIHNtYWxsOiBbXSxcbiAgICBzcGFuOiBbXSxcbiAgICBzdWI6IFtdLFxuICAgIHN1cDogW10sXG4gICAgc3Ryb25nOiBbXSxcbiAgICB1OiBbXSxcbiAgICB1bDogW11cbiAgfTtcbiAgLy8ganMtZG9jcy1lbmQgYWxsb3ctbGlzdFxuXG4gIGNvbnN0IHVyaUF0dHJpYnV0ZXMgPSBuZXcgU2V0KFsnYmFja2dyb3VuZCcsICdjaXRlJywgJ2hyZWYnLCAnaXRlbXR5cGUnLCAnbG9uZ2Rlc2MnLCAncG9zdGVyJywgJ3NyYycsICd4bGluazpocmVmJ10pO1xuXG4gIC8qKlxuICAgKiBBIHBhdHRlcm4gdGhhdCByZWNvZ25pemVzIFVSTHMgdGhhdCBhcmUgc2FmZSB3cnQuIFhTUyBpbiBVUkwgbmF2aWdhdGlvblxuICAgKiBjb250ZXh0cy5cbiAgICpcbiAgICogU2hvdXQtb3V0IHRvIEFuZ3VsYXIgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9ibG9iLzE1LjIuOC9wYWNrYWdlcy9jb3JlL3NyYy9zYW5pdGl6YXRpb24vdXJsX3Nhbml0aXplci50cyNMMzhcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL2JldHRlci1yZWdleFxuICBjb25zdCBTQUZFX1VSTF9QQVRURVJOID0gL14oPyFqYXZhc2NyaXB0OikoPzpbYS16MC05Ky4tXSs6fFteJjovPyNdKig/OlsvPyNdfCQpKS9pO1xuICBjb25zdCBhbGxvd2VkQXR0cmlidXRlID0gKGF0dHJpYnV0ZSwgYWxsb3dlZEF0dHJpYnV0ZUxpc3QpID0+IHtcbiAgICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGFsbG93ZWRBdHRyaWJ1dGVMaXN0LmluY2x1ZGVzKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICBpZiAodXJpQXR0cmlidXRlcy5oYXMoYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oU0FGRV9VUkxfUEFUVEVSTi50ZXN0KGF0dHJpYnV0ZS5ub2RlVmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGEgcmVndWxhciBleHByZXNzaW9uIHZhbGlkYXRlcyB0aGUgYXR0cmlidXRlLlxuICAgIHJldHVybiBhbGxvd2VkQXR0cmlidXRlTGlzdC5maWx0ZXIoYXR0cmlidXRlUmVnZXggPT4gYXR0cmlidXRlUmVnZXggaW5zdGFuY2VvZiBSZWdFeHApLnNvbWUocmVnZXggPT4gcmVnZXgudGVzdChhdHRyaWJ1dGVOYW1lKSk7XG4gIH07XG4gIGZ1bmN0aW9uIHNhbml0aXplSHRtbCh1bnNhZmVIdG1sLCBhbGxvd0xpc3QsIHNhbml0aXplRnVuY3Rpb24pIHtcbiAgICBpZiAoIXVuc2FmZUh0bWwubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdW5zYWZlSHRtbDtcbiAgICB9XG4gICAgaWYgKHNhbml0aXplRnVuY3Rpb24gJiYgdHlwZW9mIHNhbml0aXplRnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBzYW5pdGl6ZUZ1bmN0aW9uKHVuc2FmZUh0bWwpO1xuICAgIH1cbiAgICBjb25zdCBkb21QYXJzZXIgPSBuZXcgd2luZG93LkRPTVBhcnNlcigpO1xuICAgIGNvbnN0IGNyZWF0ZWREb2N1bWVudCA9IGRvbVBhcnNlci5wYXJzZUZyb21TdHJpbmcodW5zYWZlSHRtbCwgJ3RleHQvaHRtbCcpO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gW10uY29uY2F0KC4uLmNyZWF0ZWREb2N1bWVudC5ib2R5LnF1ZXJ5U2VsZWN0b3JBbGwoJyonKSk7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICBjb25zdCBlbGVtZW50TmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICghT2JqZWN0LmtleXMoYWxsb3dMaXN0KS5pbmNsdWRlcyhlbGVtZW50TmFtZSkpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBhdHRyaWJ1dGVMaXN0ID0gW10uY29uY2F0KC4uLmVsZW1lbnQuYXR0cmlidXRlcyk7XG4gICAgICBjb25zdCBhbGxvd2VkQXR0cmlidXRlcyA9IFtdLmNvbmNhdChhbGxvd0xpc3RbJyonXSB8fCBbXSwgYWxsb3dMaXN0W2VsZW1lbnROYW1lXSB8fCBbXSk7XG4gICAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBhdHRyaWJ1dGVMaXN0KSB7XG4gICAgICAgIGlmICghYWxsb3dlZEF0dHJpYnV0ZShhdHRyaWJ1dGUsIGFsbG93ZWRBdHRyaWJ1dGVzKSkge1xuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZS5ub2RlTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZWREb2N1bWVudC5ib2R5LmlubmVySFRNTDtcbiAgfVxuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgdXRpbC90ZW1wbGF0ZS1mYWN0b3J5LmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBDb25zdGFudHNcbiAgICovXG5cbiAgY29uc3QgTkFNRSQ1ID0gJ1RlbXBsYXRlRmFjdG9yeSc7XG4gIGNvbnN0IERlZmF1bHQkNCA9IHtcbiAgICBhbGxvd0xpc3Q6IERlZmF1bHRBbGxvd2xpc3QsXG4gICAgY29udGVudDoge30sXG4gICAgLy8geyBzZWxlY3RvciA6IHRleHQgLCAgc2VsZWN0b3IyIDogdGV4dDIgLCB9XG4gICAgZXh0cmFDbGFzczogJycsXG4gICAgaHRtbDogZmFsc2UsXG4gICAgc2FuaXRpemU6IHRydWUsXG4gICAgc2FuaXRpemVGbjogbnVsbCxcbiAgICB0ZW1wbGF0ZTogJzxkaXY+PC9kaXY+J1xuICB9O1xuICBjb25zdCBEZWZhdWx0VHlwZSQ0ID0ge1xuICAgIGFsbG93TGlzdDogJ29iamVjdCcsXG4gICAgY29udGVudDogJ29iamVjdCcsXG4gICAgZXh0cmFDbGFzczogJyhzdHJpbmd8ZnVuY3Rpb24pJyxcbiAgICBodG1sOiAnYm9vbGVhbicsXG4gICAgc2FuaXRpemU6ICdib29sZWFuJyxcbiAgICBzYW5pdGl6ZUZuOiAnKG51bGx8ZnVuY3Rpb24pJyxcbiAgICB0ZW1wbGF0ZTogJ3N0cmluZydcbiAgfTtcbiAgY29uc3QgRGVmYXVsdENvbnRlbnRUeXBlID0ge1xuICAgIGVudHJ5OiAnKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9ufG51bGwpJyxcbiAgICBzZWxlY3RvcjogJyhzdHJpbmd8ZWxlbWVudCknXG4gIH07XG5cbiAgLyoqXG4gICAqIENsYXNzIGRlZmluaXRpb25cbiAgICovXG5cbiAgY2xhc3MgVGVtcGxhdGVGYWN0b3J5IGV4dGVuZHMgQ29uZmlnIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICB9XG5cbiAgICAvLyBHZXR0ZXJzXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgICAgcmV0dXJuIERlZmF1bHQkNDtcbiAgICB9XG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSQ0O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgICByZXR1cm4gTkFNRSQ1O1xuICAgIH1cblxuICAgIC8vIFB1YmxpY1xuICAgIGdldENvbnRlbnQoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLl9jb25maWcuY29udGVudCkubWFwKGNvbmZpZyA9PiB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbihjb25maWcpKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgfVxuICAgIGhhc0NvbnRlbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRDb250ZW50KCkubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgY2hhbmdlQ29udGVudChjb250ZW50KSB7XG4gICAgICB0aGlzLl9jaGVja0NvbnRlbnQoY29udGVudCk7XG4gICAgICB0aGlzLl9jb25maWcuY29udGVudCA9IHtcbiAgICAgICAgLi4udGhpcy5fY29uZmlnLmNvbnRlbnQsXG4gICAgICAgIC4uLmNvbnRlbnRcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9IdG1sKCkge1xuICAgICAgY29uc3QgdGVtcGxhdGVXcmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0ZW1wbGF0ZVdyYXBwZXIuaW5uZXJIVE1MID0gdGhpcy5fbWF5YmVTYW5pdGl6ZSh0aGlzLl9jb25maWcudGVtcGxhdGUpO1xuICAgICAgZm9yIChjb25zdCBbc2VsZWN0b3IsIHRleHRdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuX2NvbmZpZy5jb250ZW50KSkge1xuICAgICAgICB0aGlzLl9zZXRDb250ZW50KHRlbXBsYXRlV3JhcHBlciwgdGV4dCwgc2VsZWN0b3IpO1xuICAgICAgfVxuICAgICAgY29uc3QgdGVtcGxhdGUgPSB0ZW1wbGF0ZVdyYXBwZXIuY2hpbGRyZW5bMF07XG4gICAgICBjb25zdCBleHRyYUNsYXNzID0gdGhpcy5fcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24odGhpcy5fY29uZmlnLmV4dHJhQ2xhc3MpO1xuICAgICAgaWYgKGV4dHJhQ2xhc3MpIHtcbiAgICAgICAgdGVtcGxhdGUuY2xhc3NMaXN0LmFkZCguLi5leHRyYUNsYXNzLnNwbGl0KCcgJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgIH1cblxuICAgIC8vIFByaXZhdGVcbiAgICBfdHlwZUNoZWNrQ29uZmlnKGNvbmZpZykge1xuICAgICAgc3VwZXIuX3R5cGVDaGVja0NvbmZpZyhjb25maWcpO1xuICAgICAgdGhpcy5fY2hlY2tDb250ZW50KGNvbmZpZy5jb250ZW50KTtcbiAgICB9XG4gICAgX2NoZWNrQ29udGVudChhcmcpIHtcbiAgICAgIGZvciAoY29uc3QgW3NlbGVjdG9yLCBjb250ZW50XSBvZiBPYmplY3QuZW50cmllcyhhcmcpKSB7XG4gICAgICAgIHN1cGVyLl90eXBlQ2hlY2tDb25maWcoe1xuICAgICAgICAgIHNlbGVjdG9yLFxuICAgICAgICAgIGVudHJ5OiBjb250ZW50XG4gICAgICAgIH0sIERlZmF1bHRDb250ZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9zZXRDb250ZW50KHRlbXBsYXRlLCBjb250ZW50LCBzZWxlY3Rvcikge1xuICAgICAgY29uc3QgdGVtcGxhdGVFbGVtZW50ID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShzZWxlY3RvciwgdGVtcGxhdGUpO1xuICAgICAgaWYgKCF0ZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29udGVudCA9IHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKGNvbnRlbnQpO1xuICAgICAgaWYgKCFjb250ZW50KSB7XG4gICAgICAgIHRlbXBsYXRlRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzRWxlbWVudChjb250ZW50KSkge1xuICAgICAgICB0aGlzLl9wdXRFbGVtZW50SW5UZW1wbGF0ZShnZXRFbGVtZW50KGNvbnRlbnQpLCB0ZW1wbGF0ZUVsZW1lbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fY29uZmlnLmh0bWwpIHtcbiAgICAgICAgdGVtcGxhdGVFbGVtZW50LmlubmVySFRNTCA9IHRoaXMuX21heWJlU2FuaXRpemUoY29udGVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRlbXBsYXRlRWxlbWVudC50ZXh0Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgfVxuICAgIF9tYXliZVNhbml0aXplKGFyZykge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5zYW5pdGl6ZSA/IHNhbml0aXplSHRtbChhcmcsIHRoaXMuX2NvbmZpZy5hbGxvd0xpc3QsIHRoaXMuX2NvbmZpZy5zYW5pdGl6ZUZuKSA6IGFyZztcbiAgICB9XG4gICAgX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKGFyZykge1xuICAgICAgcmV0dXJuIGV4ZWN1dGUoYXJnLCBbdGhpc10pO1xuICAgIH1cbiAgICBfcHV0RWxlbWVudEluVGVtcGxhdGUoZWxlbWVudCwgdGVtcGxhdGVFbGVtZW50KSB7XG4gICAgICBpZiAodGhpcy5fY29uZmlnLmh0bWwpIHtcbiAgICAgICAgdGVtcGxhdGVFbGVtZW50LmlubmVySFRNTCA9ICcnO1xuICAgICAgICB0ZW1wbGF0ZUVsZW1lbnQuYXBwZW5kKGVsZW1lbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0ZW1wbGF0ZUVsZW1lbnQudGV4dENvbnRlbnQgPSBlbGVtZW50LnRleHRDb250ZW50O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgdG9vbHRpcC5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cblxuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IE5BTUUkNCA9ICd0b29sdGlwJztcbiAgY29uc3QgRElTQUxMT1dFRF9BVFRSSUJVVEVTID0gbmV3IFNldChbJ3Nhbml0aXplJywgJ2FsbG93TGlzdCcsICdzYW5pdGl6ZUZuJ10pO1xuICBjb25zdCBDTEFTU19OQU1FX0ZBREUkMiA9ICdmYWRlJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9NT0RBTCA9ICdtb2RhbCc7XG4gIGNvbnN0IENMQVNTX05BTUVfU0hPVyQyID0gJ3Nob3cnO1xuICBjb25zdCBTRUxFQ1RPUl9UT09MVElQX0lOTkVSID0gJy50b29sdGlwLWlubmVyJztcbiAgY29uc3QgU0VMRUNUT1JfTU9EQUwgPSBgLiR7Q0xBU1NfTkFNRV9NT0RBTH1gO1xuICBjb25zdCBFVkVOVF9NT0RBTF9ISURFID0gJ2hpZGUuYnMubW9kYWwnO1xuICBjb25zdCBUUklHR0VSX0hPVkVSID0gJ2hvdmVyJztcbiAgY29uc3QgVFJJR0dFUl9GT0NVUyA9ICdmb2N1cyc7XG4gIGNvbnN0IFRSSUdHRVJfQ0xJQ0sgPSAnY2xpY2snO1xuICBjb25zdCBUUklHR0VSX01BTlVBTCA9ICdtYW51YWwnO1xuICBjb25zdCBFVkVOVF9ISURFJDIgPSAnaGlkZSc7XG4gIGNvbnN0IEVWRU5UX0hJRERFTiQyID0gJ2hpZGRlbic7XG4gIGNvbnN0IEVWRU5UX1NIT1ckMiA9ICdzaG93JztcbiAgY29uc3QgRVZFTlRfU0hPV04kMiA9ICdzaG93bic7XG4gIGNvbnN0IEVWRU5UX0lOU0VSVEVEID0gJ2luc2VydGVkJztcbiAgY29uc3QgRVZFTlRfQ0xJQ0skMSA9ICdjbGljayc7XG4gIGNvbnN0IEVWRU5UX0ZPQ1VTSU4kMSA9ICdmb2N1c2luJztcbiAgY29uc3QgRVZFTlRfRk9DVVNPVVQkMSA9ICdmb2N1c291dCc7XG4gIGNvbnN0IEVWRU5UX01PVVNFRU5URVIgPSAnbW91c2VlbnRlcic7XG4gIGNvbnN0IEVWRU5UX01PVVNFTEVBVkUgPSAnbW91c2VsZWF2ZSc7XG4gIGNvbnN0IEF0dGFjaG1lbnRNYXAgPSB7XG4gICAgQVVUTzogJ2F1dG8nLFxuICAgIFRPUDogJ3RvcCcsXG4gICAgUklHSFQ6IGlzUlRMKCkgPyAnbGVmdCcgOiAncmlnaHQnLFxuICAgIEJPVFRPTTogJ2JvdHRvbScsXG4gICAgTEVGVDogaXNSVEwoKSA/ICdyaWdodCcgOiAnbGVmdCdcbiAgfTtcbiAgY29uc3QgRGVmYXVsdCQzID0ge1xuICAgIGFsbG93TGlzdDogRGVmYXVsdEFsbG93bGlzdCxcbiAgICBhbmltYXRpb246IHRydWUsXG4gICAgYm91bmRhcnk6ICdjbGlwcGluZ1BhcmVudHMnLFxuICAgIGNvbnRhaW5lcjogZmFsc2UsXG4gICAgY3VzdG9tQ2xhc3M6ICcnLFxuICAgIGRlbGF5OiAwLFxuICAgIGZhbGxiYWNrUGxhY2VtZW50czogWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXSxcbiAgICBodG1sOiBmYWxzZSxcbiAgICBvZmZzZXQ6IFswLCA2XSxcbiAgICBwbGFjZW1lbnQ6ICd0b3AnLFxuICAgIHBvcHBlckNvbmZpZzogbnVsbCxcbiAgICBzYW5pdGl6ZTogdHJ1ZSxcbiAgICBzYW5pdGl6ZUZuOiBudWxsLFxuICAgIHNlbGVjdG9yOiBmYWxzZSxcbiAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJ0b29sdGlwXCIgcm9sZT1cInRvb2x0aXBcIj4nICsgJzxkaXYgY2xhc3M9XCJ0b29sdGlwLWFycm93XCI+PC9kaXY+JyArICc8ZGl2IGNsYXNzPVwidG9vbHRpcC1pbm5lclwiPjwvZGl2PicgKyAnPC9kaXY+JyxcbiAgICB0aXRsZTogJycsXG4gICAgdHJpZ2dlcjogJ2hvdmVyIGZvY3VzJ1xuICB9O1xuICBjb25zdCBEZWZhdWx0VHlwZSQzID0ge1xuICAgIGFsbG93TGlzdDogJ29iamVjdCcsXG4gICAgYW5pbWF0aW9uOiAnYm9vbGVhbicsXG4gICAgYm91bmRhcnk6ICcoc3RyaW5nfGVsZW1lbnQpJyxcbiAgICBjb250YWluZXI6ICcoc3RyaW5nfGVsZW1lbnR8Ym9vbGVhbiknLFxuICAgIGN1c3RvbUNsYXNzOiAnKHN0cmluZ3xmdW5jdGlvbiknLFxuICAgIGRlbGF5OiAnKG51bWJlcnxvYmplY3QpJyxcbiAgICBmYWxsYmFja1BsYWNlbWVudHM6ICdhcnJheScsXG4gICAgaHRtbDogJ2Jvb2xlYW4nLFxuICAgIG9mZnNldDogJyhhcnJheXxzdHJpbmd8ZnVuY3Rpb24pJyxcbiAgICBwbGFjZW1lbnQ6ICcoc3RyaW5nfGZ1bmN0aW9uKScsXG4gICAgcG9wcGVyQ29uZmlnOiAnKG51bGx8b2JqZWN0fGZ1bmN0aW9uKScsXG4gICAgc2FuaXRpemU6ICdib29sZWFuJyxcbiAgICBzYW5pdGl6ZUZuOiAnKG51bGx8ZnVuY3Rpb24pJyxcbiAgICBzZWxlY3RvcjogJyhzdHJpbmd8Ym9vbGVhbiknLFxuICAgIHRlbXBsYXRlOiAnc3RyaW5nJyxcbiAgICB0aXRsZTogJyhzdHJpbmd8ZWxlbWVudHxmdW5jdGlvbiknLFxuICAgIHRyaWdnZXI6ICdzdHJpbmcnXG4gIH07XG5cbiAgLyoqXG4gICAqIENsYXNzIGRlZmluaXRpb25cbiAgICovXG5cbiAgY2xhc3MgVG9vbHRpcCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgICAgaWYgKHR5cGVvZiBQb3BwZXJfX25hbWVzcGFjZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9vdHN0cmFwXFwncyB0b29sdGlwcyByZXF1aXJlIFBvcHBlciAoaHR0cHM6Ly9wb3BwZXIuanMub3JnKScpO1xuICAgICAgfVxuICAgICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKTtcblxuICAgICAgLy8gUHJpdmF0ZVxuICAgICAgdGhpcy5faXNFbmFibGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSAwO1xuICAgICAgdGhpcy5faXNIb3ZlcmVkID0gbnVsbDtcbiAgICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXIgPSB7fTtcbiAgICAgIHRoaXMuX3BvcHBlciA9IG51bGw7XG4gICAgICB0aGlzLl90ZW1wbGF0ZUZhY3RvcnkgPSBudWxsO1xuICAgICAgdGhpcy5fbmV3Q29udGVudCA9IG51bGw7XG5cbiAgICAgIC8vIFByb3RlY3RlZFxuICAgICAgdGhpcy50aXAgPSBudWxsO1xuICAgICAgdGhpcy5fc2V0TGlzdGVuZXJzKCk7XG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5zZWxlY3Rvcikge1xuICAgICAgICB0aGlzLl9maXhUaXRsZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdldHRlcnNcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdCQzO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDM7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICAgIHJldHVybiBOQU1FJDQ7XG4gICAgfVxuXG4gICAgLy8gUHVibGljXG4gICAgZW5hYmxlKCkge1xuICAgICAgdGhpcy5faXNFbmFibGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgZGlzYWJsZSgpIHtcbiAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICB0b2dnbGVFbmFibGVkKCkge1xuICAgICAgdGhpcy5faXNFbmFibGVkID0gIXRoaXMuX2lzRW5hYmxlZDtcbiAgICB9XG4gICAgdG9nZ2xlKCkge1xuICAgICAgaWYgKCF0aGlzLl9pc0VuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlci5jbGljayA9ICF0aGlzLl9hY3RpdmVUcmlnZ2VyLmNsaWNrO1xuICAgICAgaWYgKHRoaXMuX2lzU2hvd24oKSkge1xuICAgICAgICB0aGlzLl9sZWF2ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9lbnRlcigpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuICAgICAgRXZlbnRIYW5kbGVyLm9mZih0aGlzLl9lbGVtZW50LmNsb3Nlc3QoU0VMRUNUT1JfTU9EQUwpLCBFVkVOVF9NT0RBTF9ISURFLCB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyKTtcbiAgICAgIGlmICh0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1icy1vcmlnaW5hbC10aXRsZScpKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCd0aXRsZScsIHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLW9yaWdpbmFsLXRpdGxlJykpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZGlzcG9zZVBvcHBlcigpO1xuICAgICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBzaG93KCkge1xuICAgICAgaWYgKHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHVzZSBzaG93IG9uIHZpc2libGUgZWxlbWVudHMnKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHRoaXMuX2lzV2l0aENvbnRlbnQoKSAmJiB0aGlzLl9pc0VuYWJsZWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX1NIT1ckMikpO1xuICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IGZpbmRTaGFkb3dSb290KHRoaXMuX2VsZW1lbnQpO1xuICAgICAgY29uc3QgaXNJblRoZURvbSA9IChzaGFkb3dSb290IHx8IHRoaXMuX2VsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmNvbnRhaW5zKHRoaXMuX2VsZW1lbnQpO1xuICAgICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkIHx8ICFpc0luVGhlRG9tKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETzogdjYgcmVtb3ZlIHRoaXMgb3IgbWFrZSBpdCBvcHRpb25hbFxuICAgICAgdGhpcy5fZGlzcG9zZVBvcHBlcigpO1xuICAgICAgY29uc3QgdGlwID0gdGhpcy5fZ2V0VGlwRWxlbWVudCgpO1xuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknLCB0aXAuZ2V0QXR0cmlidXRlKCdpZCcpKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29udGFpbmVyXG4gICAgICB9ID0gdGhpcy5fY29uZmlnO1xuICAgICAgaWYgKCF0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKHRoaXMudGlwKSkge1xuICAgICAgICBjb250YWluZXIuYXBwZW5kKHRpcCk7XG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX0lOU0VSVEVEKSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9wb3BwZXIgPSB0aGlzLl9jcmVhdGVQb3BwZXIodGlwKTtcbiAgICAgIHRpcC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQyKTtcblxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIGFkZCBleHRyYVxuICAgICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB0byB0aGUgYm9keSdzIGltbWVkaWF0ZSBjaGlsZHJlbjtcbiAgICAgIC8vIG9ubHkgbmVlZGVkIGJlY2F1c2Ugb2YgYnJva2VuIGV2ZW50IGRlbGVnYXRpb24gb24gaU9TXG4gICAgICAvLyBodHRwczovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTQvMDIvbW91c2VfZXZlbnRfYnViLmh0bWxcbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKSkge1xuICAgICAgICAgIEV2ZW50SGFuZGxlci5vbihlbGVtZW50LCAnbW91c2VvdmVyJywgbm9vcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50TmFtZShFVkVOVF9TSE9XTiQyKSk7XG4gICAgICAgIGlmICh0aGlzLl9pc0hvdmVyZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5fbGVhdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc0hvdmVyZWQgPSBmYWxzZTtcbiAgICAgIH07XG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCB0aGlzLnRpcCwgdGhpcy5faXNBbmltYXRlZCgpKTtcbiAgICB9XG4gICAgaGlkZSgpIHtcbiAgICAgIGlmICghdGhpcy5faXNTaG93bigpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX0hJREUkMikpO1xuICAgICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRpcCA9IHRoaXMuX2dldFRpcEVsZW1lbnQoKTtcbiAgICAgIHRpcC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQyKTtcblxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIHJlbW92ZSB0aGUgZXh0cmFcbiAgICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgd2UgYWRkZWQgZm9yIGlPUyBzdXBwb3J0XG4gICAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikpIHtcbiAgICAgICAgICBFdmVudEhhbmRsZXIub2ZmKGVsZW1lbnQsICdtb3VzZW92ZXInLCBub29wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlcltUUklHR0VSX0NMSUNLXSA9IGZhbHNlO1xuICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlcltUUklHR0VSX0ZPQ1VTXSA9IGZhbHNlO1xuICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlcltUUklHR0VSX0hPVkVSXSA9IGZhbHNlO1xuICAgICAgdGhpcy5faXNIb3ZlcmVkID0gbnVsbDsgLy8gaXQgaXMgYSB0cmljayB0byBzdXBwb3J0IG1hbnVhbCB0cmlnZ2VyaW5nXG5cbiAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faXNIb3ZlcmVkKSB7XG4gICAgICAgICAgdGhpcy5fZGlzcG9zZVBvcHBlcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5Jyk7XG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX0hJRERFTiQyKSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy50aXAsIHRoaXMuX2lzQW5pbWF0ZWQoKSk7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcbiAgICAgICAgdGhpcy5fcG9wcGVyLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFByb3RlY3RlZFxuICAgIF9pc1dpdGhDb250ZW50KCkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5fZ2V0VGl0bGUoKSk7XG4gICAgfVxuICAgIF9nZXRUaXBFbGVtZW50KCkge1xuICAgICAgaWYgKCF0aGlzLnRpcCkge1xuICAgICAgICB0aGlzLnRpcCA9IHRoaXMuX2NyZWF0ZVRpcEVsZW1lbnQodGhpcy5fbmV3Q29udGVudCB8fCB0aGlzLl9nZXRDb250ZW50Rm9yVGVtcGxhdGUoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50aXA7XG4gICAgfVxuICAgIF9jcmVhdGVUaXBFbGVtZW50KGNvbnRlbnQpIHtcbiAgICAgIGNvbnN0IHRpcCA9IHRoaXMuX2dldFRlbXBsYXRlRmFjdG9yeShjb250ZW50KS50b0h0bWwoKTtcblxuICAgICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgY2hlY2sgaW4gdjZcbiAgICAgIGlmICghdGlwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdGlwLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9GQURFJDIsIENMQVNTX05BTUVfU0hPVyQyKTtcbiAgICAgIC8vIFRPRE86IHY2IHRoZSBmb2xsb3dpbmcgY2FuIGJlIGFjaGlldmVkIHdpdGggQ1NTIG9ubHlcbiAgICAgIHRpcC5jbGFzc0xpc3QuYWRkKGBicy0ke3RoaXMuY29uc3RydWN0b3IuTkFNRX0tYXV0b2ApO1xuICAgICAgY29uc3QgdGlwSWQgPSBnZXRVSUQodGhpcy5jb25zdHJ1Y3Rvci5OQU1FKS50b1N0cmluZygpO1xuICAgICAgdGlwLnNldEF0dHJpYnV0ZSgnaWQnLCB0aXBJZCk7XG4gICAgICBpZiAodGhpcy5faXNBbmltYXRlZCgpKSB7XG4gICAgICAgIHRpcC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfRkFERSQyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aXA7XG4gICAgfVxuICAgIHNldENvbnRlbnQoY29udGVudCkge1xuICAgICAgdGhpcy5fbmV3Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgICBpZiAodGhpcy5faXNTaG93bigpKSB7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VQb3BwZXIoKTtcbiAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICB9XG4gICAgfVxuICAgIF9nZXRUZW1wbGF0ZUZhY3RvcnkoY29udGVudCkge1xuICAgICAgaWYgKHRoaXMuX3RlbXBsYXRlRmFjdG9yeSkge1xuICAgICAgICB0aGlzLl90ZW1wbGF0ZUZhY3RvcnkuY2hhbmdlQ29udGVudChjb250ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlRmFjdG9yeSA9IG5ldyBUZW1wbGF0ZUZhY3Rvcnkoe1xuICAgICAgICAgIC4uLnRoaXMuX2NvbmZpZyxcbiAgICAgICAgICAvLyB0aGUgYGNvbnRlbnRgIHZhciBoYXMgdG8gYmUgYWZ0ZXIgYHRoaXMuX2NvbmZpZ2BcbiAgICAgICAgICAvLyB0byBvdmVycmlkZSBjb25maWcuY29udGVudCBpbiBjYXNlIG9mIHBvcG92ZXJcbiAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgIGV4dHJhQ2xhc3M6IHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHRoaXMuX2NvbmZpZy5jdXN0b21DbGFzcylcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGVGYWN0b3J5O1xuICAgIH1cbiAgICBfZ2V0Q29udGVudEZvclRlbXBsYXRlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW1NFTEVDVE9SX1RPT0xUSVBfSU5ORVJdOiB0aGlzLl9nZXRUaXRsZSgpXG4gICAgICB9O1xuICAgIH1cbiAgICBfZ2V0VGl0bGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24odGhpcy5fY29uZmlnLnRpdGxlKSB8fCB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1icy1vcmlnaW5hbC10aXRsZScpO1xuICAgIH1cblxuICAgIC8vIFByaXZhdGVcbiAgICBfaW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KGV2ZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5nZXRPckNyZWF0ZUluc3RhbmNlKGV2ZW50LmRlbGVnYXRlVGFyZ2V0LCB0aGlzLl9nZXREZWxlZ2F0ZUNvbmZpZygpKTtcbiAgICB9XG4gICAgX2lzQW5pbWF0ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29uZmlnLmFuaW1hdGlvbiB8fCB0aGlzLnRpcCAmJiB0aGlzLnRpcC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFJDIpO1xuICAgIH1cbiAgICBfaXNTaG93bigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRpcCAmJiB0aGlzLnRpcC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XJDIpO1xuICAgIH1cbiAgICBfY3JlYXRlUG9wcGVyKHRpcCkge1xuICAgICAgY29uc3QgcGxhY2VtZW50ID0gZXhlY3V0ZSh0aGlzLl9jb25maWcucGxhY2VtZW50LCBbdGhpcywgdGlwLCB0aGlzLl9lbGVtZW50XSk7XG4gICAgICBjb25zdCBhdHRhY2htZW50ID0gQXR0YWNobWVudE1hcFtwbGFjZW1lbnQudG9VcHBlckNhc2UoKV07XG4gICAgICByZXR1cm4gUG9wcGVyX19uYW1lc3BhY2UuY3JlYXRlUG9wcGVyKHRoaXMuX2VsZW1lbnQsIHRpcCwgdGhpcy5fZ2V0UG9wcGVyQ29uZmlnKGF0dGFjaG1lbnQpKTtcbiAgICB9XG4gICAgX2dldE9mZnNldCgpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb2Zmc2V0XG4gICAgICB9ID0gdGhpcy5fY29uZmlnO1xuICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBvZmZzZXQuc3BsaXQoJywnKS5tYXAodmFsdWUgPT4gTnVtYmVyLnBhcnNlSW50KHZhbHVlLCAxMCkpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHBvcHBlckRhdGEgPT4gb2Zmc2V0KHBvcHBlckRhdGEsIHRoaXMuX2VsZW1lbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gICAgX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKGFyZykge1xuICAgICAgcmV0dXJuIGV4ZWN1dGUoYXJnLCBbdGhpcy5fZWxlbWVudF0pO1xuICAgIH1cbiAgICBfZ2V0UG9wcGVyQ29uZmlnKGF0dGFjaG1lbnQpIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRCc1BvcHBlckNvbmZpZyA9IHtcbiAgICAgICAgcGxhY2VtZW50OiBhdHRhY2htZW50LFxuICAgICAgICBtb2RpZmllcnM6IFt7XG4gICAgICAgICAgbmFtZTogJ2ZsaXAnLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGZhbGxiYWNrUGxhY2VtZW50czogdGhpcy5fY29uZmlnLmZhbGxiYWNrUGxhY2VtZW50c1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KClcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBib3VuZGFyeTogdGhpcy5fY29uZmlnLmJvdW5kYXJ5XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogJ2Fycm93JyxcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBlbGVtZW50OiBgLiR7dGhpcy5jb25zdHJ1Y3Rvci5OQU1FfS1hcnJvd2BcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiAncHJlU2V0UGxhY2VtZW50JyxcbiAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgIHBoYXNlOiAnYmVmb3JlTWFpbicsXG4gICAgICAgICAgZm46IGRhdGEgPT4ge1xuICAgICAgICAgICAgLy8gUHJlLXNldCBQb3BwZXIncyBwbGFjZW1lbnQgYXR0cmlidXRlIGluIG9yZGVyIHRvIHJlYWQgdGhlIGFycm93IHNpemVzIHByb3Blcmx5LlxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBQb3BwZXIgbWl4ZXMgdXAgdGhlIHdpZHRoIGFuZCBoZWlnaHQgZGltZW5zaW9ucyBzaW5jZSB0aGUgaW5pdGlhbCBhcnJvdyBzdHlsZSBpcyBmb3IgdG9wIHBsYWNlbWVudFxuICAgICAgICAgICAgdGhpcy5fZ2V0VGlwRWxlbWVudCgpLnNldEF0dHJpYnV0ZSgnZGF0YS1wb3BwZXItcGxhY2VtZW50JywgZGF0YS5zdGF0ZS5wbGFjZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfV1cbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5kZWZhdWx0QnNQb3BwZXJDb25maWcsXG4gICAgICAgIC4uLmV4ZWN1dGUodGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZywgW2RlZmF1bHRCc1BvcHBlckNvbmZpZ10pXG4gICAgICB9O1xuICAgIH1cbiAgICBfc2V0TGlzdGVuZXJzKCkge1xuICAgICAgY29uc3QgdHJpZ2dlcnMgPSB0aGlzLl9jb25maWcudHJpZ2dlci5zcGxpdCgnICcpO1xuICAgICAgZm9yIChjb25zdCB0cmlnZ2VyIG9mIHRyaWdnZXJzKSB7XG4gICAgICAgIGlmICh0cmlnZ2VyID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX0NMSUNLJDEpLCB0aGlzLl9jb25maWcuc2VsZWN0b3IsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLl9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQoZXZlbnQpO1xuICAgICAgICAgICAgY29udGV4dC50b2dnbGUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyICE9PSBUUklHR0VSX01BTlVBTCkge1xuICAgICAgICAgIGNvbnN0IGV2ZW50SW4gPSB0cmlnZ2VyID09PSBUUklHR0VSX0hPVkVSID8gdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfTU9VU0VFTlRFUikgOiB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50TmFtZShFVkVOVF9GT0NVU0lOJDEpO1xuICAgICAgICAgIGNvbnN0IGV2ZW50T3V0ID0gdHJpZ2dlciA9PT0gVFJJR0dFUl9IT1ZFUiA/IHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX01PVVNFTEVBVkUpIDogdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfRk9DVVNPVVQkMSk7XG4gICAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIGV2ZW50SW4sIHRoaXMuX2NvbmZpZy5zZWxlY3RvciwgZXZlbnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldChldmVudCk7XG4gICAgICAgICAgICBjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyW2V2ZW50LnR5cGUgPT09ICdmb2N1c2luJyA/IFRSSUdHRVJfRk9DVVMgOiBUUklHR0VSX0hPVkVSXSA9IHRydWU7XG4gICAgICAgICAgICBjb250ZXh0Ll9lbnRlcigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBldmVudE91dCwgdGhpcy5fY29uZmlnLnNlbGVjdG9yLCBldmVudCA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5faW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KGV2ZW50KTtcbiAgICAgICAgICAgIGNvbnRleHQuX2FjdGl2ZVRyaWdnZXJbZXZlbnQudHlwZSA9PT0gJ2ZvY3Vzb3V0JyA/IFRSSUdHRVJfRk9DVVMgOiBUUklHR0VSX0hPVkVSXSA9IGNvbnRleHQuX2VsZW1lbnQuY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCk7XG4gICAgICAgICAgICBjb250ZXh0Ll9sZWF2ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fZWxlbWVudCkge1xuICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQuY2xvc2VzdChTRUxFQ1RPUl9NT0RBTCksIEVWRU5UX01PREFMX0hJREUsIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXIpO1xuICAgIH1cbiAgICBfZml4VGl0bGUoKSB7XG4gICAgICBjb25zdCB0aXRsZSA9IHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKCd0aXRsZScpO1xuICAgICAgaWYgKCF0aXRsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJykgJiYgIXRoaXMuX2VsZW1lbnQudGV4dENvbnRlbnQudHJpbSgpKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgdGl0bGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtb3JpZ2luYWwtdGl0bGUnLCB0aXRsZSk7IC8vIERPIE5PVCBVU0UgSVQuIElzIG9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndGl0bGUnKTtcbiAgICB9XG4gICAgX2VudGVyKCkge1xuICAgICAgaWYgKHRoaXMuX2lzU2hvd24oKSB8fCB0aGlzLl9pc0hvdmVyZWQpIHtcbiAgICAgICAgdGhpcy5faXNIb3ZlcmVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5faXNIb3ZlcmVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3NldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5faXNIb3ZlcmVkKSB7XG4gICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMuX2NvbmZpZy5kZWxheS5zaG93KTtcbiAgICB9XG4gICAgX2xlYXZlKCkge1xuICAgICAgaWYgKHRoaXMuX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9pc0hvdmVyZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3NldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuX2lzSG92ZXJlZCkge1xuICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzLl9jb25maWcuZGVsYXkuaGlkZSk7XG4gICAgfVxuICAgIF9zZXRUaW1lb3V0KGhhbmRsZXIsIHRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGhhbmRsZXIsIHRpbWVvdXQpO1xuICAgIH1cbiAgICBfaXNXaXRoQWN0aXZlVHJpZ2dlcigpIHtcbiAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuX2FjdGl2ZVRyaWdnZXIpLmluY2x1ZGVzKHRydWUpO1xuICAgIH1cbiAgICBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgICAgY29uc3QgZGF0YUF0dHJpYnV0ZXMgPSBNYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICAgIGZvciAoY29uc3QgZGF0YUF0dHJpYnV0ZSBvZiBPYmplY3Qua2V5cyhkYXRhQXR0cmlidXRlcykpIHtcbiAgICAgICAgaWYgKERJU0FMTE9XRURfQVRUUklCVVRFUy5oYXMoZGF0YUF0dHJpYnV0ZSkpIHtcbiAgICAgICAgICBkZWxldGUgZGF0YUF0dHJpYnV0ZXNbZGF0YUF0dHJpYnV0ZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgLi4uZGF0YUF0dHJpYnV0ZXMsXG4gICAgICAgIC4uLih0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiBjb25maWcgPyBjb25maWcgOiB7fSlcbiAgICAgIH07XG4gICAgICBjb25maWcgPSB0aGlzLl9tZXJnZUNvbmZpZ09iaihjb25maWcpO1xuICAgICAgY29uZmlnID0gdGhpcy5fY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpO1xuICAgICAgdGhpcy5fdHlwZUNoZWNrQ29uZmlnKGNvbmZpZyk7XG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cbiAgICBfY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpIHtcbiAgICAgIGNvbmZpZy5jb250YWluZXIgPSBjb25maWcuY29udGFpbmVyID09PSBmYWxzZSA/IGRvY3VtZW50LmJvZHkgOiBnZXRFbGVtZW50KGNvbmZpZy5jb250YWluZXIpO1xuICAgICAgaWYgKHR5cGVvZiBjb25maWcuZGVsYXkgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbmZpZy5kZWxheSA9IHtcbiAgICAgICAgICBzaG93OiBjb25maWcuZGVsYXksXG4gICAgICAgICAgaGlkZTogY29uZmlnLmRlbGF5XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy50aXRsZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uZmlnLnRpdGxlID0gY29uZmlnLnRpdGxlLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy5jb250ZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25maWcuY29udGVudCA9IGNvbmZpZy5jb250ZW50LnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cbiAgICBfZ2V0RGVsZWdhdGVDb25maWcoKSB7XG4gICAgICBjb25zdCBjb25maWcgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuX2NvbmZpZykpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFtrZXldICE9PSB2YWx1ZSkge1xuICAgICAgICAgIGNvbmZpZ1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbmZpZy5zZWxlY3RvciA9IGZhbHNlO1xuICAgICAgY29uZmlnLnRyaWdnZXIgPSAnbWFudWFsJztcblxuICAgICAgLy8gSW4gdGhlIGZ1dHVyZSBjYW4gYmUgcmVwbGFjZWQgd2l0aDpcbiAgICAgIC8vIGNvbnN0IGtleXNXaXRoRGlmZmVyZW50VmFsdWVzID0gT2JqZWN0LmVudHJpZXModGhpcy5fY29uZmlnKS5maWx0ZXIoZW50cnkgPT4gdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0W2VudHJ5WzBdXSAhPT0gdGhpcy5fY29uZmlnW2VudHJ5WzBdXSlcbiAgICAgIC8vIGBPYmplY3QuZnJvbUVudHJpZXMoa2V5c1dpdGhEaWZmZXJlbnRWYWx1ZXMpYFxuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG4gICAgX2Rpc3Bvc2VQb3BwZXIoKSB7XG4gICAgICBpZiAodGhpcy5fcG9wcGVyKSB7XG4gICAgICAgIHRoaXMuX3BvcHBlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX3BvcHBlciA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50aXApIHtcbiAgICAgICAgdGhpcy50aXAucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMudGlwID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTdGF0aWNcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBUb29sdGlwLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogalF1ZXJ5XG4gICAqL1xuXG4gIGRlZmluZUpRdWVyeVBsdWdpbihUb29sdGlwKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwIHBvcG92ZXIuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIENvbnN0YW50c1xuICAgKi9cblxuICBjb25zdCBOQU1FJDMgPSAncG9wb3Zlcic7XG4gIGNvbnN0IFNFTEVDVE9SX1RJVExFID0gJy5wb3BvdmVyLWhlYWRlcic7XG4gIGNvbnN0IFNFTEVDVE9SX0NPTlRFTlQgPSAnLnBvcG92ZXItYm9keSc7XG4gIGNvbnN0IERlZmF1bHQkMiA9IHtcbiAgICAuLi5Ub29sdGlwLkRlZmF1bHQsXG4gICAgY29udGVudDogJycsXG4gICAgb2Zmc2V0OiBbMCwgOF0sXG4gICAgcGxhY2VtZW50OiAncmlnaHQnLFxuICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInBvcG92ZXJcIiByb2xlPVwidG9vbHRpcFwiPicgKyAnPGRpdiBjbGFzcz1cInBvcG92ZXItYXJyb3dcIj48L2Rpdj4nICsgJzxoMyBjbGFzcz1cInBvcG92ZXItaGVhZGVyXCI+PC9oMz4nICsgJzxkaXYgY2xhc3M9XCJwb3BvdmVyLWJvZHlcIj48L2Rpdj4nICsgJzwvZGl2PicsXG4gICAgdHJpZ2dlcjogJ2NsaWNrJ1xuICB9O1xuICBjb25zdCBEZWZhdWx0VHlwZSQyID0ge1xuICAgIC4uLlRvb2x0aXAuRGVmYXVsdFR5cGUsXG4gICAgY29udGVudDogJyhudWxsfHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKSdcbiAgfTtcblxuICAvKipcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxuICAgKi9cblxuICBjbGFzcyBQb3BvdmVyIGV4dGVuZHMgVG9vbHRpcCB7XG4gICAgLy8gR2V0dGVyc1xuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0JDI7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkMjtcbiAgICB9XG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgcmV0dXJuIE5BTUUkMztcbiAgICB9XG5cbiAgICAvLyBPdmVycmlkZXNcbiAgICBfaXNXaXRoQ29udGVudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRUaXRsZSgpIHx8IHRoaXMuX2dldENvbnRlbnQoKTtcbiAgICB9XG5cbiAgICAvLyBQcml2YXRlXG4gICAgX2dldENvbnRlbnRGb3JUZW1wbGF0ZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFtTRUxFQ1RPUl9USVRMRV06IHRoaXMuX2dldFRpdGxlKCksXG4gICAgICAgIFtTRUxFQ1RPUl9DT05URU5UXTogdGhpcy5fZ2V0Q29udGVudCgpXG4gICAgICB9O1xuICAgIH1cbiAgICBfZ2V0Q29udGVudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0aGlzLl9jb25maWcuY29udGVudCk7XG4gICAgfVxuXG4gICAgLy8gU3RhdGljXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gUG9wb3Zlci5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGpRdWVyeVxuICAgKi9cblxuICBkZWZpbmVKUXVlcnlQbHVnaW4oUG9wb3Zlcik7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCBzY3JvbGxzcHkuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIENvbnN0YW50c1xuICAgKi9cblxuICBjb25zdCBOQU1FJDIgPSAnc2Nyb2xsc3B5JztcbiAgY29uc3QgREFUQV9LRVkkMiA9ICdicy5zY3JvbGxzcHknO1xuICBjb25zdCBFVkVOVF9LRVkkMiA9IGAuJHtEQVRBX0tFWSQyfWA7XG4gIGNvbnN0IERBVEFfQVBJX0tFWSA9ICcuZGF0YS1hcGknO1xuICBjb25zdCBFVkVOVF9BQ1RJVkFURSA9IGBhY3RpdmF0ZSR7RVZFTlRfS0VZJDJ9YDtcbiAgY29uc3QgRVZFTlRfQ0xJQ0sgPSBgY2xpY2ske0VWRU5UX0tFWSQyfWA7XG4gIGNvbnN0IEVWRU5UX0xPQURfREFUQV9BUEkkMSA9IGBsb2FkJHtFVkVOVF9LRVkkMn0ke0RBVEFfQVBJX0tFWX1gO1xuICBjb25zdCBDTEFTU19OQU1FX0RST1BET1dOX0lURU0gPSAnZHJvcGRvd24taXRlbSc7XG4gIGNvbnN0IENMQVNTX05BTUVfQUNUSVZFJDEgPSAnYWN0aXZlJztcbiAgY29uc3QgU0VMRUNUT1JfREFUQV9TUFkgPSAnW2RhdGEtYnMtc3B5PVwic2Nyb2xsXCJdJztcbiAgY29uc3QgU0VMRUNUT1JfVEFSR0VUX0xJTktTID0gJ1tocmVmXSc7XG4gIGNvbnN0IFNFTEVDVE9SX05BVl9MSVNUX0dST1VQID0gJy5uYXYsIC5saXN0LWdyb3VwJztcbiAgY29uc3QgU0VMRUNUT1JfTkFWX0xJTktTID0gJy5uYXYtbGluayc7XG4gIGNvbnN0IFNFTEVDVE9SX05BVl9JVEVNUyA9ICcubmF2LWl0ZW0nO1xuICBjb25zdCBTRUxFQ1RPUl9MSVNUX0lURU1TID0gJy5saXN0LWdyb3VwLWl0ZW0nO1xuICBjb25zdCBTRUxFQ1RPUl9MSU5LX0lURU1TID0gYCR7U0VMRUNUT1JfTkFWX0xJTktTfSwgJHtTRUxFQ1RPUl9OQVZfSVRFTVN9ID4gJHtTRUxFQ1RPUl9OQVZfTElOS1N9LCAke1NFTEVDVE9SX0xJU1RfSVRFTVN9YDtcbiAgY29uc3QgU0VMRUNUT1JfRFJPUERPV04gPSAnLmRyb3Bkb3duJztcbiAgY29uc3QgU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFJDEgPSAnLmRyb3Bkb3duLXRvZ2dsZSc7XG4gIGNvbnN0IERlZmF1bHQkMSA9IHtcbiAgICBvZmZzZXQ6IG51bGwsXG4gICAgLy8gVE9ETzogdjYgQGRlcHJlY2F0ZWQsIGtlZXAgaXQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHJlYXNvbnNcbiAgICByb290TWFyZ2luOiAnMHB4IDBweCAtMjUlJyxcbiAgICBzbW9vdGhTY3JvbGw6IGZhbHNlLFxuICAgIHRhcmdldDogbnVsbCxcbiAgICB0aHJlc2hvbGQ6IFswLjEsIDAuNSwgMV1cbiAgfTtcbiAgY29uc3QgRGVmYXVsdFR5cGUkMSA9IHtcbiAgICBvZmZzZXQ6ICcobnVtYmVyfG51bGwpJyxcbiAgICAvLyBUT0RPIHY2IEBkZXByZWNhdGVkLCBrZWVwIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSByZWFzb25zXG4gICAgcm9vdE1hcmdpbjogJ3N0cmluZycsXG4gICAgc21vb3RoU2Nyb2xsOiAnYm9vbGVhbicsXG4gICAgdGFyZ2V0OiAnZWxlbWVudCcsXG4gICAgdGhyZXNob2xkOiAnYXJyYXknXG4gIH07XG5cbiAgLyoqXG4gICAqIENsYXNzIGRlZmluaXRpb25cbiAgICovXG5cbiAgY2xhc3MgU2Nyb2xsU3B5IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xuXG4gICAgICAvLyB0aGlzLl9lbGVtZW50IGlzIHRoZSBvYnNlcnZhYmxlc0NvbnRhaW5lciBhbmQgY29uZmlnLnRhcmdldCB0aGUgbWVudSBsaW5rcyB3cmFwcGVyXG4gICAgICB0aGlzLl90YXJnZXRMaW5rcyA9IG5ldyBNYXAoKTtcbiAgICAgIHRoaXMuX29ic2VydmFibGVTZWN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9lbGVtZW50KS5vdmVyZmxvd1kgPT09ICd2aXNpYmxlJyA/IG51bGwgOiB0aGlzLl9lbGVtZW50O1xuICAgICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gbnVsbDtcbiAgICAgIHRoaXMuX29ic2VydmVyID0gbnVsbDtcbiAgICAgIHRoaXMuX3ByZXZpb3VzU2Nyb2xsRGF0YSA9IHtcbiAgICAgICAgdmlzaWJsZUVudHJ5VG9wOiAwLFxuICAgICAgICBwYXJlbnRTY3JvbGxUb3A6IDBcbiAgICAgIH07XG4gICAgICB0aGlzLnJlZnJlc2goKTsgLy8gaW5pdGlhbGl6ZVxuICAgIH1cblxuICAgIC8vIEdldHRlcnNcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdCQxO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDE7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICAgIHJldHVybiBOQU1FJDI7XG4gICAgfVxuXG4gICAgLy8gUHVibGljXG4gICAgcmVmcmVzaCgpIHtcbiAgICAgIHRoaXMuX2luaXRpYWxpemVUYXJnZXRzQW5kT2JzZXJ2YWJsZXMoKTtcbiAgICAgIHRoaXMuX21heWJlRW5hYmxlU21vb3RoU2Nyb2xsKCk7XG4gICAgICBpZiAodGhpcy5fb2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSB0aGlzLl9nZXROZXdPYnNlcnZlcigpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBzZWN0aW9uIG9mIHRoaXMuX29ic2VydmFibGVTZWN0aW9ucy52YWx1ZXMoKSkge1xuICAgICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHNlY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIC8vIFByaXZhdGVcbiAgICBfY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpIHtcbiAgICAgIC8vIFRPRE86IG9uIHY2IHRhcmdldCBzaG91bGQgYmUgZ2l2ZW4gZXhwbGljaXRseSAmIHJlbW92ZSB0aGUge3RhcmdldDogJ3NzLXRhcmdldCd9IGNhc2VcbiAgICAgIGNvbmZpZy50YXJnZXQgPSBnZXRFbGVtZW50KGNvbmZpZy50YXJnZXQpIHx8IGRvY3VtZW50LmJvZHk7XG5cbiAgICAgIC8vIFRPRE86IHY2IE9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHJlYXNvbnMuIFVzZSByb290TWFyZ2luIG9ubHlcbiAgICAgIGNvbmZpZy5yb290TWFyZ2luID0gY29uZmlnLm9mZnNldCA/IGAke2NvbmZpZy5vZmZzZXR9cHggMHB4IC0zMCVgIDogY29uZmlnLnJvb3RNYXJnaW47XG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy50aHJlc2hvbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbmZpZy50aHJlc2hvbGQgPSBjb25maWcudGhyZXNob2xkLnNwbGl0KCcsJykubWFwKHZhbHVlID0+IE51bWJlci5wYXJzZUZsb2F0KHZhbHVlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cbiAgICBfbWF5YmVFbmFibGVTbW9vdGhTY3JvbGwoKSB7XG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5zbW9vdGhTY3JvbGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyB1bnJlZ2lzdGVyIGFueSBwcmV2aW91cyBsaXN0ZW5lcnNcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fY29uZmlnLnRhcmdldCwgRVZFTlRfQ0xJQ0spO1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2NvbmZpZy50YXJnZXQsIEVWRU5UX0NMSUNLLCBTRUxFQ1RPUl9UQVJHRVRfTElOS1MsIGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3Qgb2JzZXJ2YWJsZVNlY3Rpb24gPSB0aGlzLl9vYnNlcnZhYmxlU2VjdGlvbnMuZ2V0KGV2ZW50LnRhcmdldC5oYXNoKTtcbiAgICAgICAgaWYgKG9ic2VydmFibGVTZWN0aW9uKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBjb25zdCByb290ID0gdGhpcy5fcm9vdEVsZW1lbnQgfHwgd2luZG93O1xuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IG9ic2VydmFibGVTZWN0aW9uLm9mZnNldFRvcCAtIHRoaXMuX2VsZW1lbnQub2Zmc2V0VG9wO1xuICAgICAgICAgIGlmIChyb290LnNjcm9sbFRvKSB7XG4gICAgICAgICAgICByb290LnNjcm9sbFRvKHtcbiAgICAgICAgICAgICAgdG9wOiBoZWlnaHQsXG4gICAgICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ2hyb21lIDYwIGRvZXNuJ3Qgc3VwcG9ydCBgc2Nyb2xsVG9gXG4gICAgICAgICAgcm9vdC5zY3JvbGxUb3AgPSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0TmV3T2JzZXJ2ZXIoKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICByb290OiB0aGlzLl9yb290RWxlbWVudCxcbiAgICAgICAgdGhyZXNob2xkOiB0aGlzLl9jb25maWcudGhyZXNob2xkLFxuICAgICAgICByb290TWFyZ2luOiB0aGlzLl9jb25maWcucm9vdE1hcmdpblxuICAgICAgfTtcbiAgICAgIHJldHVybiBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB0aGlzLl9vYnNlcnZlckNhbGxiYWNrKGVudHJpZXMpLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgbG9naWMgb2Ygc2VsZWN0aW9uXG4gICAgX29ic2VydmVyQ2FsbGJhY2soZW50cmllcykge1xuICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGVudHJ5ID0+IHRoaXMuX3RhcmdldExpbmtzLmdldChgIyR7ZW50cnkudGFyZ2V0LmlkfWApO1xuICAgICAgY29uc3QgYWN0aXZhdGUgPSBlbnRyeSA9PiB7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzU2Nyb2xsRGF0YS52aXNpYmxlRW50cnlUb3AgPSBlbnRyeS50YXJnZXQub2Zmc2V0VG9wO1xuICAgICAgICB0aGlzLl9wcm9jZXNzKHRhcmdldEVsZW1lbnQoZW50cnkpKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBwYXJlbnRTY3JvbGxUb3AgPSAodGhpcy5fcm9vdEVsZW1lbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5zY3JvbGxUb3A7XG4gICAgICBjb25zdCB1c2VyU2Nyb2xsc0Rvd24gPSBwYXJlbnRTY3JvbGxUb3AgPj0gdGhpcy5fcHJldmlvdXNTY3JvbGxEYXRhLnBhcmVudFNjcm9sbFRvcDtcbiAgICAgIHRoaXMuX3ByZXZpb3VzU2Nyb2xsRGF0YS5wYXJlbnRTY3JvbGxUb3AgPSBwYXJlbnRTY3JvbGxUb3A7XG4gICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgICAgaWYgKCFlbnRyeS5pc0ludGVyc2VjdGluZykge1xuICAgICAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fY2xlYXJBY3RpdmVDbGFzcyh0YXJnZXRFbGVtZW50KGVudHJ5KSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW50cnlJc0xvd2VyVGhhblByZXZpb3VzID0gZW50cnkudGFyZ2V0Lm9mZnNldFRvcCA+PSB0aGlzLl9wcmV2aW91c1Njcm9sbERhdGEudmlzaWJsZUVudHJ5VG9wO1xuICAgICAgICAvLyBpZiB3ZSBhcmUgc2Nyb2xsaW5nIGRvd24sIHBpY2sgdGhlIGJpZ2dlciBvZmZzZXRUb3BcbiAgICAgICAgaWYgKHVzZXJTY3JvbGxzRG93biAmJiBlbnRyeUlzTG93ZXJUaGFuUHJldmlvdXMpIHtcbiAgICAgICAgICBhY3RpdmF0ZShlbnRyeSk7XG4gICAgICAgICAgLy8gaWYgcGFyZW50IGlzbid0IHNjcm9sbGVkLCBsZXQncyBrZWVwIHRoZSBmaXJzdCB2aXNpYmxlIGl0ZW0sIGJyZWFraW5nIHRoZSBpdGVyYXRpb25cbiAgICAgICAgICBpZiAoIXBhcmVudFNjcm9sbFRvcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlIGFyZSBzY3JvbGxpbmcgdXAsIHBpY2sgdGhlIHNtYWxsZXN0IG9mZnNldFRvcFxuICAgICAgICBpZiAoIXVzZXJTY3JvbGxzRG93biAmJiAhZW50cnlJc0xvd2VyVGhhblByZXZpb3VzKSB7XG4gICAgICAgICAgYWN0aXZhdGUoZW50cnkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIF9pbml0aWFsaXplVGFyZ2V0c0FuZE9ic2VydmFibGVzKCkge1xuICAgICAgdGhpcy5fdGFyZ2V0TGlua3MgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLl9vYnNlcnZhYmxlU2VjdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICBjb25zdCB0YXJnZXRMaW5rcyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfVEFSR0VUX0xJTktTLCB0aGlzLl9jb25maWcudGFyZ2V0KTtcbiAgICAgIGZvciAoY29uc3QgYW5jaG9yIG9mIHRhcmdldExpbmtzKSB7XG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IHRoZSBhbmNob3IgaGFzIGFuIGlkIGFuZCBpcyBub3QgZGlzYWJsZWRcbiAgICAgICAgaWYgKCFhbmNob3IuaGFzaCB8fCBpc0Rpc2FibGVkKGFuY2hvcikpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvYnNlcnZhYmxlU2VjdGlvbiA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoZGVjb2RlVVJJKGFuY2hvci5oYXNoKSwgdGhpcy5fZWxlbWVudCk7XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIG9ic2VydmFibGVTZWN0aW9uIGV4aXN0cyAmIGlzIHZpc2libGVcbiAgICAgICAgaWYgKGlzVmlzaWJsZShvYnNlcnZhYmxlU2VjdGlvbikpIHtcbiAgICAgICAgICB0aGlzLl90YXJnZXRMaW5rcy5zZXQoZGVjb2RlVVJJKGFuY2hvci5oYXNoKSwgYW5jaG9yKTtcbiAgICAgICAgICB0aGlzLl9vYnNlcnZhYmxlU2VjdGlvbnMuc2V0KGFuY2hvci5oYXNoLCBvYnNlcnZhYmxlU2VjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgX3Byb2Nlc3ModGFyZ2V0KSB7XG4gICAgICBpZiAodGhpcy5fYWN0aXZlVGFyZ2V0ID09PSB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fY2xlYXJBY3RpdmVDbGFzcyh0aGlzLl9jb25maWcudGFyZ2V0KTtcbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IHRhcmdldDtcbiAgICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDEpO1xuICAgICAgdGhpcy5fYWN0aXZhdGVQYXJlbnRzKHRhcmdldCk7XG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9BQ1RJVkFURSwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0YXJnZXRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBfYWN0aXZhdGVQYXJlbnRzKHRhcmdldCkge1xuICAgICAgLy8gQWN0aXZhdGUgZHJvcGRvd24gcGFyZW50c1xuICAgICAgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QRE9XTl9JVEVNKSkge1xuICAgICAgICBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSQxLCB0YXJnZXQuY2xvc2VzdChTRUxFQ1RPUl9EUk9QRE9XTikpLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgbGlzdEdyb3VwIG9mIFNlbGVjdG9yRW5naW5lLnBhcmVudHModGFyZ2V0LCBTRUxFQ1RPUl9OQVZfTElTVF9HUk9VUCkpIHtcbiAgICAgICAgLy8gU2V0IHRyaWdnZXJlZCBsaW5rcyBwYXJlbnRzIGFzIGFjdGl2ZVxuICAgICAgICAvLyBXaXRoIGJvdGggPHVsPiBhbmQgPG5hdj4gbWFya3VwIGEgcGFyZW50IGlzIHRoZSBwcmV2aW91cyBzaWJsaW5nIG9mIGFueSBuYXYgYW5jZXN0b3JcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIFNlbGVjdG9yRW5naW5lLnByZXYobGlzdEdyb3VwLCBTRUxFQ1RPUl9MSU5LX0lURU1TKSkge1xuICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSQxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBfY2xlYXJBY3RpdmVDbGFzcyhwYXJlbnQpIHtcbiAgICAgIHBhcmVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFJDEpO1xuICAgICAgY29uc3QgYWN0aXZlTm9kZXMgPSBTZWxlY3RvckVuZ2luZS5maW5kKGAke1NFTEVDVE9SX1RBUkdFVF9MSU5LU30uJHtDTEFTU19OQU1FX0FDVElWRSQxfWAsIHBhcmVudCk7XG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgYWN0aXZlTm9kZXMpIHtcbiAgICAgICAgbm9kZS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFJDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0YXRpY1xuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IFNjcm9sbFNweS5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQgfHwgY29uZmlnLnN0YXJ0c1dpdGgoJ18nKSB8fCBjb25maWcgPT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gICAqL1xuXG4gIEV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX0xPQURfREFUQV9BUEkkMSwgKCkgPT4ge1xuICAgIGZvciAoY29uc3Qgc3B5IG9mIFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfREFUQV9TUFkpKSB7XG4gICAgICBTY3JvbGxTcHkuZ2V0T3JDcmVhdGVJbnN0YW5jZShzcHkpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIGpRdWVyeVxuICAgKi9cblxuICBkZWZpbmVKUXVlcnlQbHVnaW4oU2Nyb2xsU3B5KTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwIHRhYi5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cblxuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IE5BTUUkMSA9ICd0YWInO1xuICBjb25zdCBEQVRBX0tFWSQxID0gJ2JzLnRhYic7XG4gIGNvbnN0IEVWRU5UX0tFWSQxID0gYC4ke0RBVEFfS0VZJDF9YDtcbiAgY29uc3QgRVZFTlRfSElERSQxID0gYGhpZGUke0VWRU5UX0tFWSQxfWA7XG4gIGNvbnN0IEVWRU5UX0hJRERFTiQxID0gYGhpZGRlbiR7RVZFTlRfS0VZJDF9YDtcbiAgY29uc3QgRVZFTlRfU0hPVyQxID0gYHNob3cke0VWRU5UX0tFWSQxfWA7XG4gIGNvbnN0IEVWRU5UX1NIT1dOJDEgPSBgc2hvd24ke0VWRU5UX0tFWSQxfWA7XG4gIGNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJID0gYGNsaWNrJHtFVkVOVF9LRVkkMX1gO1xuICBjb25zdCBFVkVOVF9LRVlET1dOID0gYGtleWRvd24ke0VWRU5UX0tFWSQxfWA7XG4gIGNvbnN0IEVWRU5UX0xPQURfREFUQV9BUEkgPSBgbG9hZCR7RVZFTlRfS0VZJDF9YDtcbiAgY29uc3QgQVJST1dfTEVGVF9LRVkgPSAnQXJyb3dMZWZ0JztcbiAgY29uc3QgQVJST1dfUklHSFRfS0VZID0gJ0Fycm93UmlnaHQnO1xuICBjb25zdCBBUlJPV19VUF9LRVkgPSAnQXJyb3dVcCc7XG4gIGNvbnN0IEFSUk9XX0RPV05fS0VZID0gJ0Fycm93RG93bic7XG4gIGNvbnN0IEhPTUVfS0VZID0gJ0hvbWUnO1xuICBjb25zdCBFTkRfS0VZID0gJ0VuZCc7XG4gIGNvbnN0IENMQVNTX05BTUVfQUNUSVZFID0gJ2FjdGl2ZSc7XG4gIGNvbnN0IENMQVNTX05BTUVfRkFERSQxID0gJ2ZhZGUnO1xuICBjb25zdCBDTEFTU19OQU1FX1NIT1ckMSA9ICdzaG93JztcbiAgY29uc3QgQ0xBU1NfRFJPUERPV04gPSAnZHJvcGRvd24nO1xuICBjb25zdCBTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUgPSAnLmRyb3Bkb3duLXRvZ2dsZSc7XG4gIGNvbnN0IFNFTEVDVE9SX0RST1BET1dOX01FTlUgPSAnLmRyb3Bkb3duLW1lbnUnO1xuICBjb25zdCBOT1RfU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFID0gYDpub3QoJHtTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEV9KWA7XG4gIGNvbnN0IFNFTEVDVE9SX1RBQl9QQU5FTCA9ICcubGlzdC1ncm91cCwgLm5hdiwgW3JvbGU9XCJ0YWJsaXN0XCJdJztcbiAgY29uc3QgU0VMRUNUT1JfT1VURVIgPSAnLm5hdi1pdGVtLCAubGlzdC1ncm91cC1pdGVtJztcbiAgY29uc3QgU0VMRUNUT1JfSU5ORVIgPSBgLm5hdi1saW5rJHtOT1RfU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFfSwgLmxpc3QtZ3JvdXAtaXRlbSR7Tk9UX1NFTEVDVE9SX0RST1BET1dOX1RPR0dMRX0sIFtyb2xlPVwidGFiXCJdJHtOT1RfU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFfWA7XG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFID0gJ1tkYXRhLWJzLXRvZ2dsZT1cInRhYlwiXSwgW2RhdGEtYnMtdG9nZ2xlPVwicGlsbFwiXSwgW2RhdGEtYnMtdG9nZ2xlPVwibGlzdFwiXSc7IC8vIFRPRE86IGNvdWxkIG9ubHkgYmUgYHRhYmAgaW4gdjZcbiAgY29uc3QgU0VMRUNUT1JfSU5ORVJfRUxFTSA9IGAke1NFTEVDVE9SX0lOTkVSfSwgJHtTRUxFQ1RPUl9EQVRBX1RPR0dMRX1gO1xuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRV9BQ1RJVkUgPSBgLiR7Q0xBU1NfTkFNRV9BQ1RJVkV9W2RhdGEtYnMtdG9nZ2xlPVwidGFiXCJdLCAuJHtDTEFTU19OQU1FX0FDVElWRX1bZGF0YS1icy10b2dnbGU9XCJwaWxsXCJdLCAuJHtDTEFTU19OQU1FX0FDVElWRX1bZGF0YS1icy10b2dnbGU9XCJsaXN0XCJdYDtcblxuICAvKipcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxuICAgKi9cblxuICBjbGFzcyBUYWIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XG4gICAgICBzdXBlcihlbGVtZW50KTtcbiAgICAgIHRoaXMuX3BhcmVudCA9IHRoaXMuX2VsZW1lbnQuY2xvc2VzdChTRUxFQ1RPUl9UQUJfUEFORUwpO1xuICAgICAgaWYgKCF0aGlzLl9wYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBUT0RPOiBzaG91bGQgdGhyb3cgZXhjZXB0aW9uIGluIHY2XG4gICAgICAgIC8vIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7ZWxlbWVudC5vdXRlckhUTUx9IGhhcyBub3QgYSB2YWxpZCBwYXJlbnQgJHtTRUxFQ1RPUl9JTk5FUl9FTEVNfWApXG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB1cCBpbml0aWFsIGFyaWEgYXR0cmlidXRlc1xuICAgICAgdGhpcy5fc2V0SW5pdGlhbEF0dHJpYnV0ZXModGhpcy5fcGFyZW50LCB0aGlzLl9nZXRDaGlsZHJlbigpKTtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVlET1dOLCBldmVudCA9PiB0aGlzLl9rZXlkb3duKGV2ZW50KSk7XG4gICAgfVxuXG4gICAgLy8gR2V0dGVyc1xuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICAgIHJldHVybiBOQU1FJDE7XG4gICAgfVxuXG4gICAgLy8gUHVibGljXG4gICAgc2hvdygpIHtcbiAgICAgIC8vIFNob3dzIHRoaXMgZWxlbSBhbmQgZGVhY3RpdmF0ZSB0aGUgYWN0aXZlIHNpYmxpbmcgaWYgZXhpc3RzXG4gICAgICBjb25zdCBpbm5lckVsZW0gPSB0aGlzLl9lbGVtZW50O1xuICAgICAgaWYgKHRoaXMuX2VsZW1Jc0FjdGl2ZShpbm5lckVsZW0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gU2VhcmNoIGZvciBhY3RpdmUgdGFiIG9uIHNhbWUgcGFyZW50IHRvIGRlYWN0aXZhdGUgaXRcbiAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2dldEFjdGl2ZUVsZW0oKTtcbiAgICAgIGNvbnN0IGhpZGVFdmVudCA9IGFjdGl2ZSA/IEV2ZW50SGFuZGxlci50cmlnZ2VyKGFjdGl2ZSwgRVZFTlRfSElERSQxLCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IGlubmVyRWxlbVxuICAgICAgfSkgOiBudWxsO1xuICAgICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIoaW5uZXJFbGVtLCBFVkVOVF9TSE9XJDEsIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogYWN0aXZlXG4gICAgICB9KTtcbiAgICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCB8fCBoaWRlRXZlbnQgJiYgaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fZGVhY3RpdmF0ZShhY3RpdmUsIGlubmVyRWxlbSk7XG4gICAgICB0aGlzLl9hY3RpdmF0ZShpbm5lckVsZW0sIGFjdGl2ZSk7XG4gICAgfVxuXG4gICAgLy8gUHJpdmF0ZVxuICAgIF9hY3RpdmF0ZShlbGVtZW50LCByZWxhdGVkRWxlbSkge1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSk7XG4gICAgICB0aGlzLl9hY3RpdmF0ZShTZWxlY3RvckVuZ2luZS5nZXRFbGVtZW50RnJvbVNlbGVjdG9yKGVsZW1lbnQpKTsgLy8gU2VhcmNoIGFuZCBhY3RpdmF0ZS9zaG93IHRoZSBwcm9wZXIgc2VjdGlvblxuXG4gICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyb2xlJykgIT09ICd0YWInKSB7XG4gICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3RvZ2dsZURyb3BEb3duKGVsZW1lbnQsIHRydWUpO1xuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcihlbGVtZW50LCBFVkVOVF9TSE9XTiQxLCB7XG4gICAgICAgICAgcmVsYXRlZFRhcmdldDogcmVsYXRlZEVsZW1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgZWxlbWVudCwgZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFJDEpKTtcbiAgICB9XG4gICAgX2RlYWN0aXZhdGUoZWxlbWVudCwgcmVsYXRlZEVsZW0pIHtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUpO1xuICAgICAgZWxlbWVudC5ibHVyKCk7XG4gICAgICB0aGlzLl9kZWFjdGl2YXRlKFNlbGVjdG9yRW5naW5lLmdldEVsZW1lbnRGcm9tU2VsZWN0b3IoZWxlbWVudCkpOyAvLyBTZWFyY2ggYW5kIGRlYWN0aXZhdGUgdGhlIHNob3duIHNlY3Rpb24gdG9vXG5cbiAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSAhPT0gJ3RhYicpIHtcbiAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIGZhbHNlKTtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICAgIHRoaXMuX3RvZ2dsZURyb3BEb3duKGVsZW1lbnQsIGZhbHNlKTtcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIoZWxlbWVudCwgRVZFTlRfSElEREVOJDEsIHtcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0OiByZWxhdGVkRWxlbVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCBlbGVtZW50LCBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUkMSkpO1xuICAgIH1cbiAgICBfa2V5ZG93bihldmVudCkge1xuICAgICAgaWYgKCFbQVJST1dfTEVGVF9LRVksIEFSUk9XX1JJR0hUX0tFWSwgQVJST1dfVVBfS0VZLCBBUlJPV19ET1dOX0tFWSwgSE9NRV9LRVksIEVORF9LRVldLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIHN0b3BQcm9wYWdhdGlvbi9wcmV2ZW50RGVmYXVsdCBib3RoIGFkZGVkIHRvIHN1cHBvcnQgdXAvZG93biBrZXlzIHdpdGhvdXQgc2Nyb2xsaW5nIHRoZSBwYWdlXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9nZXRDaGlsZHJlbigpLmZpbHRlcihlbGVtZW50ID0+ICFpc0Rpc2FibGVkKGVsZW1lbnQpKTtcbiAgICAgIGxldCBuZXh0QWN0aXZlRWxlbWVudDtcbiAgICAgIGlmIChbSE9NRV9LRVksIEVORF9LRVldLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgICAgbmV4dEFjdGl2ZUVsZW1lbnQgPSBjaGlsZHJlbltldmVudC5rZXkgPT09IEhPTUVfS0VZID8gMCA6IGNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaXNOZXh0ID0gW0FSUk9XX1JJR0hUX0tFWSwgQVJST1dfRE9XTl9LRVldLmluY2x1ZGVzKGV2ZW50LmtleSk7XG4gICAgICAgIG5leHRBY3RpdmVFbGVtZW50ID0gZ2V0TmV4dEFjdGl2ZUVsZW1lbnQoY2hpbGRyZW4sIGV2ZW50LnRhcmdldCwgaXNOZXh0LCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXh0QWN0aXZlRWxlbWVudCkge1xuICAgICAgICBuZXh0QWN0aXZlRWxlbWVudC5mb2N1cyh7XG4gICAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgVGFiLmdldE9yQ3JlYXRlSW5zdGFuY2UobmV4dEFjdGl2ZUVsZW1lbnQpLnNob3coKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX2dldENoaWxkcmVuKCkge1xuICAgICAgLy8gY29sbGVjdGlvbiBvZiBpbm5lciBlbGVtZW50c1xuICAgICAgcmV0dXJuIFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfSU5ORVJfRUxFTSwgdGhpcy5fcGFyZW50KTtcbiAgICB9XG4gICAgX2dldEFjdGl2ZUVsZW0oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0Q2hpbGRyZW4oKS5maW5kKGNoaWxkID0+IHRoaXMuX2VsZW1Jc0FjdGl2ZShjaGlsZCkpIHx8IG51bGw7XG4gICAgfVxuICAgIF9zZXRJbml0aWFsQXR0cmlidXRlcyhwYXJlbnQsIGNoaWxkcmVuKSB7XG4gICAgICB0aGlzLl9zZXRBdHRyaWJ1dGVJZk5vdEV4aXN0cyhwYXJlbnQsICdyb2xlJywgJ3RhYmxpc3QnKTtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgdGhpcy5fc2V0SW5pdGlhbEF0dHJpYnV0ZXNPbkNoaWxkKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX3NldEluaXRpYWxBdHRyaWJ1dGVzT25DaGlsZChjaGlsZCkge1xuICAgICAgY2hpbGQgPSB0aGlzLl9nZXRJbm5lckVsZW1lbnQoY2hpbGQpO1xuICAgICAgY29uc3QgaXNBY3RpdmUgPSB0aGlzLl9lbGVtSXNBY3RpdmUoY2hpbGQpO1xuICAgICAgY29uc3Qgb3V0ZXJFbGVtID0gdGhpcy5fZ2V0T3V0ZXJFbGVtZW50KGNoaWxkKTtcbiAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIGlzQWN0aXZlKTtcbiAgICAgIGlmIChvdXRlckVsZW0gIT09IGNoaWxkKSB7XG4gICAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZUlmTm90RXhpc3RzKG91dGVyRWxlbSwgJ3JvbGUnLCAncHJlc2VudGF0aW9uJyk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZUlmTm90RXhpc3RzKGNoaWxkLCAncm9sZScsICd0YWInKTtcblxuICAgICAgLy8gc2V0IGF0dHJpYnV0ZXMgdG8gdGhlIHJlbGF0ZWQgcGFuZWwgdG9vXG4gICAgICB0aGlzLl9zZXRJbml0aWFsQXR0cmlidXRlc09uVGFyZ2V0UGFuZWwoY2hpbGQpO1xuICAgIH1cbiAgICBfc2V0SW5pdGlhbEF0dHJpYnV0ZXNPblRhcmdldFBhbmVsKGNoaWxkKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBTZWxlY3RvckVuZ2luZS5nZXRFbGVtZW50RnJvbVNlbGVjdG9yKGNoaWxkKTtcbiAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZUlmTm90RXhpc3RzKHRhcmdldCwgJ3JvbGUnLCAndGFicGFuZWwnKTtcbiAgICAgIGlmIChjaGlsZC5pZCkge1xuICAgICAgICB0aGlzLl9zZXRBdHRyaWJ1dGVJZk5vdEV4aXN0cyh0YXJnZXQsICdhcmlhLWxhYmVsbGVkYnknLCBgJHtjaGlsZC5pZH1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX3RvZ2dsZURyb3BEb3duKGVsZW1lbnQsIG9wZW4pIHtcbiAgICAgIGNvbnN0IG91dGVyRWxlbSA9IHRoaXMuX2dldE91dGVyRWxlbWVudChlbGVtZW50KTtcbiAgICAgIGlmICghb3V0ZXJFbGVtLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19EUk9QRE9XTikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdG9nZ2xlID0gKHNlbGVjdG9yLCBjbGFzc05hbWUpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoc2VsZWN0b3IsIG91dGVyRWxlbSk7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKGNsYXNzTmFtZSwgb3Blbik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0b2dnbGUoU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFLCBDTEFTU19OQU1FX0FDVElWRSk7XG4gICAgICB0b2dnbGUoU0VMRUNUT1JfRFJPUERPV05fTUVOVSwgQ0xBU1NfTkFNRV9TSE9XJDEpO1xuICAgICAgb3V0ZXJFbGVtLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIG9wZW4pO1xuICAgIH1cbiAgICBfc2V0QXR0cmlidXRlSWZOb3RFeGlzdHMoZWxlbWVudCwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgICAgaWYgKCFlbGVtZW50Lmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGUpKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBfZWxlbUlzQWN0aXZlKGVsZW0pIHtcbiAgICAgIHJldHVybiBlbGVtLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0FDVElWRSk7XG4gICAgfVxuXG4gICAgLy8gVHJ5IHRvIGdldCB0aGUgaW5uZXIgZWxlbWVudCAodXN1YWxseSB0aGUgLm5hdi1saW5rKVxuICAgIF9nZXRJbm5lckVsZW1lbnQoZWxlbSkge1xuICAgICAgcmV0dXJuIGVsZW0ubWF0Y2hlcyhTRUxFQ1RPUl9JTk5FUl9FTEVNKSA/IGVsZW0gOiBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0lOTkVSX0VMRU0sIGVsZW0pO1xuICAgIH1cblxuICAgIC8vIFRyeSB0byBnZXQgdGhlIG91dGVyIGVsZW1lbnQgKHVzdWFsbHkgdGhlIC5uYXYtaXRlbSlcbiAgICBfZ2V0T3V0ZXJFbGVtZW50KGVsZW0pIHtcbiAgICAgIHJldHVybiBlbGVtLmNsb3Nlc3QoU0VMRUNUT1JfT1VURVIpIHx8IGVsZW07XG4gICAgfVxuXG4gICAgLy8gU3RhdGljXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gVGFiLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcyk7XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQgfHwgY29uZmlnLnN0YXJ0c1dpdGgoJ18nKSB8fCBjb25maWcgPT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gICAqL1xuXG4gIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEksIFNFTEVDVE9SX0RBVEFfVE9HR0xFLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoWydBJywgJ0FSRUEnXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBpZiAoaXNEaXNhYmxlZCh0aGlzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBUYWIuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKS5zaG93KCk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIG9uIGZvY3VzXG4gICAqL1xuICBFdmVudEhhbmRsZXIub24od2luZG93LCBFVkVOVF9MT0FEX0RBVEFfQVBJLCAoKSA9PiB7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfREFUQV9UT0dHTEVfQUNUSVZFKSkge1xuICAgICAgVGFiLmdldE9yQ3JlYXRlSW5zdGFuY2UoZWxlbWVudCk7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIGpRdWVyeVxuICAgKi9cblxuICBkZWZpbmVKUXVlcnlQbHVnaW4oVGFiKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwIHRvYXN0LmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBDb25zdGFudHNcbiAgICovXG5cbiAgY29uc3QgTkFNRSA9ICd0b2FzdCc7XG4gIGNvbnN0IERBVEFfS0VZID0gJ2JzLnRvYXN0JztcbiAgY29uc3QgRVZFTlRfS0VZID0gYC4ke0RBVEFfS0VZfWA7XG4gIGNvbnN0IEVWRU5UX01PVVNFT1ZFUiA9IGBtb3VzZW92ZXIke0VWRU5UX0tFWX1gO1xuICBjb25zdCBFVkVOVF9NT1VTRU9VVCA9IGBtb3VzZW91dCR7RVZFTlRfS0VZfWA7XG4gIGNvbnN0IEVWRU5UX0ZPQ1VTSU4gPSBgZm9jdXNpbiR7RVZFTlRfS0VZfWA7XG4gIGNvbnN0IEVWRU5UX0ZPQ1VTT1VUID0gYGZvY3Vzb3V0JHtFVkVOVF9LRVl9YDtcbiAgY29uc3QgRVZFTlRfSElERSA9IGBoaWRlJHtFVkVOVF9LRVl9YDtcbiAgY29uc3QgRVZFTlRfSElEREVOID0gYGhpZGRlbiR7RVZFTlRfS0VZfWA7XG4gIGNvbnN0IEVWRU5UX1NIT1cgPSBgc2hvdyR7RVZFTlRfS0VZfWA7XG4gIGNvbnN0IEVWRU5UX1NIT1dOID0gYHNob3duJHtFVkVOVF9LRVl9YDtcbiAgY29uc3QgQ0xBU1NfTkFNRV9GQURFID0gJ2ZhZGUnO1xuICBjb25zdCBDTEFTU19OQU1FX0hJREUgPSAnaGlkZSc7IC8vIEBkZXByZWNhdGVkIC0ga2VwdCBoZXJlIG9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gIGNvbnN0IENMQVNTX05BTUVfU0hPVyA9ICdzaG93JztcbiAgY29uc3QgQ0xBU1NfTkFNRV9TSE9XSU5HID0gJ3Nob3dpbmcnO1xuICBjb25zdCBEZWZhdWx0VHlwZSA9IHtcbiAgICBhbmltYXRpb246ICdib29sZWFuJyxcbiAgICBhdXRvaGlkZTogJ2Jvb2xlYW4nLFxuICAgIGRlbGF5OiAnbnVtYmVyJ1xuICB9O1xuICBjb25zdCBEZWZhdWx0ID0ge1xuICAgIGFuaW1hdGlvbjogdHJ1ZSxcbiAgICBhdXRvaGlkZTogdHJ1ZSxcbiAgICBkZWxheTogNTAwMFxuICB9O1xuXG4gIC8qKlxuICAgKiBDbGFzcyBkZWZpbml0aW9uXG4gICAqL1xuXG4gIGNsYXNzIFRvYXN0IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xuICAgICAgdGhpcy5fdGltZW91dCA9IG51bGw7XG4gICAgICB0aGlzLl9oYXNNb3VzZUludGVyYWN0aW9uID0gZmFsc2U7XG4gICAgICB0aGlzLl9oYXNLZXlib2FyZEludGVyYWN0aW9uID0gZmFsc2U7XG4gICAgICB0aGlzLl9zZXRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICAvLyBHZXR0ZXJzXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgICAgcmV0dXJuIERlZmF1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGU7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICAgIHJldHVybiBOQU1FO1xuICAgIH1cblxuICAgIC8vIFB1YmxpY1xuICAgIHNob3coKSB7XG4gICAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XKTtcbiAgICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcbiAgICAgIGlmICh0aGlzLl9jb25maWcuYW5pbWF0aW9uKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0ZBREUpO1xuICAgICAgfVxuICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1dJTkcpO1xuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XTik7XG4gICAgICAgIHRoaXMuX21heWJlU2NoZWR1bGVIaWRlKCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfSElERSk7IC8vIEBkZXByZWNhdGVkXG4gICAgICByZWZsb3codGhpcy5fZWxlbWVudCk7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XLCBDTEFTU19OQU1FX1NIT1dJTkcpO1xuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy5fZWxlbWVudCwgdGhpcy5fY29uZmlnLmFuaW1hdGlvbik7XG4gICAgfVxuICAgIGhpZGUoKSB7XG4gICAgICBpZiAoIXRoaXMuaXNTaG93bigpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUpO1xuICAgICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9ISURFKTsgLy8gQGRlcHJlY2F0ZWRcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPV0lORywgQ0xBU1NfTkFNRV9TSE9XKTtcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOKTtcbiAgICAgIH07XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XSU5HKTtcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NvbmZpZy5hbmltYXRpb24pO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XG4gICAgICBpZiAodGhpcy5pc1Nob3duKCkpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyk7XG4gICAgICB9XG4gICAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGlzU2hvd24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XKTtcbiAgICB9XG5cbiAgICAvLyBQcml2YXRlXG5cbiAgICBfbWF5YmVTY2hlZHVsZUhpZGUoKSB7XG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5hdXRvaGlkZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5faGFzTW91c2VJbnRlcmFjdGlvbiB8fCB0aGlzLl9oYXNLZXlib2FyZEludGVyYWN0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9LCB0aGlzLl9jb25maWcuZGVsYXkpO1xuICAgIH1cbiAgICBfb25JbnRlcmFjdGlvbihldmVudCwgaXNJbnRlcmFjdGluZykge1xuICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ21vdXNlb3Zlcic6XG4gICAgICAgIGNhc2UgJ21vdXNlb3V0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9oYXNNb3VzZUludGVyYWN0aW9uID0gaXNJbnRlcmFjdGluZztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnZm9jdXNpbic6XG4gICAgICAgIGNhc2UgJ2ZvY3Vzb3V0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9oYXNLZXlib2FyZEludGVyYWN0aW9uID0gaXNJbnRlcmFjdGluZztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0ludGVyYWN0aW5nKSB7XG4gICAgICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBuZXh0RWxlbWVudCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgICBpZiAodGhpcy5fZWxlbWVudCA9PT0gbmV4dEVsZW1lbnQgfHwgdGhpcy5fZWxlbWVudC5jb250YWlucyhuZXh0RWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWF5YmVTY2hlZHVsZUhpZGUoKTtcbiAgICB9XG4gICAgX3NldExpc3RlbmVycygpIHtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9NT1VTRU9WRVIsIGV2ZW50ID0+IHRoaXMuX29uSW50ZXJhY3Rpb24oZXZlbnQsIHRydWUpKTtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9NT1VTRU9VVCwgZXZlbnQgPT4gdGhpcy5fb25JbnRlcmFjdGlvbihldmVudCwgZmFsc2UpKTtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9GT0NVU0lOLCBldmVudCA9PiB0aGlzLl9vbkludGVyYWN0aW9uKGV2ZW50LCB0cnVlKSk7XG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfRk9DVVNPVVQsIGV2ZW50ID0+IHRoaXMuX29uSW50ZXJhY3Rpb24oZXZlbnQsIGZhbHNlKSk7XG4gICAgfVxuICAgIF9jbGVhclRpbWVvdXQoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gICAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTdGF0aWNcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBUb2FzdC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YVtjb25maWddKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cbiAgICovXG5cbiAgZW5hYmxlRGlzbWlzc1RyaWdnZXIoVG9hc3QpO1xuXG4gIC8qKlxuICAgKiBqUXVlcnlcbiAgICovXG5cbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKFRvYXN0KTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwIGluZGV4LnVtZC5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgY29uc3QgaW5kZXhfdW1kID0ge1xuICAgIEFsZXJ0LFxuICAgIEJ1dHRvbixcbiAgICBDYXJvdXNlbCxcbiAgICBDb2xsYXBzZSxcbiAgICBEcm9wZG93bixcbiAgICBNb2RhbCxcbiAgICBPZmZjYW52YXMsXG4gICAgUG9wb3ZlcixcbiAgICBTY3JvbGxTcHksXG4gICAgVGFiLFxuICAgIFRvYXN0LFxuICAgIFRvb2x0aXBcbiAgfTtcblxuICByZXR1cm4gaW5kZXhfdW1kO1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib290c3RyYXAuanMubWFwXG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJyZXF1aXJlIiwiZGVmaW5lIiwiYW1kIiwiZ2xvYmFsVGhpcyIsInNlbGYiLCJib290c3RyYXAiLCJQb3BwZXIiLCJfaW50ZXJvcE5hbWVzcGFjZURlZmF1bHQiLCJlIiwibiIsIk9iamVjdCIsImNyZWF0ZSIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwidmFsdWUiLCJrIiwiZCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiZW51bWVyYWJsZSIsImRlZmF1bHQiLCJmcmVlemUiLCJQb3BwZXJfX25hbWVzcGFjZSIsImVsZW1lbnRNYXAiLCJNYXAiLCJEYXRhIiwic2V0IiwiZWxlbWVudCIsImtleSIsImluc3RhbmNlIiwiaGFzIiwiaW5zdGFuY2VNYXAiLCJzaXplIiwiY29uc29sZSIsImVycm9yIiwiQXJyYXkiLCJmcm9tIiwia2V5cyIsInJlbW92ZSIsImRlbGV0ZSIsIk1BWF9VSUQiLCJNSUxMSVNFQ09ORFNfTVVMVElQTElFUiIsIlRSQU5TSVRJT05fRU5EIiwicGFyc2VTZWxlY3RvciIsInNlbGVjdG9yIiwid2luZG93IiwiQ1NTIiwiZXNjYXBlIiwicmVwbGFjZSIsIm1hdGNoIiwiaWQiLCJ0b1R5cGUiLCJvYmplY3QiLCJ1bmRlZmluZWQiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJ0b0xvd2VyQ2FzZSIsImdldFVJRCIsInByZWZpeCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJnZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCIsInRyYW5zaXRpb25EdXJhdGlvbiIsInRyYW5zaXRpb25EZWxheSIsImdldENvbXB1dGVkU3R5bGUiLCJmbG9hdFRyYW5zaXRpb25EdXJhdGlvbiIsIk51bWJlciIsInBhcnNlRmxvYXQiLCJmbG9hdFRyYW5zaXRpb25EZWxheSIsInNwbGl0IiwidHJpZ2dlclRyYW5zaXRpb25FbmQiLCJkaXNwYXRjaEV2ZW50IiwiRXZlbnQiLCJpc0VsZW1lbnQiLCJqcXVlcnkiLCJub2RlVHlwZSIsImdldEVsZW1lbnQiLCJsZW5ndGgiLCJxdWVyeVNlbGVjdG9yIiwiaXNWaXNpYmxlIiwiZ2V0Q2xpZW50UmVjdHMiLCJlbGVtZW50SXNWaXNpYmxlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsImNsb3NlZERldGFpbHMiLCJjbG9zZXN0Iiwic3VtbWFyeSIsInBhcmVudE5vZGUiLCJpc0Rpc2FibGVkIiwiTm9kZSIsIkVMRU1FTlRfTk9ERSIsImNsYXNzTGlzdCIsImNvbnRhaW5zIiwiZGlzYWJsZWQiLCJoYXNBdHRyaWJ1dGUiLCJnZXRBdHRyaWJ1dGUiLCJmaW5kU2hhZG93Um9vdCIsImRvY3VtZW50RWxlbWVudCIsImF0dGFjaFNoYWRvdyIsImdldFJvb3ROb2RlIiwicm9vdCIsIlNoYWRvd1Jvb3QiLCJub29wIiwicmVmbG93Iiwib2Zmc2V0SGVpZ2h0IiwiZ2V0alF1ZXJ5IiwialF1ZXJ5IiwiYm9keSIsIkRPTUNvbnRlbnRMb2FkZWRDYWxsYmFja3MiLCJvbkRPTUNvbnRlbnRMb2FkZWQiLCJjYWxsYmFjayIsInJlYWR5U3RhdGUiLCJhZGRFdmVudExpc3RlbmVyIiwicHVzaCIsImlzUlRMIiwiZGlyIiwiZGVmaW5lSlF1ZXJ5UGx1Z2luIiwicGx1Z2luIiwiJCIsIm5hbWUiLCJOQU1FIiwiSlFVRVJZX05PX0NPTkZMSUNUIiwiZm4iLCJqUXVlcnlJbnRlcmZhY2UiLCJDb25zdHJ1Y3RvciIsIm5vQ29uZmxpY3QiLCJleGVjdXRlIiwicG9zc2libGVDYWxsYmFjayIsImFyZ3MiLCJkZWZhdWx0VmFsdWUiLCJleGVjdXRlQWZ0ZXJUcmFuc2l0aW9uIiwidHJhbnNpdGlvbkVsZW1lbnQiLCJ3YWl0Rm9yVHJhbnNpdGlvbiIsImR1cmF0aW9uUGFkZGluZyIsImVtdWxhdGVkRHVyYXRpb24iLCJjYWxsZWQiLCJoYW5kbGVyIiwidGFyZ2V0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInNldFRpbWVvdXQiLCJnZXROZXh0QWN0aXZlRWxlbWVudCIsImxpc3QiLCJhY3RpdmVFbGVtZW50Iiwic2hvdWxkR2V0TmV4dCIsImlzQ3ljbGVBbGxvd2VkIiwibGlzdExlbmd0aCIsImluZGV4IiwiaW5kZXhPZiIsIm1heCIsIm1pbiIsIm5hbWVzcGFjZVJlZ2V4Iiwic3RyaXBOYW1lUmVnZXgiLCJzdHJpcFVpZFJlZ2V4IiwiZXZlbnRSZWdpc3RyeSIsInVpZEV2ZW50IiwiY3VzdG9tRXZlbnRzIiwibW91c2VlbnRlciIsIm1vdXNlbGVhdmUiLCJuYXRpdmVFdmVudHMiLCJTZXQiLCJtYWtlRXZlbnRVaWQiLCJ1aWQiLCJnZXRFbGVtZW50RXZlbnRzIiwiYm9vdHN0cmFwSGFuZGxlciIsImV2ZW50IiwiaHlkcmF0ZU9iaiIsImRlbGVnYXRlVGFyZ2V0Iiwib25lT2ZmIiwiRXZlbnRIYW5kbGVyIiwib2ZmIiwidHlwZSIsImFwcGx5IiwiYm9vdHN0cmFwRGVsZWdhdGlvbkhhbmRsZXIiLCJkb21FbGVtZW50cyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJkb21FbGVtZW50IiwiZmluZEhhbmRsZXIiLCJldmVudHMiLCJjYWxsYWJsZSIsImRlbGVnYXRpb25TZWxlY3RvciIsInZhbHVlcyIsImZpbmQiLCJub3JtYWxpemVQYXJhbWV0ZXJzIiwib3JpZ2luYWxUeXBlRXZlbnQiLCJkZWxlZ2F0aW9uRnVuY3Rpb24iLCJpc0RlbGVnYXRlZCIsInR5cGVFdmVudCIsImdldFR5cGVFdmVudCIsImFkZEhhbmRsZXIiLCJ3cmFwRnVuY3Rpb24iLCJyZWxhdGVkVGFyZ2V0IiwiaGFuZGxlcnMiLCJwcmV2aW91c0Z1bmN0aW9uIiwicmVtb3ZlSGFuZGxlciIsIkJvb2xlYW4iLCJyZW1vdmVOYW1lc3BhY2VkSGFuZGxlcnMiLCJuYW1lc3BhY2UiLCJzdG9yZUVsZW1lbnRFdmVudCIsImhhbmRsZXJLZXkiLCJlbnRyaWVzIiwiaW5jbHVkZXMiLCJvbiIsIm9uZSIsImluTmFtZXNwYWNlIiwiaXNOYW1lc3BhY2UiLCJzdGFydHNXaXRoIiwiZWxlbWVudEV2ZW50Iiwic2xpY2UiLCJrZXlIYW5kbGVycyIsInRyaWdnZXIiLCJqUXVlcnlFdmVudCIsImJ1YmJsZXMiLCJuYXRpdmVEaXNwYXRjaCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsImlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkIiwiaXNEZWZhdWx0UHJldmVudGVkIiwiZXZ0IiwiY2FuY2VsYWJsZSIsInByZXZlbnREZWZhdWx0Iiwib2JqIiwibWV0YSIsIl91bnVzZWQiLCJjb25maWd1cmFibGUiLCJub3JtYWxpemVEYXRhIiwiSlNPTiIsInBhcnNlIiwiZGVjb2RlVVJJQ29tcG9uZW50Iiwibm9ybWFsaXplRGF0YUtleSIsImNociIsIk1hbmlwdWxhdG9yIiwic2V0RGF0YUF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsInJlbW92ZURhdGFBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJnZXREYXRhQXR0cmlidXRlcyIsImF0dHJpYnV0ZXMiLCJic0tleXMiLCJkYXRhc2V0IiwiZmlsdGVyIiwicHVyZUtleSIsImNoYXJBdCIsImdldERhdGFBdHRyaWJ1dGUiLCJDb25maWciLCJEZWZhdWx0IiwiRGVmYXVsdFR5cGUiLCJFcnJvciIsIl9nZXRDb25maWciLCJjb25maWciLCJfbWVyZ2VDb25maWdPYmoiLCJfY29uZmlnQWZ0ZXJNZXJnZSIsIl90eXBlQ2hlY2tDb25maWciLCJqc29uQ29uZmlnIiwiY29uc3RydWN0b3IiLCJjb25maWdUeXBlcyIsInByb3BlcnR5IiwiZXhwZWN0ZWRUeXBlcyIsInZhbHVlVHlwZSIsIlJlZ0V4cCIsInRlc3QiLCJUeXBlRXJyb3IiLCJ0b1VwcGVyQ2FzZSIsIlZFUlNJT04iLCJCYXNlQ29tcG9uZW50IiwiX2VsZW1lbnQiLCJfY29uZmlnIiwiREFUQV9LRVkiLCJkaXNwb3NlIiwiRVZFTlRfS0VZIiwicHJvcGVydHlOYW1lIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIl9xdWV1ZUNhbGxiYWNrIiwiaXNBbmltYXRlZCIsImdldEluc3RhbmNlIiwiZ2V0T3JDcmVhdGVJbnN0YW5jZSIsImV2ZW50TmFtZSIsImdldFNlbGVjdG9yIiwiaHJlZkF0dHJpYnV0ZSIsInRyaW0iLCJTZWxlY3RvckVuZ2luZSIsImNvbmNhdCIsIkVsZW1lbnQiLCJmaW5kT25lIiwiY2hpbGRyZW4iLCJjaGlsZCIsIm1hdGNoZXMiLCJwYXJlbnRzIiwiYW5jZXN0b3IiLCJwcmV2IiwicHJldmlvdXMiLCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwibmV4dCIsIm5leHRFbGVtZW50U2libGluZyIsImZvY3VzYWJsZUNoaWxkcmVuIiwiZm9jdXNhYmxlcyIsIm1hcCIsImpvaW4iLCJlbCIsImdldFNlbGVjdG9yRnJvbUVsZW1lbnQiLCJnZXRFbGVtZW50RnJvbVNlbGVjdG9yIiwiZ2V0TXVsdGlwbGVFbGVtZW50c0Zyb21TZWxlY3RvciIsImVuYWJsZURpc21pc3NUcmlnZ2VyIiwiY29tcG9uZW50IiwibWV0aG9kIiwiY2xpY2tFdmVudCIsInRhZ05hbWUiLCJOQU1FJGYiLCJEQVRBX0tFWSRhIiwiRVZFTlRfS0VZJGIiLCJFVkVOVF9DTE9TRSIsIkVWRU5UX0NMT1NFRCIsIkNMQVNTX05BTUVfRkFERSQ1IiwiQ0xBU1NfTkFNRV9TSE9XJDgiLCJBbGVydCIsImNsb3NlIiwiY2xvc2VFdmVudCIsIl9kZXN0cm95RWxlbWVudCIsImVhY2giLCJkYXRhIiwiTkFNRSRlIiwiREFUQV9LRVkkOSIsIkVWRU5UX0tFWSRhIiwiREFUQV9BUElfS0VZJDYiLCJDTEFTU19OQU1FX0FDVElWRSQzIiwiU0VMRUNUT1JfREFUQV9UT0dHTEUkNSIsIkVWRU5UX0NMSUNLX0RBVEFfQVBJJDYiLCJCdXR0b24iLCJ0b2dnbGUiLCJidXR0b24iLCJOQU1FJGQiLCJFVkVOVF9LRVkkOSIsIkVWRU5UX1RPVUNIU1RBUlQiLCJFVkVOVF9UT1VDSE1PVkUiLCJFVkVOVF9UT1VDSEVORCIsIkVWRU5UX1BPSU5URVJET1dOIiwiRVZFTlRfUE9JTlRFUlVQIiwiUE9JTlRFUl9UWVBFX1RPVUNIIiwiUE9JTlRFUl9UWVBFX1BFTiIsIkNMQVNTX05BTUVfUE9JTlRFUl9FVkVOVCIsIlNXSVBFX1RIUkVTSE9MRCIsIkRlZmF1bHQkYyIsImVuZENhbGxiYWNrIiwibGVmdENhbGxiYWNrIiwicmlnaHRDYWxsYmFjayIsIkRlZmF1bHRUeXBlJGMiLCJTd2lwZSIsImlzU3VwcG9ydGVkIiwiX2RlbHRhWCIsIl9zdXBwb3J0UG9pbnRlckV2ZW50cyIsIlBvaW50ZXJFdmVudCIsIl9pbml0RXZlbnRzIiwiX3N0YXJ0IiwidG91Y2hlcyIsImNsaWVudFgiLCJfZXZlbnRJc1BvaW50ZXJQZW5Ub3VjaCIsIl9lbmQiLCJfaGFuZGxlU3dpcGUiLCJfbW92ZSIsImFic0RlbHRhWCIsImFicyIsImRpcmVjdGlvbiIsImFkZCIsInBvaW50ZXJUeXBlIiwibmF2aWdhdG9yIiwibWF4VG91Y2hQb2ludHMiLCJOQU1FJGMiLCJEQVRBX0tFWSQ4IiwiRVZFTlRfS0VZJDgiLCJEQVRBX0FQSV9LRVkkNSIsIkFSUk9XX0xFRlRfS0VZJDEiLCJBUlJPV19SSUdIVF9LRVkkMSIsIlRPVUNIRVZFTlRfQ09NUEFUX1dBSVQiLCJPUkRFUl9ORVhUIiwiT1JERVJfUFJFViIsIkRJUkVDVElPTl9MRUZUIiwiRElSRUNUSU9OX1JJR0hUIiwiRVZFTlRfU0xJREUiLCJFVkVOVF9TTElEIiwiRVZFTlRfS0VZRE9XTiQxIiwiRVZFTlRfTU9VU0VFTlRFUiQxIiwiRVZFTlRfTU9VU0VMRUFWRSQxIiwiRVZFTlRfRFJBR19TVEFSVCIsIkVWRU5UX0xPQURfREFUQV9BUEkkMyIsIkVWRU5UX0NMSUNLX0RBVEFfQVBJJDUiLCJDTEFTU19OQU1FX0NBUk9VU0VMIiwiQ0xBU1NfTkFNRV9BQ1RJVkUkMiIsIkNMQVNTX05BTUVfU0xJREUiLCJDTEFTU19OQU1FX0VORCIsIkNMQVNTX05BTUVfU1RBUlQiLCJDTEFTU19OQU1FX05FWFQiLCJDTEFTU19OQU1FX1BSRVYiLCJTRUxFQ1RPUl9BQ1RJVkUiLCJTRUxFQ1RPUl9JVEVNIiwiU0VMRUNUT1JfQUNUSVZFX0lURU0iLCJTRUxFQ1RPUl9JVEVNX0lNRyIsIlNFTEVDVE9SX0lORElDQVRPUlMiLCJTRUxFQ1RPUl9EQVRBX1NMSURFIiwiU0VMRUNUT1JfREFUQV9SSURFIiwiS0VZX1RPX0RJUkVDVElPTiIsIkRlZmF1bHQkYiIsImludGVydmFsIiwia2V5Ym9hcmQiLCJwYXVzZSIsInJpZGUiLCJ0b3VjaCIsIndyYXAiLCJEZWZhdWx0VHlwZSRiIiwiQ2Fyb3VzZWwiLCJfaW50ZXJ2YWwiLCJfYWN0aXZlRWxlbWVudCIsIl9pc1NsaWRpbmciLCJ0b3VjaFRpbWVvdXQiLCJfc3dpcGVIZWxwZXIiLCJfaW5kaWNhdG9yc0VsZW1lbnQiLCJfYWRkRXZlbnRMaXN0ZW5lcnMiLCJjeWNsZSIsIl9zbGlkZSIsIm5leHRXaGVuVmlzaWJsZSIsImhpZGRlbiIsIl9jbGVhckludGVydmFsIiwiX3VwZGF0ZUludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJfbWF5YmVFbmFibGVDeWNsZSIsInRvIiwiaXRlbXMiLCJfZ2V0SXRlbXMiLCJhY3RpdmVJbmRleCIsIl9nZXRJdGVtSW5kZXgiLCJfZ2V0QWN0aXZlIiwib3JkZXIiLCJkZWZhdWx0SW50ZXJ2YWwiLCJfa2V5ZG93biIsIl9hZGRUb3VjaEV2ZW50TGlzdGVuZXJzIiwiaW1nIiwiZW5kQ2FsbEJhY2siLCJjbGVhclRpbWVvdXQiLCJzd2lwZUNvbmZpZyIsIl9kaXJlY3Rpb25Ub09yZGVyIiwiX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQiLCJhY3RpdmVJbmRpY2F0b3IiLCJuZXdBY3RpdmVJbmRpY2F0b3IiLCJlbGVtZW50SW50ZXJ2YWwiLCJwYXJzZUludCIsImlzTmV4dCIsIm5leHRFbGVtZW50IiwibmV4dEVsZW1lbnRJbmRleCIsInRyaWdnZXJFdmVudCIsIl9vcmRlclRvRGlyZWN0aW9uIiwic2xpZGVFdmVudCIsImlzQ3ljbGluZyIsImRpcmVjdGlvbmFsQ2xhc3NOYW1lIiwib3JkZXJDbGFzc05hbWUiLCJjb21wbGV0ZUNhbGxCYWNrIiwiX2lzQW5pbWF0ZWQiLCJjbGVhckludGVydmFsIiwiY2Fyb3VzZWwiLCJzbGlkZUluZGV4IiwiY2Fyb3VzZWxzIiwiTkFNRSRiIiwiREFUQV9LRVkkNyIsIkVWRU5UX0tFWSQ3IiwiREFUQV9BUElfS0VZJDQiLCJFVkVOVF9TSE9XJDYiLCJFVkVOVF9TSE9XTiQ2IiwiRVZFTlRfSElERSQ2IiwiRVZFTlRfSElEREVOJDYiLCJFVkVOVF9DTElDS19EQVRBX0FQSSQ0IiwiQ0xBU1NfTkFNRV9TSE9XJDciLCJDTEFTU19OQU1FX0NPTExBUFNFIiwiQ0xBU1NfTkFNRV9DT0xMQVBTSU5HIiwiQ0xBU1NfTkFNRV9DT0xMQVBTRUQiLCJDTEFTU19OQU1FX0RFRVBFUl9DSElMRFJFTiIsIkNMQVNTX05BTUVfSE9SSVpPTlRBTCIsIldJRFRIIiwiSEVJR0hUIiwiU0VMRUNUT1JfQUNUSVZFUyIsIlNFTEVDVE9SX0RBVEFfVE9HR0xFJDQiLCJEZWZhdWx0JGEiLCJwYXJlbnQiLCJEZWZhdWx0VHlwZSRhIiwiQ29sbGFwc2UiLCJfaXNUcmFuc2l0aW9uaW5nIiwiX3RyaWdnZXJBcnJheSIsInRvZ2dsZUxpc3QiLCJlbGVtIiwiZmlsdGVyRWxlbWVudCIsImZvdW5kRWxlbWVudCIsIl9pbml0aWFsaXplQ2hpbGRyZW4iLCJfYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzIiwiX2lzU2hvd24iLCJoaWRlIiwic2hvdyIsImFjdGl2ZUNoaWxkcmVuIiwiX2dldEZpcnN0TGV2ZWxDaGlsZHJlbiIsInN0YXJ0RXZlbnQiLCJhY3RpdmVJbnN0YW5jZSIsImRpbWVuc2lvbiIsIl9nZXREaW1lbnNpb24iLCJzdHlsZSIsImNvbXBsZXRlIiwiY2FwaXRhbGl6ZWREaW1lbnNpb24iLCJzY3JvbGxTaXplIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwic2VsZWN0ZWQiLCJ0cmlnZ2VyQXJyYXkiLCJpc09wZW4iLCJOQU1FJGEiLCJEQVRBX0tFWSQ2IiwiRVZFTlRfS0VZJDYiLCJEQVRBX0FQSV9LRVkkMyIsIkVTQ0FQRV9LRVkkMiIsIlRBQl9LRVkkMSIsIkFSUk9XX1VQX0tFWSQxIiwiQVJST1dfRE9XTl9LRVkkMSIsIlJJR0hUX01PVVNFX0JVVFRPTiIsIkVWRU5UX0hJREUkNSIsIkVWRU5UX0hJRERFTiQ1IiwiRVZFTlRfU0hPVyQ1IiwiRVZFTlRfU0hPV04kNSIsIkVWRU5UX0NMSUNLX0RBVEFfQVBJJDMiLCJFVkVOVF9LRVlET1dOX0RBVEFfQVBJIiwiRVZFTlRfS0VZVVBfREFUQV9BUEkiLCJDTEFTU19OQU1FX1NIT1ckNiIsIkNMQVNTX05BTUVfRFJPUFVQIiwiQ0xBU1NfTkFNRV9EUk9QRU5EIiwiQ0xBU1NfTkFNRV9EUk9QU1RBUlQiLCJDTEFTU19OQU1FX0RST1BVUF9DRU5URVIiLCJDTEFTU19OQU1FX0RST1BET1dOX0NFTlRFUiIsIlNFTEVDVE9SX0RBVEFfVE9HR0xFJDMiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRV9TSE9XTiIsIlNFTEVDVE9SX01FTlUiLCJTRUxFQ1RPUl9OQVZCQVIiLCJTRUxFQ1RPUl9OQVZCQVJfTkFWIiwiU0VMRUNUT1JfVklTSUJMRV9JVEVNUyIsIlBMQUNFTUVOVF9UT1AiLCJQTEFDRU1FTlRfVE9QRU5EIiwiUExBQ0VNRU5UX0JPVFRPTSIsIlBMQUNFTUVOVF9CT1RUT01FTkQiLCJQTEFDRU1FTlRfUklHSFQiLCJQTEFDRU1FTlRfTEVGVCIsIlBMQUNFTUVOVF9UT1BDRU5URVIiLCJQTEFDRU1FTlRfQk9UVE9NQ0VOVEVSIiwiRGVmYXVsdCQ5IiwiYXV0b0Nsb3NlIiwiYm91bmRhcnkiLCJkaXNwbGF5Iiwib2Zmc2V0IiwicG9wcGVyQ29uZmlnIiwicmVmZXJlbmNlIiwiRGVmYXVsdFR5cGUkOSIsIkRyb3Bkb3duIiwiX3BvcHBlciIsIl9wYXJlbnQiLCJfbWVudSIsIl9pbk5hdmJhciIsIl9kZXRlY3ROYXZiYXIiLCJzaG93RXZlbnQiLCJfY3JlYXRlUG9wcGVyIiwiZm9jdXMiLCJfY29tcGxldGVIaWRlIiwiZGVzdHJveSIsInVwZGF0ZSIsImhpZGVFdmVudCIsInJlZmVyZW5jZUVsZW1lbnQiLCJfZ2V0UG9wcGVyQ29uZmlnIiwiY3JlYXRlUG9wcGVyIiwiX2dldFBsYWNlbWVudCIsInBhcmVudERyb3Bkb3duIiwiaXNFbmQiLCJfZ2V0T2Zmc2V0IiwicG9wcGVyRGF0YSIsImRlZmF1bHRCc1BvcHBlckNvbmZpZyIsInBsYWNlbWVudCIsIm1vZGlmaWVycyIsIm9wdGlvbnMiLCJlbmFibGVkIiwiX3NlbGVjdE1lbnVJdGVtIiwiY2xlYXJNZW51cyIsIm9wZW5Ub2dnbGVzIiwiY29udGV4dCIsImNvbXBvc2VkUGF0aCIsImlzTWVudVRhcmdldCIsImRhdGFBcGlLZXlkb3duSGFuZGxlciIsImlzSW5wdXQiLCJpc0VzY2FwZUV2ZW50IiwiaXNVcE9yRG93bkV2ZW50IiwiZ2V0VG9nZ2xlQnV0dG9uIiwic3RvcFByb3BhZ2F0aW9uIiwiTkFNRSQ5IiwiQ0xBU1NfTkFNRV9GQURFJDQiLCJDTEFTU19OQU1FX1NIT1ckNSIsIkVWRU5UX01PVVNFRE9XTiIsIkRlZmF1bHQkOCIsImNsYXNzTmFtZSIsImNsaWNrQ2FsbGJhY2siLCJyb290RWxlbWVudCIsIkRlZmF1bHRUeXBlJDgiLCJCYWNrZHJvcCIsIl9pc0FwcGVuZGVkIiwiX2FwcGVuZCIsIl9nZXRFbGVtZW50IiwiX2VtdWxhdGVBbmltYXRpb24iLCJiYWNrZHJvcCIsImNyZWF0ZUVsZW1lbnQiLCJhcHBlbmQiLCJOQU1FJDgiLCJEQVRBX0tFWSQ1IiwiRVZFTlRfS0VZJDUiLCJFVkVOVF9GT0NVU0lOJDIiLCJFVkVOVF9LRVlET1dOX1RBQiIsIlRBQl9LRVkiLCJUQUJfTkFWX0ZPUldBUkQiLCJUQUJfTkFWX0JBQ0tXQVJEIiwiRGVmYXVsdCQ3IiwiYXV0b2ZvY3VzIiwidHJhcEVsZW1lbnQiLCJEZWZhdWx0VHlwZSQ3IiwiRm9jdXNUcmFwIiwiX2lzQWN0aXZlIiwiX2xhc3RUYWJOYXZEaXJlY3Rpb24iLCJhY3RpdmF0ZSIsIl9oYW5kbGVGb2N1c2luIiwiX2hhbmRsZUtleWRvd24iLCJkZWFjdGl2YXRlIiwiZWxlbWVudHMiLCJzaGlmdEtleSIsIlNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQiLCJTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCIsIlBST1BFUlRZX1BBRERJTkciLCJQUk9QRVJUWV9NQVJHSU4iLCJTY3JvbGxCYXJIZWxwZXIiLCJnZXRXaWR0aCIsImRvY3VtZW50V2lkdGgiLCJjbGllbnRXaWR0aCIsImlubmVyV2lkdGgiLCJ3aWR0aCIsIl9kaXNhYmxlT3ZlckZsb3ciLCJfc2V0RWxlbWVudEF0dHJpYnV0ZXMiLCJjYWxjdWxhdGVkVmFsdWUiLCJyZXNldCIsIl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzIiwiaXNPdmVyZmxvd2luZyIsIl9zYXZlSW5pdGlhbEF0dHJpYnV0ZSIsIm92ZXJmbG93Iiwic3R5bGVQcm9wZXJ0eSIsInNjcm9sbGJhcldpZHRoIiwibWFuaXB1bGF0aW9uQ2FsbEJhY2siLCJzZXRQcm9wZXJ0eSIsIl9hcHBseU1hbmlwdWxhdGlvbkNhbGxiYWNrIiwiYWN0dWFsVmFsdWUiLCJyZW1vdmVQcm9wZXJ0eSIsImNhbGxCYWNrIiwic2VsIiwiTkFNRSQ3IiwiREFUQV9LRVkkNCIsIkVWRU5UX0tFWSQ0IiwiREFUQV9BUElfS0VZJDIiLCJFU0NBUEVfS0VZJDEiLCJFVkVOVF9ISURFJDQiLCJFVkVOVF9ISURFX1BSRVZFTlRFRCQxIiwiRVZFTlRfSElEREVOJDQiLCJFVkVOVF9TSE9XJDQiLCJFVkVOVF9TSE9XTiQ0IiwiRVZFTlRfUkVTSVpFJDEiLCJFVkVOVF9DTElDS19ESVNNSVNTIiwiRVZFTlRfTU9VU0VET1dOX0RJU01JU1MiLCJFVkVOVF9LRVlET1dOX0RJU01JU1MkMSIsIkVWRU5UX0NMSUNLX0RBVEFfQVBJJDIiLCJDTEFTU19OQU1FX09QRU4iLCJDTEFTU19OQU1FX0ZBREUkMyIsIkNMQVNTX05BTUVfU0hPVyQ0IiwiQ0xBU1NfTkFNRV9TVEFUSUMiLCJPUEVOX1NFTEVDVE9SJDEiLCJTRUxFQ1RPUl9ESUFMT0ciLCJTRUxFQ1RPUl9NT0RBTF9CT0RZIiwiU0VMRUNUT1JfREFUQV9UT0dHTEUkMiIsIkRlZmF1bHQkNiIsIkRlZmF1bHRUeXBlJDYiLCJNb2RhbCIsIl9kaWFsb2ciLCJfYmFja2Ryb3AiLCJfaW5pdGlhbGl6ZUJhY2tEcm9wIiwiX2ZvY3VzdHJhcCIsIl9pbml0aWFsaXplRm9jdXNUcmFwIiwiX3Njcm9sbEJhciIsIl9hZGp1c3REaWFsb2ciLCJfc2hvd0VsZW1lbnQiLCJfaGlkZU1vZGFsIiwiaGFuZGxlVXBkYXRlIiwic2Nyb2xsVG9wIiwibW9kYWxCb2R5IiwidHJhbnNpdGlvbkNvbXBsZXRlIiwiX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24iLCJldmVudDIiLCJfcmVzZXRBZGp1c3RtZW50cyIsImlzTW9kYWxPdmVyZmxvd2luZyIsInNjcm9sbEhlaWdodCIsImNsaWVudEhlaWdodCIsImluaXRpYWxPdmVyZmxvd1kiLCJvdmVyZmxvd1kiLCJpc0JvZHlPdmVyZmxvd2luZyIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0IiwiYWxyZWFkeU9wZW4iLCJOQU1FJDYiLCJEQVRBX0tFWSQzIiwiRVZFTlRfS0VZJDMiLCJEQVRBX0FQSV9LRVkkMSIsIkVWRU5UX0xPQURfREFUQV9BUEkkMiIsIkVTQ0FQRV9LRVkiLCJDTEFTU19OQU1FX1NIT1ckMyIsIkNMQVNTX05BTUVfU0hPV0lORyQxIiwiQ0xBU1NfTkFNRV9ISURJTkciLCJDTEFTU19OQU1FX0JBQ0tEUk9QIiwiT1BFTl9TRUxFQ1RPUiIsIkVWRU5UX1NIT1ckMyIsIkVWRU5UX1NIT1dOJDMiLCJFVkVOVF9ISURFJDMiLCJFVkVOVF9ISURFX1BSRVZFTlRFRCIsIkVWRU5UX0hJRERFTiQzIiwiRVZFTlRfUkVTSVpFIiwiRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMSIsIkVWRU5UX0tFWURPV05fRElTTUlTUyIsIlNFTEVDVE9SX0RBVEFfVE9HR0xFJDEiLCJEZWZhdWx0JDUiLCJzY3JvbGwiLCJEZWZhdWx0VHlwZSQ1IiwiT2ZmY2FudmFzIiwiYmx1ciIsImNvbXBsZXRlQ2FsbGJhY2siLCJwb3NpdGlvbiIsIkFSSUFfQVRUUklCVVRFX1BBVFRFUk4iLCJEZWZhdWx0QWxsb3dsaXN0IiwiYSIsImFyZWEiLCJiIiwiYnIiLCJjb2wiLCJjb2RlIiwiZGl2IiwiZW0iLCJociIsImgxIiwiaDIiLCJoMyIsImg0IiwiaDUiLCJoNiIsImkiLCJsaSIsIm9sIiwicCIsInByZSIsInMiLCJzbWFsbCIsInNwYW4iLCJzdWIiLCJzdXAiLCJzdHJvbmciLCJ1IiwidWwiLCJ1cmlBdHRyaWJ1dGVzIiwiU0FGRV9VUkxfUEFUVEVSTiIsImFsbG93ZWRBdHRyaWJ1dGUiLCJhdHRyaWJ1dGUiLCJhbGxvd2VkQXR0cmlidXRlTGlzdCIsImF0dHJpYnV0ZU5hbWUiLCJub2RlTmFtZSIsIm5vZGVWYWx1ZSIsImF0dHJpYnV0ZVJlZ2V4Iiwic29tZSIsInJlZ2V4Iiwic2FuaXRpemVIdG1sIiwidW5zYWZlSHRtbCIsImFsbG93TGlzdCIsInNhbml0aXplRnVuY3Rpb24iLCJkb21QYXJzZXIiLCJET01QYXJzZXIiLCJjcmVhdGVkRG9jdW1lbnQiLCJwYXJzZUZyb21TdHJpbmciLCJlbGVtZW50TmFtZSIsImF0dHJpYnV0ZUxpc3QiLCJhbGxvd2VkQXR0cmlidXRlcyIsImlubmVySFRNTCIsIk5BTUUkNSIsIkRlZmF1bHQkNCIsImNvbnRlbnQiLCJleHRyYUNsYXNzIiwiaHRtbCIsInNhbml0aXplIiwic2FuaXRpemVGbiIsInRlbXBsYXRlIiwiRGVmYXVsdFR5cGUkNCIsIkRlZmF1bHRDb250ZW50VHlwZSIsImVudHJ5IiwiVGVtcGxhdGVGYWN0b3J5IiwiZ2V0Q29udGVudCIsIl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbiIsImhhc0NvbnRlbnQiLCJjaGFuZ2VDb250ZW50IiwiX2NoZWNrQ29udGVudCIsInRvSHRtbCIsInRlbXBsYXRlV3JhcHBlciIsIl9tYXliZVNhbml0aXplIiwidGV4dCIsIl9zZXRDb250ZW50IiwiYXJnIiwidGVtcGxhdGVFbGVtZW50IiwiX3B1dEVsZW1lbnRJblRlbXBsYXRlIiwidGV4dENvbnRlbnQiLCJOQU1FJDQiLCJESVNBTExPV0VEX0FUVFJJQlVURVMiLCJDTEFTU19OQU1FX0ZBREUkMiIsIkNMQVNTX05BTUVfTU9EQUwiLCJDTEFTU19OQU1FX1NIT1ckMiIsIlNFTEVDVE9SX1RPT0xUSVBfSU5ORVIiLCJTRUxFQ1RPUl9NT0RBTCIsIkVWRU5UX01PREFMX0hJREUiLCJUUklHR0VSX0hPVkVSIiwiVFJJR0dFUl9GT0NVUyIsIlRSSUdHRVJfQ0xJQ0siLCJUUklHR0VSX01BTlVBTCIsIkVWRU5UX0hJREUkMiIsIkVWRU5UX0hJRERFTiQyIiwiRVZFTlRfU0hPVyQyIiwiRVZFTlRfU0hPV04kMiIsIkVWRU5UX0lOU0VSVEVEIiwiRVZFTlRfQ0xJQ0skMSIsIkVWRU5UX0ZPQ1VTSU4kMSIsIkVWRU5UX0ZPQ1VTT1VUJDEiLCJFVkVOVF9NT1VTRUVOVEVSIiwiRVZFTlRfTU9VU0VMRUFWRSIsIkF0dGFjaG1lbnRNYXAiLCJBVVRPIiwiVE9QIiwiUklHSFQiLCJCT1RUT00iLCJMRUZUIiwiRGVmYXVsdCQzIiwiYW5pbWF0aW9uIiwiY29udGFpbmVyIiwiY3VzdG9tQ2xhc3MiLCJkZWxheSIsImZhbGxiYWNrUGxhY2VtZW50cyIsInRpdGxlIiwiRGVmYXVsdFR5cGUkMyIsIlRvb2x0aXAiLCJfaXNFbmFibGVkIiwiX3RpbWVvdXQiLCJfaXNIb3ZlcmVkIiwiX2FjdGl2ZVRyaWdnZXIiLCJfdGVtcGxhdGVGYWN0b3J5IiwiX25ld0NvbnRlbnQiLCJ0aXAiLCJfc2V0TGlzdGVuZXJzIiwiX2ZpeFRpdGxlIiwiZW5hYmxlIiwiZGlzYWJsZSIsInRvZ2dsZUVuYWJsZWQiLCJjbGljayIsIl9sZWF2ZSIsIl9lbnRlciIsIl9oaWRlTW9kYWxIYW5kbGVyIiwiX2Rpc3Bvc2VQb3BwZXIiLCJfaXNXaXRoQ29udGVudCIsInNoYWRvd1Jvb3QiLCJpc0luVGhlRG9tIiwib3duZXJEb2N1bWVudCIsIl9nZXRUaXBFbGVtZW50IiwiX2lzV2l0aEFjdGl2ZVRyaWdnZXIiLCJfZ2V0VGl0bGUiLCJfY3JlYXRlVGlwRWxlbWVudCIsIl9nZXRDb250ZW50Rm9yVGVtcGxhdGUiLCJfZ2V0VGVtcGxhdGVGYWN0b3J5IiwidGlwSWQiLCJzZXRDb250ZW50IiwiX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldCIsIl9nZXREZWxlZ2F0ZUNvbmZpZyIsImF0dGFjaG1lbnQiLCJwaGFzZSIsInN0YXRlIiwidHJpZ2dlcnMiLCJldmVudEluIiwiZXZlbnRPdXQiLCJfc2V0VGltZW91dCIsInRpbWVvdXQiLCJkYXRhQXR0cmlidXRlcyIsImRhdGFBdHRyaWJ1dGUiLCJOQU1FJDMiLCJTRUxFQ1RPUl9USVRMRSIsIlNFTEVDVE9SX0NPTlRFTlQiLCJEZWZhdWx0JDIiLCJEZWZhdWx0VHlwZSQyIiwiUG9wb3ZlciIsIl9nZXRDb250ZW50IiwiTkFNRSQyIiwiREFUQV9LRVkkMiIsIkVWRU5UX0tFWSQyIiwiREFUQV9BUElfS0VZIiwiRVZFTlRfQUNUSVZBVEUiLCJFVkVOVF9DTElDSyIsIkVWRU5UX0xPQURfREFUQV9BUEkkMSIsIkNMQVNTX05BTUVfRFJPUERPV05fSVRFTSIsIkNMQVNTX05BTUVfQUNUSVZFJDEiLCJTRUxFQ1RPUl9EQVRBX1NQWSIsIlNFTEVDVE9SX1RBUkdFVF9MSU5LUyIsIlNFTEVDVE9SX05BVl9MSVNUX0dST1VQIiwiU0VMRUNUT1JfTkFWX0xJTktTIiwiU0VMRUNUT1JfTkFWX0lURU1TIiwiU0VMRUNUT1JfTElTVF9JVEVNUyIsIlNFTEVDVE9SX0xJTktfSVRFTVMiLCJTRUxFQ1RPUl9EUk9QRE9XTiIsIlNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSQxIiwiRGVmYXVsdCQxIiwicm9vdE1hcmdpbiIsInNtb290aFNjcm9sbCIsInRocmVzaG9sZCIsIkRlZmF1bHRUeXBlJDEiLCJTY3JvbGxTcHkiLCJfdGFyZ2V0TGlua3MiLCJfb2JzZXJ2YWJsZVNlY3Rpb25zIiwiX3Jvb3RFbGVtZW50IiwiX2FjdGl2ZVRhcmdldCIsIl9vYnNlcnZlciIsIl9wcmV2aW91c1Njcm9sbERhdGEiLCJ2aXNpYmxlRW50cnlUb3AiLCJwYXJlbnRTY3JvbGxUb3AiLCJyZWZyZXNoIiwiX2luaXRpYWxpemVUYXJnZXRzQW5kT2JzZXJ2YWJsZXMiLCJfbWF5YmVFbmFibGVTbW9vdGhTY3JvbGwiLCJkaXNjb25uZWN0IiwiX2dldE5ld09ic2VydmVyIiwic2VjdGlvbiIsIm9ic2VydmUiLCJvYnNlcnZhYmxlU2VjdGlvbiIsImhhc2giLCJoZWlnaHQiLCJvZmZzZXRUb3AiLCJzY3JvbGxUbyIsInRvcCIsImJlaGF2aW9yIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJfb2JzZXJ2ZXJDYWxsYmFjayIsInRhcmdldEVsZW1lbnQiLCJfcHJvY2VzcyIsInVzZXJTY3JvbGxzRG93biIsImlzSW50ZXJzZWN0aW5nIiwiX2NsZWFyQWN0aXZlQ2xhc3MiLCJlbnRyeUlzTG93ZXJUaGFuUHJldmlvdXMiLCJ0YXJnZXRMaW5rcyIsImFuY2hvciIsImRlY29kZVVSSSIsIl9hY3RpdmF0ZVBhcmVudHMiLCJsaXN0R3JvdXAiLCJpdGVtIiwiYWN0aXZlTm9kZXMiLCJub2RlIiwic3B5IiwiTkFNRSQxIiwiREFUQV9LRVkkMSIsIkVWRU5UX0tFWSQxIiwiRVZFTlRfSElERSQxIiwiRVZFTlRfSElEREVOJDEiLCJFVkVOVF9TSE9XJDEiLCJFVkVOVF9TSE9XTiQxIiwiRVZFTlRfQ0xJQ0tfREFUQV9BUEkiLCJFVkVOVF9LRVlET1dOIiwiRVZFTlRfTE9BRF9EQVRBX0FQSSIsIkFSUk9XX0xFRlRfS0VZIiwiQVJST1dfUklHSFRfS0VZIiwiQVJST1dfVVBfS0VZIiwiQVJST1dfRE9XTl9LRVkiLCJIT01FX0tFWSIsIkVORF9LRVkiLCJDTEFTU19OQU1FX0FDVElWRSIsIkNMQVNTX05BTUVfRkFERSQxIiwiQ0xBU1NfTkFNRV9TSE9XJDEiLCJDTEFTU19EUk9QRE9XTiIsIlNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSIsIlNFTEVDVE9SX0RST1BET1dOX01FTlUiLCJOT1RfU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFIiwiU0VMRUNUT1JfVEFCX1BBTkVMIiwiU0VMRUNUT1JfT1VURVIiLCJTRUxFQ1RPUl9JTk5FUiIsIlNFTEVDVE9SX0RBVEFfVE9HR0xFIiwiU0VMRUNUT1JfSU5ORVJfRUxFTSIsIlNFTEVDVE9SX0RBVEFfVE9HR0xFX0FDVElWRSIsIlRhYiIsIl9zZXRJbml0aWFsQXR0cmlidXRlcyIsIl9nZXRDaGlsZHJlbiIsImlubmVyRWxlbSIsIl9lbGVtSXNBY3RpdmUiLCJhY3RpdmUiLCJfZ2V0QWN0aXZlRWxlbSIsIl9kZWFjdGl2YXRlIiwiX2FjdGl2YXRlIiwicmVsYXRlZEVsZW0iLCJfdG9nZ2xlRHJvcERvd24iLCJuZXh0QWN0aXZlRWxlbWVudCIsInByZXZlbnRTY3JvbGwiLCJfc2V0QXR0cmlidXRlSWZOb3RFeGlzdHMiLCJfc2V0SW5pdGlhbEF0dHJpYnV0ZXNPbkNoaWxkIiwiX2dldElubmVyRWxlbWVudCIsImlzQWN0aXZlIiwib3V0ZXJFbGVtIiwiX2dldE91dGVyRWxlbWVudCIsIl9zZXRJbml0aWFsQXR0cmlidXRlc09uVGFyZ2V0UGFuZWwiLCJvcGVuIiwiRVZFTlRfTU9VU0VPVkVSIiwiRVZFTlRfTU9VU0VPVVQiLCJFVkVOVF9GT0NVU0lOIiwiRVZFTlRfRk9DVVNPVVQiLCJFVkVOVF9ISURFIiwiRVZFTlRfSElEREVOIiwiRVZFTlRfU0hPVyIsIkVWRU5UX1NIT1dOIiwiQ0xBU1NfTkFNRV9GQURFIiwiQ0xBU1NfTkFNRV9ISURFIiwiQ0xBU1NfTkFNRV9TSE9XIiwiQ0xBU1NfTkFNRV9TSE9XSU5HIiwiYXV0b2hpZGUiLCJUb2FzdCIsIl9oYXNNb3VzZUludGVyYWN0aW9uIiwiX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24iLCJfY2xlYXJUaW1lb3V0IiwiX21heWJlU2NoZWR1bGVIaWRlIiwiaXNTaG93biIsIl9vbkludGVyYWN0aW9uIiwiaXNJbnRlcmFjdGluZyIsImluZGV4X3VtZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bootstrap/dist/js/bootstrap.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bootstrap/dist/css/bootstrap.min.css":
/*!***********************************************************!*\
  !*** ./node_modules/bootstrap/dist/css/bootstrap.min.css ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"1f139981b9b4\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvY3NzL2Jvb3RzdHJhcC5taW4uY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXV0b2NoZWNrZXIvLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvY3NzL2Jvb3RzdHJhcC5taW4uY3NzPzY1MzkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIxZjEzOTk4MWI5YjRcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bootstrap/dist/css/bootstrap.min.css\n");

/***/ })

};
;