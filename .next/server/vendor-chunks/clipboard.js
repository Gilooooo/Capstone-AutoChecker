"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/clipboard";
exports.ids = ["vendor-chunks/clipboard"];
exports.modules = {

/***/ "(ssr)/./node_modules/clipboard/dist/clipboard.js":
/*!**************************************************!*\
  !*** ./node_modules/clipboard/dist/clipboard.js ***!
  \**************************************************/
/***/ ((module) => {

eval("\n/*!\n * clipboard.js v2.0.11\n * https://clipboardjs.com/\n *\n * Licensed MIT Â© Zeno Rocha\n */ (function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory();\n    else {}\n})(void 0, function() {\n    return /******/ function() {\n        /******/ var __webpack_modules__ = {\n            /***/ 686: /***/ function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_645__) {\n                \"use strict\";\n                // EXPORTS\n                __nested_webpack_require_645__.d(__nested_webpack_exports__, {\n                    \"default\": function() {\n                        return /* binding */ clipboard;\n                    }\n                });\n                // EXTERNAL MODULE: ./node_modules/tiny-emitter/index.js\n                var tiny_emitter = __nested_webpack_require_645__(279);\n                var tiny_emitter_default = /*#__PURE__*/ __nested_webpack_require_645__.n(tiny_emitter);\n                // EXTERNAL MODULE: ./node_modules/good-listener/src/listen.js\n                var listen = __nested_webpack_require_645__(370);\n                var listen_default = /*#__PURE__*/ __nested_webpack_require_645__.n(listen);\n                // EXTERNAL MODULE: ./node_modules/select/src/select.js\n                var src_select = __nested_webpack_require_645__(817);\n                var select_default = /*#__PURE__*/ __nested_webpack_require_645__.n(src_select);\n                ; // CONCATENATED MODULE: ./src/common/command.js\n                /**\n * Executes a given operation type.\n * @param {String} type\n * @return {Boolean}\n */ function command(type) {\n                    try {\n                        return document.execCommand(type);\n                    } catch (err) {\n                        return false;\n                    }\n                }\n                ; // CONCATENATED MODULE: ./src/actions/cut.js\n                /**\n * Cut action wrapper.\n * @param {String|HTMLElement} target\n * @return {String}\n */ var ClipboardActionCut = function ClipboardActionCut(target) {\n                    var selectedText = select_default()(target);\n                    command(\"cut\");\n                    return selectedText;\n                };\n                /* harmony default export */ var actions_cut = ClipboardActionCut;\n                ; // CONCATENATED MODULE: ./src/common/create-fake-element.js\n                /**\n * Creates a fake textarea element with a value.\n * @param {String} value\n * @return {HTMLElement}\n */ function createFakeElement(value) {\n                    var isRTL = document.documentElement.getAttribute(\"dir\") === \"rtl\";\n                    var fakeElement = document.createElement(\"textarea\"); // Prevent zooming on iOS\n                    fakeElement.style.fontSize = \"12pt\"; // Reset box model\n                    fakeElement.style.border = \"0\";\n                    fakeElement.style.padding = \"0\";\n                    fakeElement.style.margin = \"0\"; // Move element out of screen horizontally\n                    fakeElement.style.position = \"absolute\";\n                    fakeElement.style[isRTL ? \"right\" : \"left\"] = \"-9999px\"; // Move element to the same position vertically\n                    var yPosition = window.pageYOffset || document.documentElement.scrollTop;\n                    fakeElement.style.top = \"\".concat(yPosition, \"px\");\n                    fakeElement.setAttribute(\"readonly\", \"\");\n                    fakeElement.value = value;\n                    return fakeElement;\n                }\n                ; // CONCATENATED MODULE: ./src/actions/copy.js\n                /**\n * Create fake copy action wrapper using a fake element.\n * @param {String} target\n * @param {Object} options\n * @return {String}\n */ var fakeCopyAction = function fakeCopyAction(value, options) {\n                    var fakeElement = createFakeElement(value);\n                    options.container.appendChild(fakeElement);\n                    var selectedText = select_default()(fakeElement);\n                    command(\"copy\");\n                    fakeElement.remove();\n                    return selectedText;\n                };\n                /**\n * Copy action wrapper.\n * @param {String|HTMLElement} target\n * @param {Object} options\n * @return {String}\n */ var ClipboardActionCopy = function ClipboardActionCopy(target) {\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n                        container: document.body\n                    };\n                    var selectedText = \"\";\n                    if (typeof target === \"string\") {\n                        selectedText = fakeCopyAction(target, options);\n                    } else if (target instanceof HTMLInputElement && ![\n                        \"text\",\n                        \"search\",\n                        \"url\",\n                        \"tel\",\n                        \"password\"\n                    ].includes(target === null || target === void 0 ? void 0 : target.type)) {\n                        // If input type doesn't support `setSelectionRange`. Simulate it. https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/setSelectionRange\n                        selectedText = fakeCopyAction(target.value, options);\n                    } else {\n                        selectedText = select_default()(target);\n                        command(\"copy\");\n                    }\n                    return selectedText;\n                };\n                /* harmony default export */ var actions_copy = ClipboardActionCopy;\n                ; // CONCATENATED MODULE: ./src/actions/default.js\n                function _typeof(obj) {\n                    \"@babel/helpers - typeof\";\n                    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                        _typeof = function _typeof(obj) {\n                            return typeof obj;\n                        };\n                    } else {\n                        _typeof = function _typeof(obj) {\n                            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                        };\n                    }\n                    return _typeof(obj);\n                }\n                /**\n * Inner function which performs selection from either `text` or `target`\n * properties and then executes copy or cut operations.\n * @param {Object} options\n */ var ClipboardActionDefault = function ClipboardActionDefault() {\n                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                    // Defines base properties passed from constructor.\n                    var _options$action = options.action, action = _options$action === void 0 ? \"copy\" : _options$action, container = options.container, target = options.target, text = options.text; // Sets the `action` to be performed which can be either 'copy' or 'cut'.\n                    if (action !== \"copy\" && action !== \"cut\") {\n                        throw new Error('Invalid \"action\" value, use either \"copy\" or \"cut\"');\n                    } // Sets the `target` property using an element that will be have its content copied.\n                    if (target !== undefined) {\n                        if (target && _typeof(target) === \"object\" && target.nodeType === 1) {\n                            if (action === \"copy\" && target.hasAttribute(\"disabled\")) {\n                                throw new Error('Invalid \"target\" attribute. Please use \"readonly\" instead of \"disabled\" attribute');\n                            }\n                            if (action === \"cut\" && (target.hasAttribute(\"readonly\") || target.hasAttribute(\"disabled\"))) {\n                                throw new Error('Invalid \"target\" attribute. You can\\'t cut text from elements with \"readonly\" or \"disabled\" attributes');\n                            }\n                        } else {\n                            throw new Error('Invalid \"target\" value, use a valid Element');\n                        }\n                    } // Define selection strategy based on `text` property.\n                    if (text) {\n                        return actions_copy(text, {\n                            container: container\n                        });\n                    } // Defines which selection strategy based on `target` property.\n                    if (target) {\n                        return action === \"cut\" ? actions_cut(target) : actions_copy(target, {\n                            container: container\n                        });\n                    }\n                };\n                /* harmony default export */ var actions_default = ClipboardActionDefault;\n                ; // CONCATENATED MODULE: ./src/clipboard.js\n                function clipboard_typeof(obj) {\n                    \"@babel/helpers - typeof\";\n                    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                        clipboard_typeof = function _typeof(obj) {\n                            return typeof obj;\n                        };\n                    } else {\n                        clipboard_typeof = function _typeof(obj) {\n                            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                        };\n                    }\n                    return clipboard_typeof(obj);\n                }\n                function _classCallCheck(instance, Constructor) {\n                    if (!(instance instanceof Constructor)) {\n                        throw new TypeError(\"Cannot call a class as a function\");\n                    }\n                }\n                function _defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                function _createClass(Constructor, protoProps, staticProps) {\n                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) _defineProperties(Constructor, staticProps);\n                    return Constructor;\n                }\n                function _inherits(subClass, superClass) {\n                    if (typeof superClass !== \"function\" && superClass !== null) {\n                        throw new TypeError(\"Super expression must either be null or a function\");\n                    }\n                    subClass.prototype = Object.create(superClass && superClass.prototype, {\n                        constructor: {\n                            value: subClass,\n                            writable: true,\n                            configurable: true\n                        }\n                    });\n                    if (superClass) _setPrototypeOf(subClass, superClass);\n                }\n                function _setPrototypeOf(o, p) {\n                    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n                        o.__proto__ = p;\n                        return o;\n                    };\n                    return _setPrototypeOf(o, p);\n                }\n                function _createSuper(Derived) {\n                    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n                    return function _createSuperInternal() {\n                        var Super = _getPrototypeOf(Derived), result;\n                        if (hasNativeReflectConstruct) {\n                            var NewTarget = _getPrototypeOf(this).constructor;\n                            result = Reflect.construct(Super, arguments, NewTarget);\n                        } else {\n                            result = Super.apply(this, arguments);\n                        }\n                        return _possibleConstructorReturn(this, result);\n                    };\n                }\n                function _possibleConstructorReturn(self, call) {\n                    if (call && (clipboard_typeof(call) === \"object\" || typeof call === \"function\")) {\n                        return call;\n                    }\n                    return _assertThisInitialized(self);\n                }\n                function _assertThisInitialized(self) {\n                    if (self === void 0) {\n                        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                    }\n                    return self;\n                }\n                function _isNativeReflectConstruct() {\n                    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                    if (Reflect.construct.sham) return false;\n                    if (typeof Proxy === \"function\") return true;\n                    try {\n                        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\n                        return true;\n                    } catch (e) {\n                        return false;\n                    }\n                }\n                function _getPrototypeOf(o) {\n                    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n                        return o.__proto__ || Object.getPrototypeOf(o);\n                    };\n                    return _getPrototypeOf(o);\n                }\n                /**\n * Helper function to retrieve attribute value.\n * @param {String} suffix\n * @param {Element} element\n */ function getAttributeValue(suffix, element) {\n                    var attribute = \"data-clipboard-\".concat(suffix);\n                    if (!element.hasAttribute(attribute)) {\n                        return;\n                    }\n                    return element.getAttribute(attribute);\n                }\n                /**\n * Base class which takes one or more elements, adds event listeners to them,\n * and instantiates a new `ClipboardAction` on each click.\n */ var Clipboard = /*#__PURE__*/ function(_Emitter) {\n                    _inherits(Clipboard, _Emitter);\n                    var _super = _createSuper(Clipboard);\n                    /**\n   * @param {String|HTMLElement|HTMLCollection|NodeList} trigger\n   * @param {Object} options\n   */ function Clipboard(trigger, options) {\n                        var _this;\n                        _classCallCheck(this, Clipboard);\n                        _this = _super.call(this);\n                        _this.resolveOptions(options);\n                        _this.listenClick(trigger);\n                        return _this;\n                    }\n                    /**\n   * Defines if attributes would be resolved using internal setter functions\n   * or custom functions that were passed in the constructor.\n   * @param {Object} options\n   */ _createClass(Clipboard, [\n                        {\n                            key: \"resolveOptions\",\n                            value: function resolveOptions() {\n                                var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                                this.action = typeof options.action === \"function\" ? options.action : this.defaultAction;\n                                this.target = typeof options.target === \"function\" ? options.target : this.defaultTarget;\n                                this.text = typeof options.text === \"function\" ? options.text : this.defaultText;\n                                this.container = clipboard_typeof(options.container) === \"object\" ? options.container : document.body;\n                            }\n                        },\n                        {\n                            key: \"listenClick\",\n                            value: function listenClick(trigger) {\n                                var _this2 = this;\n                                this.listener = listen_default()(trigger, \"click\", function(e) {\n                                    return _this2.onClick(e);\n                                });\n                            }\n                        },\n                        {\n                            key: \"onClick\",\n                            value: function onClick(e) {\n                                var trigger = e.delegateTarget || e.currentTarget;\n                                var action = this.action(trigger) || \"copy\";\n                                var text = actions_default({\n                                    action: action,\n                                    container: this.container,\n                                    target: this.target(trigger),\n                                    text: this.text(trigger)\n                                }); // Fires an event based on the copy operation result.\n                                this.emit(text ? \"success\" : \"error\", {\n                                    action: action,\n                                    text: text,\n                                    trigger: trigger,\n                                    clearSelection: function clearSelection() {\n                                        if (trigger) {\n                                            trigger.focus();\n                                        }\n                                        window.getSelection().removeAllRanges();\n                                    }\n                                });\n                            }\n                        },\n                        {\n                            key: \"defaultAction\",\n                            value: function defaultAction(trigger) {\n                                return getAttributeValue(\"action\", trigger);\n                            }\n                        },\n                        {\n                            key: \"defaultTarget\",\n                            value: function defaultTarget(trigger) {\n                                var selector = getAttributeValue(\"target\", trigger);\n                                if (selector) {\n                                    return document.querySelector(selector);\n                                }\n                            }\n                        },\n                        {\n                            key: \"defaultText\",\n                            /**\n     * Default `text` lookup function.\n     * @param {Element} trigger\n     */ value: function defaultText(trigger) {\n                                return getAttributeValue(\"text\", trigger);\n                            }\n                        },\n                        {\n                            key: \"destroy\",\n                            value: function destroy() {\n                                this.listener.destroy();\n                            }\n                        }\n                    ], [\n                        {\n                            key: \"copy\",\n                            value: function copy(target) {\n                                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n                                    container: document.body\n                                };\n                                return actions_copy(target, options);\n                            }\n                        },\n                        {\n                            key: \"cut\",\n                            value: function cut(target) {\n                                return actions_cut(target);\n                            }\n                        },\n                        {\n                            key: \"isSupported\",\n                            value: function isSupported() {\n                                var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [\n                                    \"copy\",\n                                    \"cut\"\n                                ];\n                                var actions = typeof action === \"string\" ? [\n                                    action\n                                ] : action;\n                                var support = !!document.queryCommandSupported;\n                                actions.forEach(function(action) {\n                                    support = support && !!document.queryCommandSupported(action);\n                                });\n                                return support;\n                            }\n                        }\n                    ]);\n                    return Clipboard;\n                }(tiny_emitter_default());\n                /* harmony default export */ var clipboard = Clipboard;\n            /***/ },\n            /***/ 828: /***/ function(module1) {\n                var DOCUMENT_NODE_TYPE = 9;\n                /**\n * A polyfill for Element.matches()\n */ if (typeof Element !== \"undefined\" && !Element.prototype.matches) {\n                    var proto = Element.prototype;\n                    proto.matches = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;\n                }\n                /**\n * Finds the closest parent that matches a selector.\n *\n * @param {Element} element\n * @param {String} selector\n * @return {Function}\n */ function closest(element, selector) {\n                    while(element && element.nodeType !== DOCUMENT_NODE_TYPE){\n                        if (typeof element.matches === \"function\" && element.matches(selector)) {\n                            return element;\n                        }\n                        element = element.parentNode;\n                    }\n                }\n                module1.exports = closest;\n            /***/ },\n            /***/ 438: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_22291__) {\n                var closest = __nested_webpack_require_22291__(828);\n                /**\n * Delegates event to a selector.\n *\n * @param {Element} element\n * @param {String} selector\n * @param {String} type\n * @param {Function} callback\n * @param {Boolean} useCapture\n * @return {Object}\n */ function _delegate(element, selector, type, callback, useCapture) {\n                    var listenerFn = listener.apply(this, arguments);\n                    element.addEventListener(type, listenerFn, useCapture);\n                    return {\n                        destroy: function() {\n                            element.removeEventListener(type, listenerFn, useCapture);\n                        }\n                    };\n                }\n                /**\n * Delegates event to a selector.\n *\n * @param {Element|String|Array} [elements]\n * @param {String} selector\n * @param {String} type\n * @param {Function} callback\n * @param {Boolean} useCapture\n * @return {Object}\n */ function delegate(elements, selector, type, callback, useCapture) {\n                    // Handle the regular Element usage\n                    if (typeof elements.addEventListener === \"function\") {\n                        return _delegate.apply(null, arguments);\n                    }\n                    // Handle Element-less usage, it defaults to global delegation\n                    if (typeof type === \"function\") {\n                        // Use `document` as the first parameter, then apply arguments\n                        // This is a short way to .unshift `arguments` without running into deoptimizations\n                        return _delegate.bind(null, document).apply(null, arguments);\n                    }\n                    // Handle Selector-based usage\n                    if (typeof elements === \"string\") {\n                        elements = document.querySelectorAll(elements);\n                    }\n                    // Handle Array-like based usage\n                    return Array.prototype.map.call(elements, function(element) {\n                        return _delegate(element, selector, type, callback, useCapture);\n                    });\n                }\n                /**\n * Finds closest match and invokes callback.\n *\n * @param {Element} element\n * @param {String} selector\n * @param {String} type\n * @param {Function} callback\n * @return {Function}\n */ function listener(element, selector, type, callback) {\n                    return function(e) {\n                        e.delegateTarget = closest(e.target, selector);\n                        if (e.delegateTarget) {\n                            callback.call(element, e);\n                        }\n                    };\n                }\n                module1.exports = delegate;\n            /***/ },\n            /***/ 879: /***/ function(__unused_webpack_module, exports1) {\n                /**\n * Check if argument is a HTML element.\n *\n * @param {Object} value\n * @return {Boolean}\n */ exports1.node = function(value) {\n                    return value !== undefined && value instanceof HTMLElement && value.nodeType === 1;\n                };\n                /**\n * Check if argument is a list of HTML elements.\n *\n * @param {Object} value\n * @return {Boolean}\n */ exports1.nodeList = function(value) {\n                    var type = Object.prototype.toString.call(value);\n                    return value !== undefined && (type === \"[object NodeList]\" || type === \"[object HTMLCollection]\") && \"length\" in value && (value.length === 0 || exports1.node(value[0]));\n                };\n                /**\n * Check if argument is a string.\n *\n * @param {Object} value\n * @return {Boolean}\n */ exports1.string = function(value) {\n                    return typeof value === \"string\" || value instanceof String;\n                };\n                /**\n * Check if argument is a function.\n *\n * @param {Object} value\n * @return {Boolean}\n */ exports1.fn = function(value) {\n                    var type = Object.prototype.toString.call(value);\n                    return type === \"[object Function]\";\n                };\n            /***/ },\n            /***/ 370: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_26483__) {\n                var is = __nested_webpack_require_26483__(879);\n                var delegate = __nested_webpack_require_26483__(438);\n                /**\n * Validates all params and calls the right\n * listener function based on its target type.\n *\n * @param {String|HTMLElement|HTMLCollection|NodeList} target\n * @param {String} type\n * @param {Function} callback\n * @return {Object}\n */ function listen(target, type, callback) {\n                    if (!target && !type && !callback) {\n                        throw new Error(\"Missing required arguments\");\n                    }\n                    if (!is.string(type)) {\n                        throw new TypeError(\"Second argument must be a String\");\n                    }\n                    if (!is.fn(callback)) {\n                        throw new TypeError(\"Third argument must be a Function\");\n                    }\n                    if (is.node(target)) {\n                        return listenNode(target, type, callback);\n                    } else if (is.nodeList(target)) {\n                        return listenNodeList(target, type, callback);\n                    } else if (is.string(target)) {\n                        return listenSelector(target, type, callback);\n                    } else {\n                        throw new TypeError(\"First argument must be a String, HTMLElement, HTMLCollection, or NodeList\");\n                    }\n                }\n                /**\n * Adds an event listener to a HTML element\n * and returns a remove listener function.\n *\n * @param {HTMLElement} node\n * @param {String} type\n * @param {Function} callback\n * @return {Object}\n */ function listenNode(node, type, callback) {\n                    node.addEventListener(type, callback);\n                    return {\n                        destroy: function() {\n                            node.removeEventListener(type, callback);\n                        }\n                    };\n                }\n                /**\n * Add an event listener to a list of HTML elements\n * and returns a remove listener function.\n *\n * @param {NodeList|HTMLCollection} nodeList\n * @param {String} type\n * @param {Function} callback\n * @return {Object}\n */ function listenNodeList(nodeList, type, callback) {\n                    Array.prototype.forEach.call(nodeList, function(node) {\n                        node.addEventListener(type, callback);\n                    });\n                    return {\n                        destroy: function() {\n                            Array.prototype.forEach.call(nodeList, function(node) {\n                                node.removeEventListener(type, callback);\n                            });\n                        }\n                    };\n                }\n                /**\n * Add an event listener to a selector\n * and returns a remove listener function.\n *\n * @param {String} selector\n * @param {String} type\n * @param {Function} callback\n * @return {Object}\n */ function listenSelector(selector, type, callback) {\n                    return delegate(document.body, selector, type, callback);\n                }\n                module1.exports = listen;\n            /***/ },\n            /***/ 817: /***/ function(module1) {\n                function select(element) {\n                    var selectedText;\n                    if (element.nodeName === \"SELECT\") {\n                        element.focus();\n                        selectedText = element.value;\n                    } else if (element.nodeName === \"INPUT\" || element.nodeName === \"TEXTAREA\") {\n                        var isReadOnly = element.hasAttribute(\"readonly\");\n                        if (!isReadOnly) {\n                            element.setAttribute(\"readonly\", \"\");\n                        }\n                        element.select();\n                        element.setSelectionRange(0, element.value.length);\n                        if (!isReadOnly) {\n                            element.removeAttribute(\"readonly\");\n                        }\n                        selectedText = element.value;\n                    } else {\n                        if (element.hasAttribute(\"contenteditable\")) {\n                            element.focus();\n                        }\n                        var selection = window.getSelection();\n                        var range = document.createRange();\n                        range.selectNodeContents(element);\n                        selection.removeAllRanges();\n                        selection.addRange(range);\n                        selectedText = selection.toString();\n                    }\n                    return selectedText;\n                }\n                module1.exports = select;\n            /***/ },\n            /***/ 279: /***/ function(module1) {\n                function E() {\n                // Keep this empty so it's easier to inherit from\n                // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)\n                }\n                E.prototype = {\n                    on: function(name, callback, ctx) {\n                        var e = this.e || (this.e = {});\n                        (e[name] || (e[name] = [])).push({\n                            fn: callback,\n                            ctx: ctx\n                        });\n                        return this;\n                    },\n                    once: function(name, callback, ctx) {\n                        var self = this;\n                        function listener() {\n                            self.off(name, listener);\n                            callback.apply(ctx, arguments);\n                        }\n                        ;\n                        listener._ = callback;\n                        return this.on(name, listener, ctx);\n                    },\n                    emit: function(name) {\n                        var data = [].slice.call(arguments, 1);\n                        var evtArr = ((this.e || (this.e = {}))[name] || []).slice();\n                        var i = 0;\n                        var len = evtArr.length;\n                        for(i; i < len; i++){\n                            evtArr[i].fn.apply(evtArr[i].ctx, data);\n                        }\n                        return this;\n                    },\n                    off: function(name, callback) {\n                        var e = this.e || (this.e = {});\n                        var evts = e[name];\n                        var liveEvents = [];\n                        if (evts && callback) {\n                            for(var i = 0, len = evts.length; i < len; i++){\n                                if (evts[i].fn !== callback && evts[i].fn._ !== callback) liveEvents.push(evts[i]);\n                            }\n                        }\n                        // Remove event from queue to prevent memory leak\n                        // Suggested by https://github.com/lazd\n                        // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910\n                        liveEvents.length ? e[name] = liveEvents : delete e[name];\n                        return this;\n                    }\n                };\n                module1.exports = E;\n                module1.exports.TinyEmitter = E;\n            /***/ }\n        };\n        /************************************************************************/ /******/ // The module cache\n        /******/ var __webpack_module_cache__ = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_34058__(moduleId) {\n            /******/ // Check if module is in cache\n            /******/ if (__webpack_module_cache__[moduleId]) {\n                /******/ return __webpack_module_cache__[moduleId].exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = __webpack_module_cache__[moduleId] = {\n                /******/ // no module.id needed\n                /******/ // no module.loaded needed\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ __webpack_modules__[moduleId](module1, module1.exports, __nested_webpack_require_34058__);\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /************************************************************************/ /******/ /* webpack/runtime/compat get default export */ /******/ !function() {\n            /******/ // getDefaultExport function for compatibility with non-harmony modules\n            /******/ __nested_webpack_require_34058__.n = function(module1) {\n                /******/ var getter = module1 && module1.__esModule ? /******/ function() {\n                    return module1[\"default\"];\n                } : /******/ function() {\n                    return module1;\n                };\n                /******/ __nested_webpack_require_34058__.d(getter, {\n                    a: getter\n                });\n                /******/ return getter;\n            /******/ };\n        /******/ }();\n        /******/ /******/ /* webpack/runtime/define property getters */ /******/ !function() {\n            /******/ // define getter functions for harmony exports\n            /******/ __nested_webpack_require_34058__.d = function(exports1, definition) {\n                /******/ for(var key in definition){\n                    /******/ if (__nested_webpack_require_34058__.o(definition, key) && !__nested_webpack_require_34058__.o(exports1, key)) {\n                        /******/ Object.defineProperty(exports1, key, {\n                            enumerable: true,\n                            get: definition[key]\n                        });\n                    /******/ }\n                /******/ }\n            /******/ };\n        /******/ }();\n        /******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ !function() {\n            /******/ __nested_webpack_require_34058__.o = function(obj, prop) {\n                return Object.prototype.hasOwnProperty.call(obj, prop);\n            };\n        /******/ }();\n        /******/ /************************************************************************/ /******/ // module exports must be returned from runtime so entry inlining is disabled\n        /******/ // startup\n        /******/ // Load entry module and return exports\n        /******/ return __nested_webpack_require_34058__(686);\n    /******/ }().default;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2xpcGJvYXJkL2Rpc3QvY2xpcGJvYXJkLmpzIiwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Q0FLQyxHQUNBLFVBQVNBLGlDQUFpQ0MsSUFBSSxFQUFFQyxPQUFPO0lBQ3ZELElBQUcsSUFBaUQsRUFDbkRFLE9BQU9ELE9BQU8sR0FBR0Q7U0FDYixFQUs0QkE7QUFDbEMsR0FBRyxRQUFNO0lBQ1QsT0FBZ0IsTUFBSCxHQUFJO1FBQ2pCLE1BQU0sR0FBSSxJQUFJSyxzQkFBdUI7WUFFckMsR0FBRyxHQUFHLEtBQ04sR0FBRyxHQUFJLFNBQVNDLHVCQUF1QixFQUFFQywwQkFBbUIsRUFBRUMsOEJBQW1CO2dCQUVqRjtnQkFFQSxVQUFVO2dCQUNWQSw4QkFBbUJBLENBQUNDLENBQUMsQ0FBQ0YsMEJBQW1CQSxFQUFFO29CQUN6QyxXQUFXO3dCQUFhLE9BQU8sV0FBVyxHQUFHRztvQkFBVztnQkFDMUQ7Z0JBRUEsd0RBQXdEO2dCQUN4RCxJQUFJQyxlQUFlSCw4QkFBbUJBLENBQUM7Z0JBQ3ZDLElBQUlJLHVCQUF1QixXQUFXLEdBQUVKLDhCQUFtQkEsQ0FBQ0ssQ0FBQyxDQUFDRjtnQkFDOUQsOERBQThEO2dCQUM5RCxJQUFJRyxTQUFTTiw4QkFBbUJBLENBQUM7Z0JBQ2pDLElBQUlPLGlCQUFpQixXQUFXLEdBQUVQLDhCQUFtQkEsQ0FBQ0ssQ0FBQyxDQUFDQztnQkFDeEQsdURBQXVEO2dCQUN2RCxJQUFJRSxhQUFhUiw4QkFBbUJBLENBQUM7Z0JBQ3JDLElBQUlTLGlCQUFpQixXQUFXLEdBQUVULDhCQUFtQkEsQ0FBQ0ssQ0FBQyxDQUFDRztrQkFDdkQsK0NBQStDO2dCQUNoRDs7OztDQUlDLEdBQ0QsU0FBU0UsUUFBUUMsSUFBSTtvQkFDbkIsSUFBSTt3QkFDRixPQUFPQyxTQUFTQyxXQUFXLENBQUNGO29CQUM5QixFQUFFLE9BQU9HLEtBQUs7d0JBQ1osT0FBTztvQkFDVDtnQkFDRjtrQkFDQyw0Q0FBNEM7Z0JBRzdDOzs7O0NB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Q1gsTUFBTSxHQUFJO1FBQ1YsTUFBTSxHQUNOLE1BQU0sR0FBSSwyQ0FBMkMsR0FDckQsTUFBTSxHQUFJLENBQUM7WUFDWCxNQUFNLEdBQUssOENBQThDO1lBQ3pELE1BQU0sR0FBS25OLGdDQUFtQkEsQ0FBQ0MsQ0FBQyxHQUFHLFNBQVNSLFFBQU8sRUFBRTZOLFVBQVU7Z0JBQy9ELE1BQU0sR0FBTSxJQUFJLElBQUl0SSxPQUFPc0ksV0FBWTtvQkFDdkMsTUFBTSxHQUFPLElBQUd0TixnQ0FBbUJBLENBQUN5RixDQUFDLENBQUM2SCxZQUFZdEksUUFBUSxDQUFDaEYsZ0NBQW1CQSxDQUFDeUYsQ0FBQyxDQUFDaEcsVUFBU3VGLE1BQU07d0JBQ2hHLE1BQU0sR0FBUUYsT0FBT0MsY0FBYyxDQUFDdEYsVUFBU3VGLEtBQUs7NEJBQUVMLFlBQVk7NEJBQU00SSxLQUFLRCxVQUFVLENBQUN0SSxJQUFJO3dCQUFDO29CQUMzRixNQUFNLEdBQU87Z0JBQ2IsTUFBTSxHQUFNO1lBQ1osTUFBTSxHQUFLO1FBQ1gsTUFBTSxHQUFJO1FBQ1YsTUFBTSxHQUNOLE1BQU0sR0FBSSw0Q0FBNEMsR0FDdEQsTUFBTSxHQUFJLENBQUM7WUFDWCxNQUFNLEdBQUtoRixnQ0FBbUJBLENBQUN5RixDQUFDLEdBQUcsU0FBU3BDLEdBQUcsRUFBRW1LLElBQUk7Z0JBQUksT0FBTzFJLE9BQU9yQixTQUFTLENBQUNnSyxjQUFjLENBQUM5RyxJQUFJLENBQUN0RCxLQUFLbUs7WUFBTztRQUNqSCxNQUFNLEdBQUk7UUFDVixNQUFNLEdBQ04sd0VBQXdFLEdBQ3hFLE1BQU0sR0FBSSw2RUFBNkU7UUFDdkYsTUFBTSxHQUFJLFVBQVU7UUFDcEIsTUFBTSxHQUFJLHVDQUF1QztRQUNqRCxNQUFNLEdBQUksT0FBT3hOLGdDQUFtQkEsQ0FBQztJQUNyQyxNQUFNLEdBQUcsSUFDUjBOLE9BQU87QUFDUiIsInNvdXJjZXMiOlsid2VicGFjazovL2F1dG9jaGVja2VyLy4vbm9kZV9tb2R1bGVzL2NsaXBib2FyZC9kaXN0L2NsaXBib2FyZC5qcz83MTJhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogY2xpcGJvYXJkLmpzIHYyLjAuMTFcbiAqIGh0dHBzOi8vY2xpcGJvYXJkanMuY29tL1xuICpcbiAqIExpY2Vuc2VkIE1JVCDCqSBaZW5vIFJvY2hhXG4gKi9cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkNsaXBib2FyZEpTXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIkNsaXBib2FyZEpTXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKCkgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gNjg2OlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBFWFBPUlRTXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuICBcImRlZmF1bHRcIjogZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGNsaXBib2FyZDsgfVxufSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdGlueS1lbWl0dGVyL2luZGV4LmpzXG52YXIgdGlueV9lbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNzkpO1xudmFyIHRpbnlfZW1pdHRlcl9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubih0aW55X2VtaXR0ZXIpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9nb29kLWxpc3RlbmVyL3NyYy9saXN0ZW4uanNcbnZhciBsaXN0ZW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3MCk7XG52YXIgbGlzdGVuX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGxpc3Rlbik7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3NlbGVjdC9zcmMvc2VsZWN0LmpzXG52YXIgc3JjX3NlbGVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oODE3KTtcbnZhciBzZWxlY3RfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oc3JjX3NlbGVjdCk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tbW9uL2NvbW1hbmQuanNcbi8qKlxuICogRXhlY3V0ZXMgYSBnaXZlbiBvcGVyYXRpb24gdHlwZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBjb21tYW5kKHR5cGUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZXhlY0NvbW1hbmQodHlwZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2FjdGlvbnMvY3V0LmpzXG5cblxuLyoqXG4gKiBDdXQgYWN0aW9uIHdyYXBwZXIuXG4gKiBAcGFyYW0ge1N0cmluZ3xIVE1MRWxlbWVudH0gdGFyZ2V0XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxudmFyIENsaXBib2FyZEFjdGlvbkN1dCA9IGZ1bmN0aW9uIENsaXBib2FyZEFjdGlvbkN1dCh0YXJnZXQpIHtcbiAgdmFyIHNlbGVjdGVkVGV4dCA9IHNlbGVjdF9kZWZhdWx0KCkodGFyZ2V0KTtcbiAgY29tbWFuZCgnY3V0Jyk7XG4gIHJldHVybiBzZWxlY3RlZFRleHQ7XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBhY3Rpb25zX2N1dCA9IChDbGlwYm9hcmRBY3Rpb25DdXQpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbW1vbi9jcmVhdGUtZmFrZS1lbGVtZW50LmpzXG4vKipcbiAqIENyZWF0ZXMgYSBmYWtlIHRleHRhcmVhIGVsZW1lbnQgd2l0aCBhIHZhbHVlLlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmFrZUVsZW1lbnQodmFsdWUpIHtcbiAgdmFyIGlzUlRMID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGlyJykgPT09ICdydGwnO1xuICB2YXIgZmFrZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpOyAvLyBQcmV2ZW50IHpvb21pbmcgb24gaU9TXG5cbiAgZmFrZUVsZW1lbnQuc3R5bGUuZm9udFNpemUgPSAnMTJwdCc7IC8vIFJlc2V0IGJveCBtb2RlbFxuXG4gIGZha2VFbGVtZW50LnN0eWxlLmJvcmRlciA9ICcwJztcbiAgZmFrZUVsZW1lbnQuc3R5bGUucGFkZGluZyA9ICcwJztcbiAgZmFrZUVsZW1lbnQuc3R5bGUubWFyZ2luID0gJzAnOyAvLyBNb3ZlIGVsZW1lbnQgb3V0IG9mIHNjcmVlbiBob3Jpem9udGFsbHlcblxuICBmYWtlRWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIGZha2VFbGVtZW50LnN0eWxlW2lzUlRMID8gJ3JpZ2h0JyA6ICdsZWZ0J10gPSAnLTk5OTlweCc7IC8vIE1vdmUgZWxlbWVudCB0byB0aGUgc2FtZSBwb3NpdGlvbiB2ZXJ0aWNhbGx5XG5cbiAgdmFyIHlQb3NpdGlvbiA9IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wO1xuICBmYWtlRWxlbWVudC5zdHlsZS50b3AgPSBcIlwiLmNvbmNhdCh5UG9zaXRpb24sIFwicHhcIik7XG4gIGZha2VFbGVtZW50LnNldEF0dHJpYnV0ZSgncmVhZG9ubHknLCAnJyk7XG4gIGZha2VFbGVtZW50LnZhbHVlID0gdmFsdWU7XG4gIHJldHVybiBmYWtlRWxlbWVudDtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9hY3Rpb25zL2NvcHkuanNcblxuXG5cbi8qKlxuICogQ3JlYXRlIGZha2UgY29weSBhY3Rpb24gd3JhcHBlciB1c2luZyBhIGZha2UgZWxlbWVudC5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0YXJnZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxudmFyIGZha2VDb3B5QWN0aW9uID0gZnVuY3Rpb24gZmFrZUNvcHlBY3Rpb24odmFsdWUsIG9wdGlvbnMpIHtcbiAgdmFyIGZha2VFbGVtZW50ID0gY3JlYXRlRmFrZUVsZW1lbnQodmFsdWUpO1xuICBvcHRpb25zLmNvbnRhaW5lci5hcHBlbmRDaGlsZChmYWtlRWxlbWVudCk7XG4gIHZhciBzZWxlY3RlZFRleHQgPSBzZWxlY3RfZGVmYXVsdCgpKGZha2VFbGVtZW50KTtcbiAgY29tbWFuZCgnY29weScpO1xuICBmYWtlRWxlbWVudC5yZW1vdmUoKTtcbiAgcmV0dXJuIHNlbGVjdGVkVGV4dDtcbn07XG4vKipcbiAqIENvcHkgYWN0aW9uIHdyYXBwZXIuXG4gKiBAcGFyYW0ge1N0cmluZ3xIVE1MRWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cblxudmFyIENsaXBib2FyZEFjdGlvbkNvcHkgPSBmdW5jdGlvbiBDbGlwYm9hcmRBY3Rpb25Db3B5KHRhcmdldCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge1xuICAgIGNvbnRhaW5lcjogZG9jdW1lbnQuYm9keVxuICB9O1xuICB2YXIgc2VsZWN0ZWRUZXh0ID0gJyc7XG5cbiAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgc2VsZWN0ZWRUZXh0ID0gZmFrZUNvcHlBY3Rpb24odGFyZ2V0LCBvcHRpb25zKTtcbiAgfSBlbHNlIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50ICYmICFbJ3RleHQnLCAnc2VhcmNoJywgJ3VybCcsICd0ZWwnLCAncGFzc3dvcmQnXS5pbmNsdWRlcyh0YXJnZXQgPT09IG51bGwgfHwgdGFyZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YXJnZXQudHlwZSkpIHtcbiAgICAvLyBJZiBpbnB1dCB0eXBlIGRvZXNuJ3Qgc3VwcG9ydCBgc2V0U2VsZWN0aW9uUmFuZ2VgLiBTaW11bGF0ZSBpdC4gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxJbnB1dEVsZW1lbnQvc2V0U2VsZWN0aW9uUmFuZ2VcbiAgICBzZWxlY3RlZFRleHQgPSBmYWtlQ29weUFjdGlvbih0YXJnZXQudmFsdWUsIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHNlbGVjdGVkVGV4dCA9IHNlbGVjdF9kZWZhdWx0KCkodGFyZ2V0KTtcbiAgICBjb21tYW5kKCdjb3B5Jyk7XG4gIH1cblxuICByZXR1cm4gc2VsZWN0ZWRUZXh0O1xufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgYWN0aW9uc19jb3B5ID0gKENsaXBib2FyZEFjdGlvbkNvcHkpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2FjdGlvbnMvZGVmYXVsdC5qc1xuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5cblxuLyoqXG4gKiBJbm5lciBmdW5jdGlvbiB3aGljaCBwZXJmb3JtcyBzZWxlY3Rpb24gZnJvbSBlaXRoZXIgYHRleHRgIG9yIGB0YXJnZXRgXG4gKiBwcm9wZXJ0aWVzIGFuZCB0aGVuIGV4ZWN1dGVzIGNvcHkgb3IgY3V0IG9wZXJhdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbnZhciBDbGlwYm9hcmRBY3Rpb25EZWZhdWx0ID0gZnVuY3Rpb24gQ2xpcGJvYXJkQWN0aW9uRGVmYXVsdCgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAvLyBEZWZpbmVzIGJhc2UgcHJvcGVydGllcyBwYXNzZWQgZnJvbSBjb25zdHJ1Y3Rvci5cbiAgdmFyIF9vcHRpb25zJGFjdGlvbiA9IG9wdGlvbnMuYWN0aW9uLFxuICAgICAgYWN0aW9uID0gX29wdGlvbnMkYWN0aW9uID09PSB2b2lkIDAgPyAnY29weScgOiBfb3B0aW9ucyRhY3Rpb24sXG4gICAgICBjb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lcixcbiAgICAgIHRhcmdldCA9IG9wdGlvbnMudGFyZ2V0LFxuICAgICAgdGV4dCA9IG9wdGlvbnMudGV4dDsgLy8gU2V0cyB0aGUgYGFjdGlvbmAgdG8gYmUgcGVyZm9ybWVkIHdoaWNoIGNhbiBiZSBlaXRoZXIgJ2NvcHknIG9yICdjdXQnLlxuXG4gIGlmIChhY3Rpb24gIT09ICdjb3B5JyAmJiBhY3Rpb24gIT09ICdjdXQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFwiYWN0aW9uXCIgdmFsdWUsIHVzZSBlaXRoZXIgXCJjb3B5XCIgb3IgXCJjdXRcIicpO1xuICB9IC8vIFNldHMgdGhlIGB0YXJnZXRgIHByb3BlcnR5IHVzaW5nIGFuIGVsZW1lbnQgdGhhdCB3aWxsIGJlIGhhdmUgaXRzIGNvbnRlbnQgY29waWVkLlxuXG5cbiAgaWYgKHRhcmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHRhcmdldCAmJiBfdHlwZW9mKHRhcmdldCkgPT09ICdvYmplY3QnICYmIHRhcmdldC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgaWYgKGFjdGlvbiA9PT0gJ2NvcHknICYmIHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFwidGFyZ2V0XCIgYXR0cmlidXRlLiBQbGVhc2UgdXNlIFwicmVhZG9ubHlcIiBpbnN0ZWFkIG9mIFwiZGlzYWJsZWRcIiBhdHRyaWJ1dGUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFjdGlvbiA9PT0gJ2N1dCcgJiYgKHRhcmdldC5oYXNBdHRyaWJ1dGUoJ3JlYWRvbmx5JykgfHwgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFwidGFyZ2V0XCIgYXR0cmlidXRlLiBZb3UgY2FuXFwndCBjdXQgdGV4dCBmcm9tIGVsZW1lbnRzIHdpdGggXCJyZWFkb25seVwiIG9yIFwiZGlzYWJsZWRcIiBhdHRyaWJ1dGVzJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBcInRhcmdldFwiIHZhbHVlLCB1c2UgYSB2YWxpZCBFbGVtZW50Jyk7XG4gICAgfVxuICB9IC8vIERlZmluZSBzZWxlY3Rpb24gc3RyYXRlZ3kgYmFzZWQgb24gYHRleHRgIHByb3BlcnR5LlxuXG5cbiAgaWYgKHRleHQpIHtcbiAgICByZXR1cm4gYWN0aW9uc19jb3B5KHRleHQsIHtcbiAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyXG4gICAgfSk7XG4gIH0gLy8gRGVmaW5lcyB3aGljaCBzZWxlY3Rpb24gc3RyYXRlZ3kgYmFzZWQgb24gYHRhcmdldGAgcHJvcGVydHkuXG5cblxuICBpZiAodGFyZ2V0KSB7XG4gICAgcmV0dXJuIGFjdGlvbiA9PT0gJ2N1dCcgPyBhY3Rpb25zX2N1dCh0YXJnZXQpIDogYWN0aW9uc19jb3B5KHRhcmdldCwge1xuICAgICAgY29udGFpbmVyOiBjb250YWluZXJcbiAgICB9KTtcbiAgfVxufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgYWN0aW9uc19kZWZhdWx0ID0gKENsaXBib2FyZEFjdGlvbkRlZmF1bHQpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NsaXBib2FyZC5qc1xuZnVuY3Rpb24gY2xpcGJvYXJkX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgY2xpcGJvYXJkX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBjbGlwYm9hcmRfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIGNsaXBib2FyZF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKGNsaXBib2FyZF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5cblxuXG5cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gcmV0cmlldmUgYXR0cmlidXRlIHZhbHVlLlxuICogQHBhcmFtIHtTdHJpbmd9IHN1ZmZpeFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gZ2V0QXR0cmlidXRlVmFsdWUoc3VmZml4LCBlbGVtZW50KSB7XG4gIHZhciBhdHRyaWJ1dGUgPSBcImRhdGEtY2xpcGJvYXJkLVwiLmNvbmNhdChzdWZmaXgpO1xuXG4gIGlmICghZWxlbWVudC5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xufVxuLyoqXG4gKiBCYXNlIGNsYXNzIHdoaWNoIHRha2VzIG9uZSBvciBtb3JlIGVsZW1lbnRzLCBhZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGVtLFxuICogYW5kIGluc3RhbnRpYXRlcyBhIG5ldyBgQ2xpcGJvYXJkQWN0aW9uYCBvbiBlYWNoIGNsaWNrLlxuICovXG5cblxudmFyIENsaXBib2FyZCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VtaXR0ZXIpIHtcbiAgX2luaGVyaXRzKENsaXBib2FyZCwgX0VtaXR0ZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQ2xpcGJvYXJkKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd8SFRNTEVsZW1lbnR8SFRNTENvbGxlY3Rpb258Tm9kZUxpc3R9IHRyaWdnZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIENsaXBib2FyZCh0cmlnZ2VyLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENsaXBib2FyZCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpO1xuXG4gICAgX3RoaXMucmVzb2x2ZU9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICBfdGhpcy5saXN0ZW5DbGljayh0cmlnZ2VyKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogRGVmaW5lcyBpZiBhdHRyaWJ1dGVzIHdvdWxkIGJlIHJlc29sdmVkIHVzaW5nIGludGVybmFsIHNldHRlciBmdW5jdGlvbnNcbiAgICogb3IgY3VzdG9tIGZ1bmN0aW9ucyB0aGF0IHdlcmUgcGFzc2VkIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQ2xpcGJvYXJkLCBbe1xuICAgIGtleTogXCJyZXNvbHZlT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlT3B0aW9ucygpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgIHRoaXMuYWN0aW9uID0gdHlwZW9mIG9wdGlvbnMuYWN0aW9uID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5hY3Rpb24gOiB0aGlzLmRlZmF1bHRBY3Rpb247XG4gICAgICB0aGlzLnRhcmdldCA9IHR5cGVvZiBvcHRpb25zLnRhcmdldCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMudGFyZ2V0IDogdGhpcy5kZWZhdWx0VGFyZ2V0O1xuICAgICAgdGhpcy50ZXh0ID0gdHlwZW9mIG9wdGlvbnMudGV4dCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMudGV4dCA6IHRoaXMuZGVmYXVsdFRleHQ7XG4gICAgICB0aGlzLmNvbnRhaW5lciA9IGNsaXBib2FyZF90eXBlb2Yob3B0aW9ucy5jb250YWluZXIpID09PSAnb2JqZWN0JyA/IG9wdGlvbnMuY29udGFpbmVyIDogZG9jdW1lbnQuYm9keTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNsaWNrIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBwYXNzZWQgdHJpZ2dlci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xIVE1MRWxlbWVudHxIVE1MQ29sbGVjdGlvbnxOb2RlTGlzdH0gdHJpZ2dlclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibGlzdGVuQ2xpY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdGVuQ2xpY2sodHJpZ2dlcikge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5fZGVmYXVsdCgpKHRyaWdnZXIsICdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIub25DbGljayhlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGEgbmV3IGBDbGlwYm9hcmRBY3Rpb25gIG9uIGVhY2ggY2xpY2sgZXZlbnQuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25DbGlja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgIHZhciB0cmlnZ2VyID0gZS5kZWxlZ2F0ZVRhcmdldCB8fCBlLmN1cnJlbnRUYXJnZXQ7XG4gICAgICB2YXIgYWN0aW9uID0gdGhpcy5hY3Rpb24odHJpZ2dlcikgfHwgJ2NvcHknO1xuICAgICAgdmFyIHRleHQgPSBhY3Rpb25zX2RlZmF1bHQoe1xuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgY29udGFpbmVyOiB0aGlzLmNvbnRhaW5lcixcbiAgICAgICAgdGFyZ2V0OiB0aGlzLnRhcmdldCh0cmlnZ2VyKSxcbiAgICAgICAgdGV4dDogdGhpcy50ZXh0KHRyaWdnZXIpXG4gICAgICB9KTsgLy8gRmlyZXMgYW4gZXZlbnQgYmFzZWQgb24gdGhlIGNvcHkgb3BlcmF0aW9uIHJlc3VsdC5cblxuICAgICAgdGhpcy5lbWl0KHRleHQgPyAnc3VjY2VzcycgOiAnZXJyb3InLCB7XG4gICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICB0cmlnZ2VyOiB0cmlnZ2VyLFxuICAgICAgICBjbGVhclNlbGVjdGlvbjogZnVuY3Rpb24gY2xlYXJTZWxlY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHRyaWdnZXIpIHtcbiAgICAgICAgICAgIHRyaWdnZXIuZm9jdXMoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGBhY3Rpb25gIGxvb2t1cCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRyaWdnZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlZmF1bHRBY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVmYXVsdEFjdGlvbih0cmlnZ2VyKSB7XG4gICAgICByZXR1cm4gZ2V0QXR0cmlidXRlVmFsdWUoJ2FjdGlvbicsIHRyaWdnZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGB0YXJnZXRgIGxvb2t1cCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRyaWdnZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlZmF1bHRUYXJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVmYXVsdFRhcmdldCh0cmlnZ2VyKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBnZXRBdHRyaWJ1dGVWYWx1ZSgndGFyZ2V0JywgdHJpZ2dlcik7XG5cbiAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93IGZpcmUgcHJvZ3JhbW1hdGljYWxseSBhIGNvcHkgYWN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd8SFRNTEVsZW1lbnR9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybnMgVGV4dCBjb3BpZWQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZWZhdWx0VGV4dFwiLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBgdGV4dGAgbG9va3VwIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdHJpZ2dlclxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWZhdWx0VGV4dCh0cmlnZ2VyKSB7XG4gICAgICByZXR1cm4gZ2V0QXR0cmlidXRlVmFsdWUoJ3RleHQnLCB0cmlnZ2VyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJveSBsaWZlY3ljbGUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmxpc3RlbmVyLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkodGFyZ2V0KSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge1xuICAgICAgICBjb250YWluZXI6IGRvY3VtZW50LmJvZHlcbiAgICAgIH07XG4gICAgICByZXR1cm4gYWN0aW9uc19jb3B5KHRhcmdldCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93IGZpcmUgcHJvZ3JhbW1hdGljYWxseSBhIGN1dCBhY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xIVE1MRWxlbWVudH0gdGFyZ2V0XG4gICAgICogQHJldHVybnMgVGV4dCBjdXR0ZWQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3V0KHRhcmdldCkge1xuICAgICAgcmV0dXJuIGFjdGlvbnNfY3V0KHRhcmdldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHN1cHBvcnQgb2YgdGhlIGdpdmVuIGFjdGlvbiwgb3IgYWxsIGFjdGlvbnMgaWYgbm8gYWN0aW9uIGlzXG4gICAgICogZ2l2ZW4uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFthY3Rpb25dXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc1N1cHBvcnRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1N1cHBvcnRlZCgpIHtcbiAgICAgIHZhciBhY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFsnY29weScsICdjdXQnXTtcbiAgICAgIHZhciBhY3Rpb25zID0gdHlwZW9mIGFjdGlvbiA9PT0gJ3N0cmluZycgPyBbYWN0aW9uXSA6IGFjdGlvbjtcbiAgICAgIHZhciBzdXBwb3J0ID0gISFkb2N1bWVudC5xdWVyeUNvbW1hbmRTdXBwb3J0ZWQ7XG4gICAgICBhY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICBzdXBwb3J0ID0gc3VwcG9ydCAmJiAhIWRvY3VtZW50LnF1ZXJ5Q29tbWFuZFN1cHBvcnRlZChhY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gc3VwcG9ydDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2xpcGJvYXJkO1xufSgodGlueV9lbWl0dGVyX2RlZmF1bHQoKSkpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjbGlwYm9hcmQgPSAoQ2xpcGJvYXJkKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDgyODpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxudmFyIERPQ1VNRU5UX05PREVfVFlQRSA9IDk7XG5cbi8qKlxuICogQSBwb2x5ZmlsbCBmb3IgRWxlbWVudC5tYXRjaGVzKClcbiAqL1xuaWYgKHR5cGVvZiBFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcykge1xuICAgIHZhciBwcm90byA9IEVsZW1lbnQucHJvdG90eXBlO1xuXG4gICAgcHJvdG8ubWF0Y2hlcyA9IHByb3RvLm1hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICAgICAgICAgICAgICBwcm90by5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgcHJvdG8ubXNNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgcHJvdG8ub01hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICAgICAgICAgICAgICBwcm90by53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIGNsb3Nlc3QgcGFyZW50IHRoYXQgbWF0Y2hlcyBhIHNlbGVjdG9yLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gY2xvc2VzdCAoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICB3aGlsZSAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlICE9PSBET0NVTUVOVF9OT0RFX1RZUEUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50Lm1hdGNoZXMgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgIGVsZW1lbnQubWF0Y2hlcyhzZWxlY3RvcikpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9zZXN0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0Mzg6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGNsb3Nlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgyOCk7XG5cbi8qKlxuICogRGVsZWdhdGVzIGV2ZW50IHRvIGEgc2VsZWN0b3IuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtCb29sZWFufSB1c2VDYXB0dXJlXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIF9kZWxlZ2F0ZShlbGVtZW50LCBzZWxlY3RvciwgdHlwZSwgY2FsbGJhY2ssIHVzZUNhcHR1cmUpIHtcbiAgICB2YXIgbGlzdGVuZXJGbiA9IGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXJGbiwgdXNlQ2FwdHVyZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lckZuLCB1c2VDYXB0dXJlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBEZWxlZ2F0ZXMgZXZlbnQgdG8gYSBzZWxlY3Rvci5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8U3RyaW5nfEFycmF5fSBbZWxlbWVudHNdXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtCb29sZWFufSB1c2VDYXB0dXJlXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGRlbGVnYXRlKGVsZW1lbnRzLCBzZWxlY3RvciwgdHlwZSwgY2FsbGJhY2ssIHVzZUNhcHR1cmUpIHtcbiAgICAvLyBIYW5kbGUgdGhlIHJlZ3VsYXIgRWxlbWVudCB1c2FnZVxuICAgIGlmICh0eXBlb2YgZWxlbWVudHMuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gX2RlbGVnYXRlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIEVsZW1lbnQtbGVzcyB1c2FnZSwgaXQgZGVmYXVsdHMgdG8gZ2xvYmFsIGRlbGVnYXRpb25cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVXNlIGBkb2N1bWVudGAgYXMgdGhlIGZpcnN0IHBhcmFtZXRlciwgdGhlbiBhcHBseSBhcmd1bWVudHNcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNob3J0IHdheSB0byAudW5zaGlmdCBgYXJndW1lbnRzYCB3aXRob3V0IHJ1bm5pbmcgaW50byBkZW9wdGltaXphdGlvbnNcbiAgICAgICAgcmV0dXJuIF9kZWxlZ2F0ZS5iaW5kKG51bGwsIGRvY3VtZW50KS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBTZWxlY3Rvci1iYXNlZCB1c2FnZVxuICAgIGlmICh0eXBlb2YgZWxlbWVudHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChlbGVtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIEFycmF5LWxpa2UgYmFzZWQgdXNhZ2VcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKGVsZW1lbnRzLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gX2RlbGVnYXRlKGVsZW1lbnQsIHNlbGVjdG9yLCB0eXBlLCBjYWxsYmFjaywgdXNlQ2FwdHVyZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogRmluZHMgY2xvc2VzdCBtYXRjaCBhbmQgaW52b2tlcyBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gbGlzdGVuZXIoZWxlbWVudCwgc2VsZWN0b3IsIHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5kZWxlZ2F0ZVRhcmdldCA9IGNsb3Nlc3QoZS50YXJnZXQsIHNlbGVjdG9yKTtcblxuICAgICAgICBpZiAoZS5kZWxlZ2F0ZVRhcmdldCkge1xuICAgICAgICAgICAgY2FsbGJhY2suY2FsbChlbGVtZW50LCBlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWxlZ2F0ZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODc5OlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQ2hlY2sgaWYgYXJndW1lbnQgaXMgYSBIVE1MIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLm5vZGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICYmIHZhbHVlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnRcbiAgICAgICAgJiYgdmFsdWUubm9kZVR5cGUgPT09IDE7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGFyZ3VtZW50IGlzIGEgbGlzdCBvZiBIVE1MIGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5ub2RlTGlzdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuXG4gICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWRcbiAgICAgICAgJiYgKHR5cGUgPT09ICdbb2JqZWN0IE5vZGVMaXN0XScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgSFRNTENvbGxlY3Rpb25dJylcbiAgICAgICAgJiYgKCdsZW5ndGgnIGluIHZhbHVlKVxuICAgICAgICAmJiAodmFsdWUubGVuZ3RoID09PSAwIHx8IGV4cG9ydHMubm9kZSh2YWx1ZVswXSkpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhcmd1bWVudCBpcyBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuc3RyaW5nID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJ1xuICAgICAgICB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZztcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYXJndW1lbnQgaXMgYSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuZm4gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcblxuICAgIHJldHVybiB0eXBlID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzcwOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpcyA9IF9fd2VicGFja19yZXF1aXJlX18oODc5KTtcbnZhciBkZWxlZ2F0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDM4KTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgYWxsIHBhcmFtcyBhbmQgY2FsbHMgdGhlIHJpZ2h0XG4gKiBsaXN0ZW5lciBmdW5jdGlvbiBiYXNlZCBvbiBpdHMgdGFyZ2V0IHR5cGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8SFRNTEVsZW1lbnR8SFRNTENvbGxlY3Rpb258Tm9kZUxpc3R9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGxpc3Rlbih0YXJnZXQsIHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0YXJnZXQgJiYgIXR5cGUgJiYgIWNhbGxiYWNrKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBhcmd1bWVudHMnKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzLnN0cmluZyh0eXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIFN0cmluZycpO1xuICAgIH1cblxuICAgIGlmICghaXMuZm4oY2FsbGJhY2spKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXJkIGFyZ3VtZW50IG11c3QgYmUgYSBGdW5jdGlvbicpO1xuICAgIH1cblxuICAgIGlmIChpcy5ub2RlKHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuIGxpc3Rlbk5vZGUodGFyZ2V0LCB0eXBlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzLm5vZGVMaXN0KHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuIGxpc3Rlbk5vZGVMaXN0KHRhcmdldCwgdHlwZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBlbHNlIGlmIChpcy5zdHJpbmcodGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gbGlzdGVuU2VsZWN0b3IodGFyZ2V0LCB0eXBlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgU3RyaW5nLCBIVE1MRWxlbWVudCwgSFRNTENvbGxlY3Rpb24sIG9yIE5vZGVMaXN0Jyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgdG8gYSBIVE1MIGVsZW1lbnRcbiAqIGFuZCByZXR1cm5zIGEgcmVtb3ZlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBsaXN0ZW5Ob2RlKG5vZGUsIHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gYSBsaXN0IG9mIEhUTUwgZWxlbWVudHNcbiAqIGFuZCByZXR1cm5zIGEgcmVtb3ZlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7Tm9kZUxpc3R8SFRNTENvbGxlY3Rpb259IG5vZGVMaXN0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gbGlzdGVuTm9kZUxpc3Qobm9kZUxpc3QsIHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChub2RlTGlzdCwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2spO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKG5vZGVMaXN0LCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEFkZCBhbiBldmVudCBsaXN0ZW5lciB0byBhIHNlbGVjdG9yXG4gKiBhbmQgcmV0dXJucyBhIHJlbW92ZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBsaXN0ZW5TZWxlY3RvcihzZWxlY3RvciwgdHlwZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZGVsZWdhdGUoZG9jdW1lbnQuYm9keSwgc2VsZWN0b3IsIHR5cGUsIGNhbGxiYWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0ZW47XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDgxNzpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuZnVuY3Rpb24gc2VsZWN0KGVsZW1lbnQpIHtcbiAgICB2YXIgc2VsZWN0ZWRUZXh0O1xuXG4gICAgaWYgKGVsZW1lbnQubm9kZU5hbWUgPT09ICdTRUxFQ1QnKSB7XG4gICAgICAgIGVsZW1lbnQuZm9jdXMoKTtcblxuICAgICAgICBzZWxlY3RlZFRleHQgPSBlbGVtZW50LnZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChlbGVtZW50Lm5vZGVOYW1lID09PSAnSU5QVVQnIHx8IGVsZW1lbnQubm9kZU5hbWUgPT09ICdURVhUQVJFQScpIHtcbiAgICAgICAgdmFyIGlzUmVhZE9ubHkgPSBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgncmVhZG9ubHknKTtcblxuICAgICAgICBpZiAoIWlzUmVhZE9ubHkpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdyZWFkb25seScsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuc2VsZWN0KCk7XG4gICAgICAgIGVsZW1lbnQuc2V0U2VsZWN0aW9uUmFuZ2UoMCwgZWxlbWVudC52YWx1ZS5sZW5ndGgpO1xuXG4gICAgICAgIGlmICghaXNSZWFkT25seSkge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3JlYWRvbmx5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxlY3RlZFRleHQgPSBlbGVtZW50LnZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSkge1xuICAgICAgICAgICAgZWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcblxuICAgICAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMoZWxlbWVudCk7XG4gICAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcblxuICAgICAgICBzZWxlY3RlZFRleHQgPSBzZWxlY3Rpb24udG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZWN0ZWRUZXh0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNlbGVjdDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjc5OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5mdW5jdGlvbiBFICgpIHtcbiAgLy8gS2VlcCB0aGlzIGVtcHR5IHNvIGl0J3MgZWFzaWVyIHRvIGluaGVyaXQgZnJvbVxuICAvLyAodmlhIGh0dHBzOi8vZ2l0aHViLmNvbS9saXBzbWFjayBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zY290dGNvcmdhbi90aW55LWVtaXR0ZXIvaXNzdWVzLzMpXG59XG5cbkUucHJvdG90eXBlID0ge1xuICBvbjogZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrLCBjdHgpIHtcbiAgICB2YXIgZSA9IHRoaXMuZSB8fCAodGhpcy5lID0ge30pO1xuXG4gICAgKGVbbmFtZV0gfHwgKGVbbmFtZV0gPSBbXSkpLnB1c2goe1xuICAgICAgZm46IGNhbGxiYWNrLFxuICAgICAgY3R4OiBjdHhcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIG9uY2U6IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaywgY3R4KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGZ1bmN0aW9uIGxpc3RlbmVyICgpIHtcbiAgICAgIHNlbGYub2ZmKG5hbWUsIGxpc3RlbmVyKTtcbiAgICAgIGNhbGxiYWNrLmFwcGx5KGN0eCwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgbGlzdGVuZXIuXyA9IGNhbGxiYWNrXG4gICAgcmV0dXJuIHRoaXMub24obmFtZSwgbGlzdGVuZXIsIGN0eCk7XG4gIH0sXG5cbiAgZW1pdDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgZGF0YSA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgZXZ0QXJyID0gKCh0aGlzLmUgfHwgKHRoaXMuZSA9IHt9KSlbbmFtZV0gfHwgW10pLnNsaWNlKCk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBldnRBcnIubGVuZ3RoO1xuXG4gICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGV2dEFycltpXS5mbi5hcHBseShldnRBcnJbaV0uY3R4LCBkYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBvZmY6IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykge1xuICAgIHZhciBlID0gdGhpcy5lIHx8ICh0aGlzLmUgPSB7fSk7XG4gICAgdmFyIGV2dHMgPSBlW25hbWVdO1xuICAgIHZhciBsaXZlRXZlbnRzID0gW107XG5cbiAgICBpZiAoZXZ0cyAmJiBjYWxsYmFjaykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV2dHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGV2dHNbaV0uZm4gIT09IGNhbGxiYWNrICYmIGV2dHNbaV0uZm4uXyAhPT0gY2FsbGJhY2spXG4gICAgICAgICAgbGl2ZUV2ZW50cy5wdXNoKGV2dHNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBldmVudCBmcm9tIHF1ZXVlIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICAvLyBTdWdnZXN0ZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2xhemRcbiAgICAvLyBSZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS9zY290dGNvcmdhbi90aW55LWVtaXR0ZXIvY29tbWl0L2M2ZWJmYWE5YmM5NzNiMzNkMTEwYTg0YTMwNzc0MmI3Y2Y5NGM5NTMjY29tbWl0Y29tbWVudC01MDI0OTEwXG5cbiAgICAobGl2ZUV2ZW50cy5sZW5ndGgpXG4gICAgICA/IGVbbmFtZV0gPSBsaXZlRXZlbnRzXG4gICAgICA6IGRlbGV0ZSBlW25hbWVdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRTtcbm1vZHVsZS5leHBvcnRzLlRpbnlFbWl0dGVyID0gRTtcblxuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0ICovXG4vKioqKioqLyBcdCFmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMgKi9cbi8qKioqKiovIFx0IWZ1bmN0aW9uKCkge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuLyoqKioqKi8gXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG4vKioqKioqLyBcdFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kICovXG4vKioqKioqLyBcdCFmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmosIHByb3ApIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApOyB9XG4vKioqKioqLyBcdH0oKTtcbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBtb2R1bGUgZXhwb3J0cyBtdXN0IGJlIHJldHVybmVkIGZyb20gcnVudGltZSBzbyBlbnRyeSBpbmxpbmluZyBpcyBkaXNhYmxlZFxuLyoqKioqKi8gXHQvLyBzdGFydHVwXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyg2ODYpO1xuLyoqKioqKi8gfSkoKVxuLmRlZmF1bHQ7XG59KTsiXSwibmFtZXMiOlsid2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJyb290IiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJfX3dlYnBhY2tfbW9kdWxlc19fIiwiX191bnVzZWRfd2VicGFja19tb2R1bGUiLCJfX3dlYnBhY2tfZXhwb3J0c19fIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsImQiLCJjbGlwYm9hcmQiLCJ0aW55X2VtaXR0ZXIiLCJ0aW55X2VtaXR0ZXJfZGVmYXVsdCIsIm4iLCJsaXN0ZW4iLCJsaXN0ZW5fZGVmYXVsdCIsInNyY19zZWxlY3QiLCJzZWxlY3RfZGVmYXVsdCIsImNvbW1hbmQiLCJ0eXBlIiwiZG9jdW1lbnQiLCJleGVjQ29tbWFuZCIsImVyciIsIkNsaXBib2FyZEFjdGlvbkN1dCIsInRhcmdldCIsInNlbGVjdGVkVGV4dCIsImFjdGlvbnNfY3V0IiwiY3JlYXRlRmFrZUVsZW1lbnQiLCJ2YWx1ZSIsImlzUlRMIiwiZG9jdW1lbnRFbGVtZW50IiwiZ2V0QXR0cmlidXRlIiwiZmFrZUVsZW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic3R5bGUiLCJmb250U2l6ZSIsImJvcmRlciIsInBhZGRpbmciLCJtYXJnaW4iLCJwb3NpdGlvbiIsInlQb3NpdGlvbiIsIndpbmRvdyIsInBhZ2VZT2Zmc2V0Iiwic2Nyb2xsVG9wIiwidG9wIiwiY29uY2F0Iiwic2V0QXR0cmlidXRlIiwiZmFrZUNvcHlBY3Rpb24iLCJvcHRpb25zIiwiY29udGFpbmVyIiwiYXBwZW5kQ2hpbGQiLCJyZW1vdmUiLCJDbGlwYm9hcmRBY3Rpb25Db3B5IiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiYm9keSIsIkhUTUxJbnB1dEVsZW1lbnQiLCJpbmNsdWRlcyIsImFjdGlvbnNfY29weSIsIl90eXBlb2YiLCJvYmoiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiQ2xpcGJvYXJkQWN0aW9uRGVmYXVsdCIsIl9vcHRpb25zJGFjdGlvbiIsImFjdGlvbiIsInRleHQiLCJFcnJvciIsIm5vZGVUeXBlIiwiaGFzQXR0cmlidXRlIiwiYWN0aW9uc19kZWZhdWx0IiwiY2xpcGJvYXJkX3R5cGVvZiIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInByb3BzIiwiaSIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsIl9zZXRQcm90b3R5cGVPZiIsIm8iLCJwIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJfY3JlYXRlU3VwZXIiLCJEZXJpdmVkIiwiaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJfY3JlYXRlU3VwZXJJbnRlcm5hbCIsIlN1cGVyIiwiX2dldFByb3RvdHlwZU9mIiwicmVzdWx0IiwiTmV3VGFyZ2V0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsImFwcGx5IiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJzZWxmIiwiY2FsbCIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsInNoYW0iLCJQcm94eSIsIkRhdGUiLCJ0b1N0cmluZyIsImUiLCJnZXRQcm90b3R5cGVPZiIsImdldEF0dHJpYnV0ZVZhbHVlIiwic3VmZml4IiwiZWxlbWVudCIsImF0dHJpYnV0ZSIsIkNsaXBib2FyZCIsIl9FbWl0dGVyIiwiX3N1cGVyIiwidHJpZ2dlciIsIl90aGlzIiwicmVzb2x2ZU9wdGlvbnMiLCJsaXN0ZW5DbGljayIsImRlZmF1bHRBY3Rpb24iLCJkZWZhdWx0VGFyZ2V0IiwiZGVmYXVsdFRleHQiLCJfdGhpczIiLCJsaXN0ZW5lciIsIm9uQ2xpY2siLCJkZWxlZ2F0ZVRhcmdldCIsImN1cnJlbnRUYXJnZXQiLCJlbWl0IiwiY2xlYXJTZWxlY3Rpb24iLCJmb2N1cyIsImdldFNlbGVjdGlvbiIsInJlbW92ZUFsbFJhbmdlcyIsInNlbGVjdG9yIiwicXVlcnlTZWxlY3RvciIsImRlc3Ryb3kiLCJjb3B5IiwiY3V0IiwiaXNTdXBwb3J0ZWQiLCJhY3Rpb25zIiwic3VwcG9ydCIsInF1ZXJ5Q29tbWFuZFN1cHBvcnRlZCIsImZvckVhY2giLCJET0NVTUVOVF9OT0RFX1RZUEUiLCJFbGVtZW50IiwibWF0Y2hlcyIsInByb3RvIiwibWF0Y2hlc1NlbGVjdG9yIiwibW96TWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJvTWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwiY2xvc2VzdCIsInBhcmVudE5vZGUiLCJfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMiLCJfZGVsZWdhdGUiLCJjYWxsYmFjayIsInVzZUNhcHR1cmUiLCJsaXN0ZW5lckZuIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkZWxlZ2F0ZSIsImVsZW1lbnRzIiwiYmluZCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJBcnJheSIsIm1hcCIsIm5vZGUiLCJIVE1MRWxlbWVudCIsIm5vZGVMaXN0Iiwic3RyaW5nIiwiU3RyaW5nIiwiZm4iLCJpcyIsImxpc3Rlbk5vZGUiLCJsaXN0ZW5Ob2RlTGlzdCIsImxpc3RlblNlbGVjdG9yIiwic2VsZWN0Iiwibm9kZU5hbWUiLCJpc1JlYWRPbmx5Iiwic2V0U2VsZWN0aW9uUmFuZ2UiLCJyZW1vdmVBdHRyaWJ1dGUiLCJzZWxlY3Rpb24iLCJyYW5nZSIsImNyZWF0ZVJhbmdlIiwic2VsZWN0Tm9kZUNvbnRlbnRzIiwiYWRkUmFuZ2UiLCJFIiwib24iLCJuYW1lIiwiY3R4IiwicHVzaCIsIm9uY2UiLCJvZmYiLCJfIiwiZGF0YSIsInNsaWNlIiwiZXZ0QXJyIiwibGVuIiwiZXZ0cyIsImxpdmVFdmVudHMiLCJUaW55RW1pdHRlciIsIl9fd2VicGFja19tb2R1bGVfY2FjaGVfXyIsIm1vZHVsZUlkIiwiZ2V0dGVyIiwiX19lc01vZHVsZSIsImEiLCJkZWZpbml0aW9uIiwiZ2V0IiwicHJvcCIsImhhc093blByb3BlcnR5IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/clipboard/dist/clipboard.js\n");

/***/ })

};
;